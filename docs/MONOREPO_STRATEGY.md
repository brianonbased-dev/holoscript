# Multi-Language Monorepo Strategy for HoloScript

**Research Topic**: Rust + TypeScript FFI Communication & Dependency Resolution
**Date**: 2026-02-12
**Status**: Production-Ready Implementation Guide

---

## Executive Summary

HoloScript's dual-language architecture (Rust compiler + TypeScript tooling) requires careful dependency management across the FFI boundary. This guide provides the **canonical strategy** for type-safe, maintainable cross-language communication.

**Key Decision**: Use **Typeshare** for automatic type generation between Rust and TypeScript.

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│ HoloScript Monorepo                                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Rust Packages                    TypeScript Packages      │
│  ┌──────────────────┐            ┌──────────────────┐     │
│  │ compiler-wasm    │────types──>│ @holoscript/core │     │
│  │ (Rust → WASM)    │   via      │ (TS + WASM FFI)  │     │
│  └──────────────────┘  typeshare └──────────────────┘     │
│          │                                │                │
│          │                                │                │
│  ┌──────────────────┐            ┌──────────────────┐     │
│  │ holoscript-      │────types──>│ @holoscript/lsp  │     │
│  │ component        │   via      │ (TS Language     │     │
│  │ (WASI 0.3)       │  typeshare │  Server)         │     │
│  └──────────────────┘            └──────────────────┘     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Implementation: Typeshare Integration

### Step 1: Add Typeshare to Rust Packages

```toml
# packages/compiler-wasm/Cargo.toml
[dependencies]
typeshare = "1.0"
serde = { workspace = true }
serde_json = { workspace = true }
wasm-bindgen = { workspace = true }

[build-dependencies]
typeshare = "1.0"
```

### Step 2: Annotate Rust Types

```rust
// packages/compiler-wasm/src/ast.rs
use typeshare::typeshare;
use serde::{Serialize, Deserialize};

/// HoloScript AST Node
#[typeshare]
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ASTNode {
    pub node_type: NodeType,
    pub position: Position,
    pub children: Vec<ASTNode>,
}

#[typeshare]
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(tag = "type")]
pub enum NodeType {
    Object { name: String, traits: Vec<String> },
    Property { key: String, value: Value },
    Scene { name: String, objects: Vec<String> },
}

#[typeshare]
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Position {
    pub line: u32,
    pub column: u32,
    pub offset: usize,
}

#[typeshare]
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(untagged)]
pub enum Value {
    String(String),
    Number(f64),
    Boolean(bool),
    Array(Vec<Value>),
    Object(std::collections::HashMap<String, Value>),
}
```

### Step 3: Generate TypeScript Types

```bash
# Add to package.json scripts
{
  "scripts": {
    "generate-types": "typeshare packages/compiler-wasm/src --lang=typescript --output-file=packages/core/src/types/generated.ts"
  }
}
```

Generated TypeScript (`packages/core/src/types/generated.ts`):

```typescript
// Auto-generated by typeshare - DO NOT EDIT

export interface ASTNode {
  node_type: NodeType;
  position: Position;
  children: ASTNode[];
}

export type NodeType =
  | { type: "Object"; name: string; traits: string[] }
  | { type: "Property"; key: string; value: Value }
  | { type: "Scene"; name: string; objects: string[] };

export interface Position {
  line: number;
  column: number;
  offset: number;
}

export type Value =
  | string
  | number
  | boolean
  | Value[]
  | { [key: string]: Value };
```

### Step 4: Use Generated Types in TypeScript

```typescript
// packages/core/src/parser.ts
import { ASTNode, NodeType, Position } from './types/generated';
import init, { parse as wasmParse } from '@holoscript/wasm-parser';

export class Parser {
  async parse(source: string): Promise<ASTNode> {
    await init(); // Initialize WASM module

    // WASM returns JSON matching Rust types
    const json = wasmParse(source);

    // TypeScript knows exact shape thanks to typeshare
    const ast: ASTNode = JSON.parse(json);

    return ast;
  }
}
```

---

## Dependency Resolution Patterns

### Pattern 1: Rust → TypeScript (WASM Boundary)

**Use Case**: Rust compiler exposes API to TypeScript

**Implementation**:
```rust
// packages/compiler-wasm/src/lib.rs
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn parse(source: &str) -> Result<String, JsValue> {
    let ast = holoscript_parser::parse(source)
        .map_err(|e| JsValue::from_str(&e.to_string()))?;

    // Serialize to JSON (types match TypeScript thanks to typeshare)
    serde_json::to_string(&ast)
        .map_err(|e| JsValue::from_str(&e.to_string()))
}
```

```typescript
// packages/core/src/compiler.ts
import { parse } from '@holoscript/wasm-parser';
import type { ASTNode } from './types/generated';

export async function compile(source: string): Promise<ASTNode> {
  const json = parse(source);
  return JSON.parse(json) as ASTNode; // Type-safe!
}
```

### Pattern 2: TypeScript → Rust (Callback/Host Functions)

**Use Case**: Rust WASM calls TypeScript host functions

**Implementation**:
```rust
// packages/compiler-wasm/src/lib.rs
#[wasm_bindgen]
extern "C" {
    // Import TypeScript function
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);

    // Import custom host function
    #[wasm_bindgen(js_name = "readFile")]
    fn read_file_js(path: &str) -> String;
}

#[wasm_bindgen]
pub fn compile_file(path: &str) -> Result<String, JsValue> {
    // Call TypeScript host function from Rust
    let source = read_file_js(path);
    log(&format!("Compiling: {}", path));

    parse(&source)
}
```

```typescript
// packages/core/src/host.ts
import { readFileSync } from 'fs';

// Host function called by Rust WASM
(globalThis as any).readFile = (path: string): string => {
  return readFileSync(path, 'utf-8');
};
```

### Pattern 3: Shared Dependencies (Avoid Duplication)

**Problem**: Both Rust and TypeScript need same logic (e.g., trait validation)

**Solution**: Implement in Rust, expose via WASM

```rust
// packages/compiler-wasm/src/traits.rs
#[typeshare]
#[derive(Serialize, Deserialize)]
pub struct Trait {
    pub name: String,
    pub compatible_geometry: Vec<String>,
}

#[wasm_bindgen]
pub fn validate_trait(trait_name: &str, geometry: &str) -> bool {
    TRAIT_RULES.get(trait_name)
        .map(|t| t.compatible_geometry.contains(&geometry.to_string()))
        .unwrap_or(false)
}
```

```typescript
// packages/core/src/validation.ts
import { validate_trait } from '@holoscript/wasm-parser';

// Use Rust validation from TypeScript
export function isTraitCompatible(trait: string, geometry: string): boolean {
  return validate_trait(trait, geometry);
}
```

---

## Build Orchestration

### Using Moon Task Runner

[Moon](https://moonrepo.dev/moon) is a Rust-based task runner designed for monorepos with multiple languages.

```yaml
# moon.yml (workspace root)
$schema: 'https://moonrepo.dev/schemas/workspace.json'

projects:
  - 'packages/*'

tasks:
  build:
    command: 'moon run :build'
    deps:
      - 'generate-types'

  generate-types:
    command: 'pnpm run generate-types'
    inputs:
      - 'packages/compiler-wasm/src/**/*.rs'
      - 'packages/holoscript-component/src/**/*.rs'
    outputs:
      - 'packages/core/src/types/generated.ts'
```

```yaml
# packages/compiler-wasm/moon.yml
$schema: 'https://moonrepo.dev/schemas/project.json'

tasks:
  build:
    command: 'wasm-pack build --target bundler'
    inputs:
      - 'src/**/*.rs'
      - 'Cargo.toml'
    outputs:
      - 'pkg/**/*'
```

```yaml
# packages/core/moon.yml
$schema: 'https://moonrepo.dev/schemas/project.json'

tasks:
  build:
    command: 'tsup'
    deps:
      - '^build' # Wait for Rust packages to build first
    inputs:
      - 'src/**/*.ts'
      - 'tsconfig.json'
    outputs:
      - 'dist/**/*'
```

### Dependency Graph

```
generate-types → compiler-wasm:build → core:build → lsp:build
                                    ↘
                                      vscode-extension:build
```

---

## Testing Across FFI Boundary

### Rust Tests

```rust
// packages/compiler-wasm/tests/integration.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_generates_valid_json() {
        let source = r#"
            object "TestCube" {
                geometry: "cube"
            }
        "#;

        let result = parse(source).expect("Parse failed");
        let ast: ASTNode = serde_json::from_str(&result).expect("Invalid JSON");

        assert_eq!(ast.children.len(), 1);
    }
}
```

### TypeScript Tests

```typescript
// packages/core/src/__tests__/parser.test.ts
import { describe, it, expect } from 'vitest';
import { Parser } from '../parser';
import type { ASTNode } from '../types/generated';

describe('Parser', () => {
  it('should parse HoloScript and return valid AST', async () => {
    const parser = new Parser();
    const ast: ASTNode = await parser.parse(`
      object "TestCube" {
        geometry: "cube"
      }
    `);

    // TypeScript knows exact shape of AST
    expect(ast.children).toHaveLength(1);
    expect(ast.children[0].node_type).toMatchObject({
      type: 'Object',
      name: 'TestCube'
    });
  });
});
```

---

## Troubleshooting

### Issue: Type Mismatch After Rust Changes

**Symptom**: TypeScript errors after updating Rust types

**Cause**: Forgot to regenerate types

**Fix**:
```bash
pnpm run generate-types
pnpm build
```

### Issue: WASM Module Not Found

**Symptom**: `Cannot find module '@holoscript/wasm-parser'`

**Cause**: Rust package not built or not linked

**Fix**:
```bash
cd packages/compiler-wasm
wasm-pack build --target bundler
cd ../../packages/core
pnpm link ../compiler-wasm/pkg
```

### Issue: Slow Incremental Builds

**Symptom**: Rebuilding Rust changes takes 2-3 minutes

**Cause**: TypeScript packages wait for full Rust rebuild

**Fix**: Use Moon's cache:
```bash
moon run :build --cache
```

---

## Performance Optimization

### 1. Lazy WASM Initialization

```typescript
// packages/core/src/lazy-init.ts
let wasmInitialized = false;

export async function ensureWasmInit(): Promise<void> {
  if (wasmInitialized) return;

  await init(); // From @holoscript/wasm-parser
  wasmInitialized = true;
}
```

### 2. WASM Module Caching

```typescript
// packages/vscode-extension/src/extension.ts
import { promises as fs } from 'fs';
import { join } from 'path';

// Cache WASM module in extension context
export async function activate(context: vscode.ExtensionContext) {
  const wasmPath = join(context.extensionPath, 'wasm', 'holoscript_bg.wasm');
  const wasmBytes = await fs.readFile(wasmPath);

  await init(wasmBytes); // Pass bytes directly, skip fetch
}
```

### 3. Parallel Rust + TypeScript Builds

```yaml
# .github/workflows/ci.yml
jobs:
  build:
    strategy:
      matrix:
        package: [compiler-wasm, holoscript-component, core, lsp]
    steps:
      - name: Build ${{ matrix.package }}
        run: pnpm --filter @holoscript/${{ matrix.package }} build
```

---

## Future Enhancements

1. **Automatic Type Generation in Watch Mode**
   ```bash
   pnpm run dev:types # Watches Rust files, regenerates on change
   ```

2. **WASM Component Model Migration**
   - Move from wasm-bindgen → WASI 0.3 components
   - Eliminates JSON serialization overhead
   - Native interface types

3. **Tree-shakeable WASM Modules**
   - Split compiler into feature modules
   - Only load required features
   - Reduces bundle size for browser

---

## References

- [Typeshare Documentation](https://1password.github.io/typeshare/)
- [TypeScript-Rust FFI Monorepo Starter](https://github.com/beauwilliams/typescript-rust-ffi-monorepo-starter)
- [Moon Monorepo Tool](https://moonrepo.dev/moon)
- [wasm-bindgen Book](https://rustwasm.github.io/wasm-bindgen/)

---

**Last Updated**: 2026-02-12
**Status**: ✅ Production-Ready
**Next Review**: Q3 2026
