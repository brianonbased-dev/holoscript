<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HoloScript Browser Preview</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #1a1a2e; 
      color: #fff;
      overflow: hidden;
    }
    #container { width: 100vw; height: 100vh; position: relative; }
    #canvas { width: 100%; height: 100%; display: block; }
    #overlay {
      position: absolute; top: 0; left: 0; right: 0;
      padding: 15px; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
      display: flex; justify-content: space-between; align-items: center;
    }
    #file-name { font-size: 14px; font-weight: 500; }
    #toolbar { display: flex; gap: 10px; }
    .toolbar-btn {
      background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px; color: #fff; padding: 8px 14px; cursor: pointer;
      font-size: 13px; transition: all 0.2s;
    }
    .toolbar-btn:hover { background: rgba(255,255,255,0.2); }
    .toolbar-btn.active { background: #007acc; border-color: #007acc; }
    #stats {
      position: absolute; bottom: 15px; left: 15px;
      background: rgba(0,0,0,0.8); padding: 12px 16px; border-radius: 8px;
      font-size: 12px; font-family: monospace;
    }
    #code-panel {
      position: absolute; left: 15px; top: 60px; bottom: 60px; width: 400px;
      background: rgba(0,0,0,0.9); border-radius: 8px; overflow: hidden;
      display: flex; flex-direction: column;
    }
    #code-panel.hidden { display: none; }
    #code-header { padding: 10px 15px; background: rgba(255,255,255,0.1); font-weight: 500; }
    #code-editor {
      flex: 1; padding: 15px; font-family: 'Fira Code', monospace; font-size: 12px;
      background: transparent; color: #e0e0e0; border: none; resize: none;
      outline: none; overflow: auto;
    }
    #load-btn {
      position: absolute; bottom: 10px; right: 10px;
      background: #007acc; border: none; border-radius: 6px;
      color: white; padding: 10px 20px; cursor: pointer; font-weight: 500;
    }
    #file-input { display: none; }
    #drop-zone {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      text-align: center; padding: 40px; border: 2px dashed rgba(255,255,255,0.3);
      border-radius: 16px; background: rgba(0,0,0,0.5);
    }
    #drop-zone h2 { margin-bottom: 15px; }
    #drop-zone p { color: #888; margin-bottom: 20px; }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas"></canvas>
    <div id="overlay">
      <span id="file-name">Drag & Drop .hs file or click Load</span>
      <div id="toolbar">
        <button class="toolbar-btn" id="btn-code">üìù Code</button>
        <button class="toolbar-btn" id="btn-reset">üé• Reset</button>
        <button class="toolbar-btn" id="btn-wireframe">üî≤ Wire</button>
        <button class="toolbar-btn" id="btn-grid" class="active">üìê Grid</button>
        <button class="toolbar-btn" id="btn-axes" class="active">üìä Axes</button>
        <label class="toolbar-btn" for="file-input">üìÅ Load</label>
        <input type="file" id="file-input" accept=".hs,.hsplus,.holo">
      </div>
    </div>
    <div id="stats">
      Objects: <span id="stat-objects">0</span>
    </div>
    <div id="code-panel" class="hidden">
      <div id="code-header">HoloScript Code</div>
      <textarea id="code-editor" spellcheck="false"></textarea>
      <button id="load-btn">Render</button>
    </div>
    <div id="drop-zone">
      <h2>üåê HoloScript Browser Preview</h2>
      <p>Drag & drop a .hs, .hsplus, or .holo file here</p>
      <label class="toolbar-btn" for="file-input" style="display: inline-block;">üìÅ Or Click to Load File</label>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    let scene, camera, renderer, controls;
    let objects = [], animatedObjects = [], particleSystems = [];
    let gridHelper, axesHelper;
    let wireframeMode = false, showGrid = true, showAxes = true;
    let clock;

    function init() {
      const canvas = document.getElementById('canvas');
      const container = document.getElementById('container');

      clock = new THREE.Clock();
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);
      scene.fog = new THREE.Fog(0x1a1a2e, 10, 50);

      camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
      camera.position.set(8, 6, 8);

      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.2;

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Grid & Axes
      gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x333333);
      scene.add(gridHelper);
      axesHelper = new THREE.AxesHelper(5);
      scene.add(axesHelper);

      // Lights
      const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x3d3d5c, 0.6);
      scene.add(hemiLight);

      const keyLight = new THREE.DirectionalLight(0xfff5e6, 2.0);
      keyLight.position.set(5, 10, 5);
      keyLight.castShadow = true;
      keyLight.shadow.mapSize.width = 2048;
      keyLight.shadow.mapSize.height = 2048;
      scene.add(keyLight);

      const fillLight = new THREE.DirectionalLight(0x8ec8ff, 0.8);
      fillLight.position.set(-5, 3, -5);
      scene.add(fillLight);

      const rimLight = new THREE.DirectionalLight(0xffffff, 0.5);
      rimLight.position.set(0, 5, -10);
      scene.add(rimLight);

      // Ground
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(100, 100),
        new THREE.ShadowMaterial({ opacity: 0.3 })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      window.addEventListener('resize', onResize);
      setupEventListeners();
      animate();
    }

    function onResize() {
      const container = document.getElementById('container');
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const elapsed = clock.getElapsedTime();

      // Animate objects
      animatedObjects.forEach(item => {
        const { mesh, type, speed, amplitude, radius, originalY, originalPos } = item;
        const t = elapsed * speed;
        
        switch (type) {
          case 'spin':
            mesh.rotation.y += delta * speed * 2;
            break;
          case 'float':
            mesh.position.y = originalY + Math.sin(t * 2) * amplitude;
            break;
          case 'pulse':
            const s = 1 + Math.sin(t * 3) * 0.15;
            mesh.scale.set(s, s, s);
            break;
          case 'orbit':
            mesh.position.x = originalPos.x + Math.cos(t) * radius;
            mesh.position.z = originalPos.z + Math.sin(t) * radius;
            break;
          case 'bob':
            mesh.position.y = originalY + Math.sin(t * 4) * amplitude * 0.5;
            break;
          case 'sway':
            mesh.rotation.z = Math.sin(t * 2) * amplitude;
            break;
          case 'flicker':
            if (mesh.material.emissiveIntensity !== undefined) {
              mesh.material.emissiveIntensity = 0.5 + Math.random() * 0.5;
            }
            break;
          case 'rainbow':
            if (mesh.material.color) {
              mesh.material.color.setHSL((t * 0.1) % 1, 0.8, 0.5);
            }
            break;
        }
      });

      // Animate particles
      particleSystems.forEach(ps => {
        const positions = ps.geometry.attributes.position.array;
        const velocities = ps.userData.velocities;
        for (let i = 0; i < positions.length; i += 3) {
          positions[i] += velocities[i] * delta;
          positions[i + 1] += velocities[i + 1] * delta;
          positions[i + 2] += velocities[i + 2] * delta;
          if (positions[i + 1] > ps.userData.maxHeight) {
            positions[i + 1] = ps.userData.baseY;
            positions[i] = ps.userData.baseX + (Math.random() - 0.5) * ps.userData.spread;
            positions[i + 2] = ps.userData.baseZ + (Math.random() - 0.5) * ps.userData.spread;
          }
        }
        ps.geometry.attributes.position.needsUpdate = true;
      });

      controls.update();
      renderer.render(scene, camera);
    }

    function setupEventListeners() {
      document.getElementById('btn-reset').onclick = () => {
        camera.position.set(8, 6, 8);
        controls.reset();
      };

      document.getElementById('btn-wireframe').onclick = () => {
        wireframeMode = !wireframeMode;
        objects.forEach(obj => {
          if (obj.material) obj.material.wireframe = wireframeMode;
        });
        document.getElementById('btn-wireframe').classList.toggle('active', wireframeMode);
      };

      document.getElementById('btn-grid').onclick = () => {
        showGrid = !showGrid;
        gridHelper.visible = showGrid;
        document.getElementById('btn-grid').classList.toggle('active', showGrid);
      };

      document.getElementById('btn-axes').onclick = () => {
        showAxes = !showAxes;
        axesHelper.visible = showAxes;
        document.getElementById('btn-axes').classList.toggle('active', showAxes);
      };

      document.getElementById('btn-code').onclick = () => {
        document.getElementById('code-panel').classList.toggle('hidden');
      };

      document.getElementById('load-btn').onclick = () => {
        const code = document.getElementById('code-editor').value;
        if (code.trim()) {
          parseAndRender(code);
          document.getElementById('drop-zone').style.display = 'none';
        }
      };

      document.getElementById('file-input').onchange = (e) => {
        const file = e.target.files[0];
        if (file) loadFile(file);
      };

      // Drag and drop
      const container = document.getElementById('container');
      container.ondragover = (e) => { e.preventDefault(); };
      container.ondrop = (e) => {
        e.preventDefault();
        const file = e.dataTransfer.files[0];
        if (file && /\.(hs|hsplus|holo)$/i.test(file.name)) {
          loadFile(file);
        }
      };
    }

    function loadFile(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        const content = e.target.result;
        document.getElementById('file-name').textContent = file.name;
        document.getElementById('code-editor').value = content;
        document.getElementById('drop-zone').style.display = 'none';
        parseAndRender(content);
      };
      reader.readAsText(file);
    }

    function clearScene() {
      objects.forEach(obj => {
        scene.remove(obj);
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
          else obj.material.dispose();
        }
      });
      objects = [];
      animatedObjects = [];
      particleSystems = [];
      scene.fog = null;
      scene.background = new THREE.Color(0x1a1a2e);
    }

    function getColorValue(colorStr) {
      if (!colorStr) return 0x4a9eff;
      colorStr = colorStr.toLowerCase().replace('#', '');
      if (/^[0-9a-f]{6}$/i.test(colorStr)) return parseInt(colorStr, 16);
      const colors = {
        red: 0xe53935, green: 0x43a047, blue: 0x1e88e5, yellow: 0xfdd835,
        cyan: 0x00acc1, magenta: 0xd81b60, white: 0xfafafa, black: 0x212121,
        gray: 0x757575, purple: 0x8e24aa, orange: 0xfb8c00, pink: 0xf06292,
        gold: 0xffc107, silver: 0xbdbdbd, bronze: 0xcd7f32, copper: 0xb87333,
        teal: 0x00897b, indigo: 0x5c6bc0, lime: 0xc0ca33, coral: 0xff7043,
        navy: 0x283593, sky: 0x4fc3f7, forest: 0x2e7d32, rose: 0xec407a,
        ice: 0xe1f5fe, lava: 0xff5722, neon: 0x39ff14, plasma: 0xff073a,
        hologram: 0x00fff7, energy: 0xffea00, crystal: 0xb3e5fc, nebula: 0x7b1fa2
      };
      return colors[colorStr] || 0x4a9eff;
    }

    function applySkybox(type) {
      const gradients = {
        sunset: [0xffd27f, 0xff6b6b, 0x1a0a3e],
        night: [0x0a0a1a, 0x0f0f2a, 0x1a1a3e],
        nebula: [0x7b1fa2, 0x4a148c, 0x0a0a1a],
        sky: [0x87ceeb, 0x4fc3f7, 0xffffff],
        underwater: [0x006994, 0x003d5b, 0x001524],
        void: [0x0a0a0f, 0x0a0a0f, 0x0a0a0f],
        cyberpunk: [0x0d0221, 0x1a0a3e, 0x7b1fa2]
      };
      
      if (gradients[type]) {
        const [top, mid, bottom] = gradients[type];
        const canvas = document.createElement('canvas');
        canvas.width = 2; canvas.height = 512;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createLinearGradient(0, 0, 0, 512);
        grad.addColorStop(0, '#' + top.toString(16).padStart(6, '0'));
        grad.addColorStop(0.5, '#' + mid.toString(16).padStart(6, '0'));
        grad.addColorStop(1, '#' + bottom.toString(16).padStart(6, '0'));
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 2, 512);
        const texture = new THREE.CanvasTexture(canvas);
        texture.mapping = THREE.EquirectangularReflectionMapping;
        scene.background = texture;
      } else {
        scene.background = new THREE.Color(getColorValue(type));
      }
    }

    function parseAndRender(content) {
      clearScene();
      console.log('Parsing content, length:', content.length);

      try {
        // Extract balanced braces
        function extractBraces(str, startIdx) {
          let depth = 0, start = -1;
          for (let i = startIdx; i < str.length; i++) {
            if (str[i] === '{') { if (depth === 0) start = i + 1; depth++; }
            else if (str[i] === '}') { depth--; if (depth === 0) return str.slice(start, i); }
          }
          return '';
        }

        // Parse environment
        const envMatch = content.match(/environment\s*[:{]\s*\{([^}]+)\}/);
        if (envMatch) {
          const skyboxMatch = envMatch[1].match(/skybox\s*:\s*['"]([^'"]+)['"]/);
          if (skyboxMatch) applySkybox(skyboxMatch[1].toLowerCase());
        }

        // Parse objects
        const orbPattern = /(?:orb|object(?:\[\])?|button|slider)\s+["']?([\w_]+)["']?(?:\s+using\s+["']([\w_]+)["'])?(?:\s+@[\w]+)*\s*\{/g;
        let match, count = 0;

        while ((match = orbPattern.exec(content)) !== null) {
          const name = match[1];
          const props = extractBraces(content, match.index);
          
          console.log('Found object:', name, 'props length:', props.length);

          // Parse position
          let position = [0, 0, 0];
          const posArr = props.match(/position\s*:\s*\[([^\]]+)\]/);
          const posObj = props.match(/position\s*:\s*\{\s*x\s*:\s*([\d.-]+)\s*,\s*y\s*:\s*([\d.-]+)\s*,\s*z\s*:\s*([\d.-]+)\s*\}/);
          if (posArr) position = posArr[1].split(',').map(n => parseFloat(n.trim()) || 0);
          else if (posObj) position = [parseFloat(posObj[1]), parseFloat(posObj[2]), parseFloat(posObj[3])];

          // Parse scale
          let scale = [1, 1, 1];
          const scaleArr = props.match(/scale\s*:\s*\[([^\]]+)\]/);
          const scaleNum = props.match(/scale\s*:\s*([\d.]+)/);
          const scaleObj = props.match(/scale\s*:\s*\{\s*x\s*:\s*([\d.-]+)\s*,\s*y\s*:\s*([\d.-]+)\s*,\s*z\s*:\s*([\d.-]+)\s*\}/);
          if (scaleArr) scale = scaleArr[1].split(',').map(n => parseFloat(n.trim()) || 1);
          else if (scaleObj) scale = [parseFloat(scaleObj[1]), parseFloat(scaleObj[2]), parseFloat(scaleObj[3])];
          else if (scaleNum) { const s = parseFloat(scaleNum[1]); scale = [s, s, s]; }

          // Parse rotation
          let rotation = [0, 0, 0];
          const rotArr = props.match(/rotation\s*:\s*\[([^\]]+)\]/);
          const rotObj = props.match(/rotation\s*:\s*\{\s*x\s*:\s*([\d.-]+)\s*,\s*y\s*:\s*([\d.-]+)\s*,\s*z\s*:\s*([\d.-]+)\s*\}/);
          if (rotArr) rotation = rotArr[1].split(',').map(n => (parseFloat(n.trim()) || 0) * Math.PI / 180);
          else if (rotObj) rotation = [parseFloat(rotObj[1]), parseFloat(rotObj[2]), parseFloat(rotObj[3])].map(r => r * Math.PI / 180);

          // Parse color
          const colorMatch = props.match(/color\s*:\s*["']?#?([\w]+)["']?/);
          const color = colorMatch ? getColorValue(colorMatch[1]) : 0x4a9eff;

          // Parse geometry
          const geoMatch = props.match(/(?:geometry|model)\s*:\s*['"](\w+)['"]/);
          const typeMatch = props.match(/type\s*:\s*['"](\w+)['"]/);
          let geoType = geoMatch ? geoMatch[1].toLowerCase() : (typeMatch ? typeMatch[1].toLowerCase() : 'cube');

          console.log('  geometry:', geoType, 'position:', position, 'color:', color.toString(16));

          // Create geometry
          let geometry;
          switch (geoType) {
            case 'sphere': case 'orb': geometry = new THREE.SphereGeometry(0.5, 32, 32); break;
            case 'cylinder': geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 32); break;
            case 'cone': geometry = new THREE.ConeGeometry(0.5, 1, 32); break;
            case 'torus': case 'ring': geometry = new THREE.TorusGeometry(0.4, 0.15, 16, 48); break;
            case 'plane': geometry = new THREE.PlaneGeometry(1, 1); break;
            case 'torusknot': geometry = new THREE.TorusKnotGeometry(0.3, 0.1, 100, 16); break;
            case 'dodecahedron': geometry = new THREE.DodecahedronGeometry(0.5); break;
            case 'icosahedron': geometry = new THREE.IcosahedronGeometry(0.5); break;
            case 'octahedron': geometry = new THREE.OctahedronGeometry(0.5); break;
            case 'tetrahedron': geometry = new THREE.TetrahedronGeometry(0.5); break;
            case 'capsule': 
              geometry = new THREE.CapsuleGeometry ? new THREE.CapsuleGeometry(0.3, 0.6, 8, 16) : new THREE.SphereGeometry(0.5, 32, 32);
              break;
            case 'heart':
              const heartShape = new THREE.Shape();
              heartShape.moveTo(0, 0);
              heartShape.bezierCurveTo(0, -0.3, -0.5, -0.3, -0.5, 0);
              heartShape.bezierCurveTo(-0.5, 0.3, 0, 0.6, 0, 0.9);
              heartShape.bezierCurveTo(0, 0.6, 0.5, 0.3, 0.5, 0);
              heartShape.bezierCurveTo(0.5, -0.3, 0, -0.3, 0, 0);
              geometry = new THREE.ExtrudeGeometry(heartShape, { depth: 0.2, bevelEnabled: true, bevelThickness: 0.05 });
              geometry.center(); geometry.rotateX(Math.PI);
              break;
            case 'diamond': case 'crystal':
              geometry = new THREE.OctahedronGeometry(0.5);
              geometry.scale(1, 1.5, 1);
              break;
            case 'gear':
              geometry = new THREE.TorusGeometry(0.4, 0.08, 8, 24);
              break;
            case 'hexagon':
              geometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 6);
              break;
            case 'pyramid':
              geometry = new THREE.ConeGeometry(0.5, 1, 4);
              break;
            case 'star':
              geometry = new THREE.DodecahedronGeometry(0.4, 0);
              break;
            default:
              geometry = new THREE.BoxGeometry(1, 1, 1);
          }

          // Parse material type
          const matMatch = props.match(/material\s*:\s*['"](\w+)['"]/);
          const glowMatch = props.match(/glow\s*:\s*true/i);
          const matType = matMatch ? matMatch[1].toLowerCase() : 'standard';

          // Parse texture
          const textureMatch = props.match(/texture\s*:\s*["']([^"']+)["']/);
          const textureUrl = textureMatch ? textureMatch[1] : null;

          let material;
          switch (matType) {
            case 'glass':
              material = new THREE.MeshPhysicalMaterial({
                color, transparent: true, opacity: 0.3, roughness: 0,
                metalness: 0, transmission: 0.9, thickness: 0.5
              });
              break;
            case 'hologram':
              material = new THREE.MeshBasicMaterial({
                color, transparent: true, opacity: 0.6, wireframe: true
              });
              break;
            case 'neon':
              material = new THREE.MeshStandardMaterial({
                color, emissive: color, emissiveIntensity: 1.5
              });
              break;
            case 'chrome': case 'metal':
              material = new THREE.MeshStandardMaterial({
                color: 0xe0e0e0, metalness: 1, roughness: 0.1
              });
              break;
            case 'matte':
              material = new THREE.MeshLambertMaterial({ color });
              break;
            case 'wireframe':
              material = new THREE.MeshBasicMaterial({ color, wireframe: true });
              break;
            default:
              material = new THREE.MeshStandardMaterial({
                color, metalness: 0.3, roughness: 0.6,
                emissive: glowMatch ? color : 0x000000,
                emissiveIntensity: glowMatch ? 0.3 : 0
              });
          }

          // Load texture if specified
          if (textureUrl) {
            // Parse texture repeat and offset
            const repeatMatch = props.match(/textureRepeat\s*:\s*\[([^\]]+)\]/);
            const offsetMatch = props.match(/textureOffset\s*:\s*\[([^\]]+)\]/);
            const repeat = repeatMatch ? repeatMatch[1].split(',').map(n => parseFloat(n.trim()) || 1) : [1, 1];
            const offset = offsetMatch ? offsetMatch[1].split(',').map(n => parseFloat(n.trim()) || 0) : [0, 0];

            const textureLoader = new THREE.TextureLoader();
            textureLoader.crossOrigin = 'anonymous';
            textureLoader.load(textureUrl, (texture) => {
              texture.wrapS = THREE.RepeatWrapping;
              texture.wrapT = THREE.RepeatWrapping;
              texture.repeat.set(repeat[0], repeat[1]);
              texture.offset.set(offset[0], offset[1]);
              material.map = texture;
              material.needsUpdate = true;
              console.log('Loaded texture:', textureUrl, 'repeat:', repeat, 'offset:', offset);
            }, undefined, (err) => {
              console.warn('Failed to load texture:', textureUrl, err);
            });
          }

          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(position[0], position[1], position[2]);
          mesh.scale.set(scale[0], scale[1], scale[2]);
          mesh.rotation.set(rotation[0], rotation[1], rotation[2]);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          mesh.name = name;

          scene.add(mesh);
          objects.push(mesh);

          // Parse animation
          const animMatch = props.match(/animate\s*:\s*['"](\w+)['"]/);
          const animSpeedMatch = props.match(/animSpeed\s*:\s*([\d.]+)/);
          const animAmpMatch = props.match(/animAmplitude\s*:\s*([\d.]+)/);
          const animRadiusMatch = props.match(/animRadius\s*:\s*([\d.]+)/);

          if (animMatch) {
            animatedObjects.push({
              mesh,
              type: animMatch[1].toLowerCase(),
              speed: animSpeedMatch ? parseFloat(animSpeedMatch[1]) : 1,
              amplitude: animAmpMatch ? parseFloat(animAmpMatch[1]) : 0.3,
              radius: animRadiusMatch ? parseFloat(animRadiusMatch[1]) : 1,
              originalY: position[1],
              originalPos: { x: position[0], y: position[1], z: position[2] }
            });
          }

          count++;
        }

        document.getElementById('stat-objects').textContent = count;
        console.log('Total objects rendered:', count);

      } catch (error) {
        console.error('Parse error:', error);
      }
    }

    init();
  </script>
</body>
</html>
