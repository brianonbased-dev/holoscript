<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HoloScript VR Experience</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: #000;
        overflow: hidden;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        color: #fff;
      }
      #container {
        width: 100vw;
        height: 100vh;
      }

      #info {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px 20px;
        border-radius: 8px;
        font-size: 14px;
        max-width: 300px;
      }

      #info h3 {
        margin-bottom: 10px;
        color: #00ffff;
      }
      #info ul {
        margin-left: 20px;
      }
      #info li {
        margin: 5px 0;
      }

      .hidden {
        display: none !important;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>

    <div id="info">
      <h3>ðŸ¥½ VR Controls</h3>
      <ul>
        <li><strong>Trigger:</strong> Grab objects</li>
        <li><strong>Grip:</strong> Hold objects</li>
        <li><strong>Thumbstick:</strong> Move around</li>
        <li><strong>A/X:</strong> Teleport</li>
      </ul>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { VRButton } from 'three/addons/webxr/VRButton.js';
      import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

      // ===== HOLOSCRIPT CODE - REPLACE THIS =====
      const HOLOSCRIPT_CODE = `
      composition "VR Demo" {
        environment {
          skybox: "nebula"
          ambient_light: 0.3
        }
        
        object "GrabbableCube" @grabbable @physics {
          geometry: "cube"
          color: "#ff8800"
          position: [0.5, 1, -1]
          scale: [0.2, 0.2, 0.2]
        }
        
        object "GlowingSphere" @glowing @throwable {
          geometry: "sphere"
          color: "#00ffff"
          position: [-0.5, 1, -1]
          scale: [0.15, 0.15, 0.15]
        }
        
        object "TeleportPad" @pointable {
          geometry: "cylinder"
          color: "#00ff00"
          position: [0, 0.05, -3]
          scale: [0.5, 0.1, 0.5]
        }
      }
    `;
      // ==========================================

      let container, camera, scene, renderer;
      let controller1, controller2;
      let controllerGrip1, controllerGrip2;
      let raycaster;
      let grabbableObjects = [];
      let heldObject = null;

      init();
      animate();

      function init() {
        container = document.getElementById('container');

        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 3);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        container.appendChild(renderer.domElement);

        // VR Button
        document.body.appendChild(VRButton.createButton(renderer));

        // Controls for non-VR
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, -1);
        controls.update();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(10, 10);
        const floorMaterial = new THREE.MeshStandardMaterial({
          color: 0x333333,
          roughness: 0.8,
          metalness: 0.2,
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Create grabbable objects from HoloScript
        createGrabbableCube();
        createGlowingSphere();
        createTeleportPad();

        // Setup controllers
        setupControllers();

        // Raycaster for teleportation
        raycaster = new THREE.Raycaster();

        // Hide info panel in VR
        renderer.xr.addEventListener('sessionstart', () => {
          document.getElementById('info').classList.add('hidden');
        });
        renderer.xr.addEventListener('sessionend', () => {
          document.getElementById('info').classList.remove('hidden');
        });

        // Resize
        window.addEventListener('resize', onWindowResize);
      }

      function createGrabbableCube() {
        const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const material = new THREE.MeshStandardMaterial({
          color: 0xff8800,
          metalness: 0.5,
          roughness: 0.3,
        });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(0.5, 1, -1);
        cube.userData.grabbable = true;
        cube.userData.type = 'cube';
        scene.add(cube);
        grabbableObjects.push(cube);
      }

      function createGlowingSphere() {
        const geometry = new THREE.SphereGeometry(0.15, 32, 32);
        const material = new THREE.MeshStandardMaterial({
          color: 0x00ffff,
          emissive: 0x00ffff,
          emissiveIntensity: 0.5,
          metalness: 0.5,
          roughness: 0.2,
        });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.set(-0.5, 1, -1);
        sphere.userData.grabbable = true;
        sphere.userData.throwable = true;
        sphere.userData.type = 'sphere';
        scene.add(sphere);
        grabbableObjects.push(sphere);

        // Add point light
        const light = new THREE.PointLight(0x00ffff, 0.5, 2);
        sphere.add(light);
      }

      function createTeleportPad() {
        const geometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
        const material = new THREE.MeshStandardMaterial({
          color: 0x00ff00,
          emissive: 0x00ff00,
          emissiveIntensity: 0.3,
        });
        const pad = new THREE.Mesh(geometry, material);
        pad.position.set(0, 0.05, -3);
        pad.userData.teleportTarget = true;
        scene.add(pad);
      }

      function setupControllers() {
        const controllerModelFactory = new XRControllerModelFactory();

        // Controller 1 (Right hand)
        controller1 = renderer.xr.getController(0);
        controller1.addEventListener('selectstart', onSelectStart);
        controller1.addEventListener('selectend', onSelectEnd);
        controller1.addEventListener('squeezestart', onSqueezeStart);
        controller1.addEventListener('squeezeend', onSqueezeEnd);
        scene.add(controller1);

        controllerGrip1 = renderer.xr.getControllerGrip(0);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        scene.add(controllerGrip1);

        // Controller 2 (Left hand)
        controller2 = renderer.xr.getController(1);
        controller2.addEventListener('selectstart', onSelectStart);
        controller2.addEventListener('selectend', onSelectEnd);
        scene.add(controller2);

        controllerGrip2 = renderer.xr.getControllerGrip(1);
        controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
        scene.add(controllerGrip2);

        // Add ray for pointing
        const geometry = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0, 0, 0),
          new THREE.Vector3(0, 0, -5),
        ]);
        const material = new THREE.LineBasicMaterial({ color: 0x00ffff });
        const line = new THREE.Line(geometry, material);
        controller1.add(line.clone());
        controller2.add(line.clone());
      }

      function onSelectStart(event) {
        const controller = event.target;

        // Check for grabbable objects
        const intersections = getIntersections(controller);
        if (intersections.length > 0) {
          const intersection = intersections[0];
          const object = intersection.object;

          if (object.userData.grabbable) {
            // Grab the object
            controller.attach(object);
            controller.userData.selected = object;
            heldObject = object;

            // Haptic feedback
            const session = renderer.xr.getSession();
            if (session) {
              const source = event.target.gamepad;
              if (source && source.hapticActuators && source.hapticActuators.length > 0) {
                source.hapticActuators[0].pulse(0.5, 100);
              }
            }
          }
        }
      }

      function onSelectEnd(event) {
        const controller = event.target;

        if (controller.userData.selected) {
          const object = controller.userData.selected;

          // Release object back to scene
          scene.attach(object);

          // If throwable, add velocity
          if (object.userData.throwable) {
            // Simple throw - would need velocity tracking for real physics
            object.userData.velocity = new THREE.Vector3(0, 0.05, -0.1);
          }

          controller.userData.selected = undefined;
          heldObject = null;
        }
      }

      function onSqueezeStart(event) {
        // Alternative grip action
      }

      function onSqueezeEnd(event) {
        // Release grip
      }

      function getIntersections(controller) {
        const tempMatrix = new THREE.Matrix4();
        tempMatrix.identity().extractRotation(controller.matrixWorld);

        raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

        return raycaster.intersectObjects(grabbableObjects);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        renderer.setAnimationLoop(render);
      }

      function render() {
        // Update thrown objects
        grabbableObjects.forEach((obj) => {
          if (obj.userData.velocity) {
            obj.position.add(obj.userData.velocity);
            obj.userData.velocity.y -= 0.001; // Gravity

            // Floor collision
            if (obj.position.y < 0.1) {
              obj.position.y = 0.1;
              obj.userData.velocity = null;
            }
          }
        });

        // Pulse glowing objects
        const time = performance.now() * 0.001;
        grabbableObjects.forEach((obj) => {
          if (obj.userData.type === 'sphere' && obj.material.emissive) {
            obj.material.emissiveIntensity = 0.3 + Math.sin(time * 3) * 0.2;
          }
        });

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
