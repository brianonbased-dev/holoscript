{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "How do I import TypeScript modules in HoloScript?"}, {"role": "assistant", "content": "Here's how to use `@import` for TypeScript interop:\n\n```holoscript\n// Import from HoloScript packages\n@import { Vector3, Quaternion, Color } from \"@holoscript/math\"\n@import { PlayerController } from \"@holoscript/player\"\n@import { NetworkManager } from \"@holoscript/networking\"\n\n// Import from local TypeScript files\n@import { GameConfig } from \"./config.ts\"\n@import { calculateDamage, applyBuff } from \"./combat-utils.ts\"\n@import { ItemDatabase } from \"../data/items.ts\"\n\nscene GameScene {\n  state {\n    config: GameConfig.load()\n    player: null\n  }\n  \n  object Player {\n    position: Vector3.zero()\n    rotation: Quaternion.identity()\n    \n    @on_mount {\n      state.player = new PlayerController(self)\n      state.player.initialize(state.config.playerSettings)\n    }\n    \n    @on_collision(other) {\n      if (other.tag === 'enemy') {\n        let damage = calculateDamage(other.attack, self.defense)\n        self.takeDamage(damage)\n      }\n    }\n  }\n}\n```\n\n**Import syntax:**\n- Named: `@import { A, B } from \"module\"`\n- Default: `@import Default from \"module\"`\n- All: `@import * as Utils from \"module\"`"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Import custom game logic from TypeScript"}, {"role": "assistant", "content": "Here's importing custom game logic:\n\n```holoscript\n// Import game systems\n@import { CombatSystem } from \"./systems/combat.ts\"\n@import { InventoryManager } from \"./systems/inventory.ts\"\n@import { QuestTracker } from \"./systems/quests.ts\"\n@import { SaveManager } from \"./systems/save.ts\"\n\n// Import type definitions\n@import type { Item, Weapon, Armor } from \"./types/items.ts\"\n@import type { Quest, QuestObjective } from \"./types/quests.ts\"\n\n// Import constants and enums\n@import { DAMAGE_TYPES, RARITY_LEVELS } from \"./constants.ts\"\n\nscene RPGScene {\n  // Initialize systems from TypeScript\n  systems {\n    combat: CombatSystem.create()\n    inventory: InventoryManager.create(100)  // 100 slots\n    quests: QuestTracker.create()\n    save: SaveManager.create('rpg-save-v1')\n  }\n  \n  object Player {\n    @grabbable\n    \n    state {\n      health: 100\n      mana: 50\n      equippedWeapon: null as Weapon | null\n      equippedArmor: null as Armor | null\n    }\n    \n    @on_mount {\n      // Load saved game if exists\n      let savedData = systems.save.load()\n      if (savedData) {\n        state = { ...state, ...savedData.player }\n        systems.inventory.restore(savedData.inventory)\n        systems.quests.restore(savedData.quests)\n      }\n    }\n    \n    action attack(target) {\n      // Use TypeScript combat system\n      let damage = systems.combat.calculateDamage({\n        attacker: self,\n        defender: target,\n        weapon: state.equippedWeapon,\n        damageType: DAMAGE_TYPES.PHYSICAL\n      })\n      \n      target.takeDamage(damage)\n      \n      // Update quest progress\n      systems.quests.updateObjective('defeat_enemies', 1)\n    }\n    \n    action equipItem(item: Item) {\n      if (item.type === 'weapon') {\n        state.equippedWeapon = item as Weapon\n      } else if (item.type === 'armor') {\n        state.equippedArmor = item as Armor\n      }\n      systems.inventory.markEquipped(item.id)\n    }\n  }\n}\n```\n\nBenefits:\n- Type safety from TypeScript\n- Reuse existing game logic\n- Separation of concerns"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Using @import with math utilities"}, {"role": "assistant", "content": "Here's using math utilities with `@import`:\n\n```holoscript\n// Import math utilities\n@import { Vector3, Vector2, Quaternion } from \"@holoscript/math\"\n@import { lerp, clamp, smoothstep, remap } from \"@holoscript/math/utils\"\n@import { noise2D, noise3D, fbm } from \"@holoscript/math/noise\"\n@import { BezierCurve, CatmullRomSpline } from \"@holoscript/math/curves\"\n\nscene MathDemoScene {\n  // Spline path for enemy patrol\n  const patrolPath = new CatmullRomSpline([\n    Vector3.new(0, 0, 0),\n    Vector3.new(5, 0, 2),\n    Vector3.new(10, 0, 0),\n    Vector3.new(5, 0, -2),\n  ])\n  \n  object PatrolEnemy {\n    state {\n      t: 0           // Path progress 0-1\n      speed: 0.1\n    }\n    \n    @on_update(delta) {\n      // Move along spline\n      state.t = (state.t + state.speed * delta / 1000) % 1\n      \n      let pos = patrolPath.getPoint(state.t)\n      let tangent = patrolPath.getTangent(state.t)\n      \n      self.position = pos\n      self.rotation = Quaternion.lookRotation(tangent, Vector3.up())\n    }\n  }\n  \n  object NoiseGround {\n    geometry: 'plane'\n    size: [20, 20]\n    subdivisions: 50\n    \n    @on_mount {\n      self.generateTerrain()\n    }\n    \n    action generateTerrain() {\n      let vertices = self.mesh.vertices\n      \n      for (let i = 0; i < vertices.length; i++) {\n        let v = vertices[i]\n        // Use FBM noise for natural terrain\n        let height = fbm(v.x * 0.1, v.z * 0.1, {\n          octaves: 4,\n          persistence: 0.5,\n          lacunarity: 2.0\n        })\n        v.y = height * 3\n      }\n      \n      self.mesh.recalculateNormals()\n    }\n  }\n  \n  object SmoothDoor {\n    state {\n      isOpen: false\n      openProgress: 0\n    }\n    \n    @on_update(delta) {\n      // Smooth lerp for door animation\n      let target = state.isOpen ? 1 : 0\n      state.openProgress = lerp(\n        state.openProgress,\n        target,\n        1 - Math.pow(0.01, delta / 1000)\n      )\n      \n      // Apply with smoothstep for easing\n      let eased = smoothstep(0, 1, state.openProgress)\n      self.rotation.y = remap(eased, 0, 1, 0, 90)\n    }\n  }\n}\n```\n\nMath features:\n- Vector/Quaternion operations\n- Spline interpolation\n- Noise generation\n- Smooth value transitions"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Import and use external NPM packages"}, {"role": "assistant", "content": "Here's using external NPM packages:\n\n```holoscript\n// Import from NPM packages (must be in package.json)\n@import { format, formatDistance } from \"date-fns\"\n@import { v4 as uuid } from \"uuid\"\n@import lodash from \"lodash\"\n@import { z } from \"zod\"\n\n// Import from CDN (with type stub)\n@import confetti from \"https://cdn.skypack.dev/canvas-confetti\"\n\nscene NPMDemoScene {\n  state {\n    items: [],\n    lastSaved: null\n  }\n  \n  object ItemSpawner {\n    @pointable\n    \n    action spawnItem() {\n      // Use UUID from npm\n      let newItem = {\n        id: uuid(),\n        createdAt: new Date(),\n        data: {}\n      }\n      \n      state.items = [...state.items, newItem]\n    }\n  }\n  \n  ui TimeDisplay {\n    text LastSaved {\n      content: () => {\n        if (!state.lastSaved) return \"Never saved\"\n        // Use date-fns for formatting\n        return `Last saved: ${formatDistance(state.lastSaved, new Date(), { addSuffix: true })}`\n      }\n    }\n  }\n  \n  action saveGame() {\n    // Use lodash for deep clone\n    let saveData = lodash.cloneDeep({\n      items: state.items,\n      timestamp: format(new Date(), 'yyyy-MM-dd HH:mm:ss')\n    })\n    \n    // Validate with Zod\n    const SaveSchema = z.object({\n      items: z.array(z.object({\n        id: z.string().uuid(),\n        createdAt: z.date(),\n        data: z.record(z.any())\n      })),\n      timestamp: z.string()\n    })\n    \n    let validated = SaveSchema.parse(saveData)\n    storage.save('game', validated)\n    state.lastSaved = new Date()\n  }\n  \n  action celebrate() {\n    // Use canvas-confetti\n    confetti({\n      particleCount: 100,\n      spread: 70,\n      origin: { y: 0.6 }\n    })\n  }\n}\n```\n\n**NPM package requirements:**\n1. Add to `package.json` dependencies\n2. Run `npm install`\n3. Import with `@import`\n4. Types auto-resolved from `@types/*`"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Create shared TypeScript utilities for HoloScript"}, {"role": "assistant", "content": "Here's creating shared utilities:\n\n**utils/spatial.ts:**\n```typescript\nimport { Vector3 } from '@holoscript/math'\n\nexport function distance3D(a: Vector3, b: Vector3): number {\n  return Math.sqrt(\n    Math.pow(b.x - a.x, 2) +\n    Math.pow(b.y - a.y, 2) +\n    Math.pow(b.z - a.z, 2)\n  )\n}\n\nexport function randomPointInSphere(center: Vector3, radius: number): Vector3 {\n  const u = Math.random()\n  const v = Math.random()\n  const theta = u * 2 * Math.PI\n  const phi = Math.acos(2 * v - 1)\n  const r = radius * Math.cbrt(Math.random())\n  \n  return Vector3.new(\n    center.x + r * Math.sin(phi) * Math.cos(theta),\n    center.y + r * Math.sin(phi) * Math.sin(theta),\n    center.z + r * Math.cos(phi)\n  )\n}\n\nexport function lookAtRotation(from: Vector3, to: Vector3): { x: number, y: number, z: number } {\n  const dir = Vector3.subtract(to, from).normalize()\n  const yaw = Math.atan2(dir.x, dir.z) * (180 / Math.PI)\n  const pitch = Math.asin(-dir.y) * (180 / Math.PI)\n  return { x: pitch, y: yaw, z: 0 }\n}\n```\n\n**utils/audio.ts:**\n```typescript\nexport interface SoundOptions {\n  volume?: number\n  pitch?: number\n  loop?: boolean\n  spatial?: boolean\n  falloff?: number\n}\n\nexport function playSoundWithVariation(\n  soundId: string,\n  options: SoundOptions = {}\n): void {\n  const pitchVariation = 0.9 + Math.random() * 0.2  // 0.9 - 1.1\n  audio.play(soundId, {\n    ...options,\n    pitch: (options.pitch || 1) * pitchVariation\n  })\n}\n\nexport function createSoundPool(sounds: string[], maxConcurrent = 3) {\n  let activeCount = 0\n  \n  return {\n    play(options?: SoundOptions) {\n      if (activeCount >= maxConcurrent) return\n      \n      activeCount++\n      const sound = sounds[Math.floor(Math.random() * sounds.length)]\n      audio.play(sound, options).then(() => activeCount--)\n    }\n  }\n}\n```\n\n**HoloScript usage:**\n```holoscript\n@import { distance3D, randomPointInSphere, lookAtRotation } from \"./utils/spatial.ts\"\n@import { playSoundWithVariation, createSoundPool } from \"./utils/audio.ts\"\n\nscene UtilDemoScene {\n  // Create sound pool for footsteps\n  const footstepSounds = createSoundPool([\n    'footstep_1', 'footstep_2', 'footstep_3', 'footstep_4'\n  ], 2)\n  \n  object Enemy {\n    state {\n      target: null\n    }\n    \n    @on_update {\n      if (state.target) {\n        // Use utility functions\n        let dist = distance3D(self.position, state.target.position)\n        \n        if (dist < 20) {\n          // Look at player\n          self.rotation = lookAtRotation(self.position, state.target.position)\n          \n          // Move toward player\n          if (dist > 2) {\n            let dir = Vector3.subtract(state.target.position, self.position).normalize()\n            self.position = Vector3.add(self.position, Vector3.scale(dir, 0.1))\n            \n            // Play varied footstep\n            every(300) {\n              footstepSounds.play({ spatial: true, volume: 0.5 })\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  object Spawner {\n    @on_mount {\n      // Spawn enemies in random sphere\n      for (let i = 0; i < 5; i++) {\n        let pos = randomPointInSphere(self.position, 15)\n        spawn \"Enemy\" { position: pos }\n      }\n    }\n  }\n}\n```\n\nUtility patterns:\n- Pure functions for calculations\n- Factory functions for complex objects\n- Type exports for safety"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Import types for type-safe HoloScript"}, {"role": "assistant", "content": "Here's type-safe HoloScript with TypeScript types:\n\n**types/game.ts:**\n```typescript\nexport interface Player {\n  id: string\n  name: string\n  health: number\n  maxHealth: number\n  position: { x: number; y: number; z: number }\n  inventory: InventorySlot[]\n}\n\nexport interface InventorySlot {\n  item: Item | null\n  count: number\n}\n\nexport interface Item {\n  id: string\n  name: string\n  type: 'weapon' | 'armor' | 'consumable' | 'material'\n  rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary'\n  stats?: Record<string, number>\n}\n\nexport interface Enemy {\n  id: string\n  type: EnemyType\n  health: number\n  attack: number\n  defense: number\n}\n\nexport type EnemyType = 'goblin' | 'orc' | 'dragon' | 'skeleton'\n\nexport interface DamageEvent {\n  source: Player | Enemy\n  target: Player | Enemy\n  amount: number\n  type: 'physical' | 'magic' | 'true'\n  isCritical: boolean\n}\n\nexport interface GameState {\n  players: Map<string, Player>\n  enemies: Map<string, Enemy>\n  phase: 'lobby' | 'playing' | 'paused' | 'ended'\n  score: number\n}\n```\n\n**HoloScript with types:**\n```holoscript\n// Import types (type-only imports)\n@import type { Player, Enemy, DamageEvent, GameState } from \"./types/game.ts\"\n@import type { Item, InventorySlot, EnemyType } from \"./types/game.ts\"\n\n// Import runtime values\n@import { ENEMY_STATS, ITEM_DATABASE } from \"./data/constants.ts\"\n\nscene TypeSafeGame {\n  // Typed state\n  state: GameState = {\n    players: new Map(),\n    enemies: new Map(),\n    phase: 'lobby',\n    score: 0\n  }\n  \n  object PlayerEntity {\n    // State with explicit type\n    data: Player = {\n      id: uuid(),\n      name: 'Player',\n      health: 100,\n      maxHealth: 100,\n      position: { x: 0, y: 0, z: 0 },\n      inventory: Array(20).fill({ item: null, count: 0 })\n    }\n    \n    action takeDamage(event: DamageEvent) {\n      // TypeScript knows event.amount is number\n      let reducedDamage = event.type === 'true' \n        ? event.amount \n        : event.amount - self.getDefense()\n      \n      data.health = Math.max(0, data.health - reducedDamage)\n      \n      if (event.isCritical) {\n        ui.showFloatingText('CRITICAL!', self.position, { color: '#ff0000' })\n      }\n      \n      if (data.health <= 0) {\n        self.onDeath()\n      }\n    }\n    \n    action addItem(item: Item, count: number = 1): boolean {\n      // Find empty slot or stack\n      let slot = data.inventory.find(s => \n        s.item?.id === item.id || s.item === null\n      )\n      \n      if (!slot) return false  // Inventory full\n      \n      if (slot.item === null) {\n        slot.item = item\n        slot.count = count\n      } else {\n        slot.count += count\n      }\n      \n      return true\n    }\n  }\n  \n  // Typed function\n  function spawnEnemy(type: EnemyType, position: Vector3): Enemy {\n    let stats = ENEMY_STATS[type]\n    \n    let enemy: Enemy = {\n      id: uuid(),\n      type: type,\n      health: stats.health,\n      attack: stats.attack,\n      defense: stats.defense\n    }\n    \n    state.enemies.set(enemy.id, enemy)\n    \n    spawn \"EnemyEntity\" {\n      position: position\n      data: enemy\n    }\n    \n    return enemy\n  }\n  \n  // Type-safe event handler\n  action handleDamage(event: DamageEvent) {\n    // TypeScript provides autocomplete and type checking\n    if ('name' in event.target) {\n      // It's a Player\n      event.target.health -= event.amount\n    }\n  }\n}\n```\n\nType safety benefits:\n- Autocomplete in IDE\n- Compile-time error checking\n- Self-documenting code\n- Refactoring support"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Import and use animation easing functions"}, {"role": "assistant", "content": "Here's using animation easing utilities:\n\n```holoscript\n// Import easing functions\n@import { \n  easeInQuad, easeOutQuad, easeInOutQuad,\n  easeInCubic, easeOutCubic, easeInOutCubic,\n  easeInElastic, easeOutElastic, easeOutBounce,\n  easeInBack, easeOutBack,\n  spring, bezier\n} from \"@holoscript/easing\"\n\n// Import animation utilities\n@import { Tween, Timeline, stagger } from \"@holoscript/animation\"\n\nscene AnimationDemo {\n  object BouncingBall {\n    position: [0, 5, -3]\n    \n    state {\n      tween: null\n    }\n    \n    @on_mount {\n      // Create bounce animation with easing\n      state.tween = new Tween(self, {\n        y: { from: 5, to: 0 },\n        duration: 1000,\n        easing: easeOutBounce,\n        repeat: -1,  // Infinite\n        yoyo: true\n      })\n      \n      state.tween.start()\n    }\n  }\n  \n  object ElasticButton {\n    @hoverable\n    @pointable\n    \n    state {\n      baseScale: 1\n    }\n    \n    @on_hover_enter {\n      new Tween(self, {\n        scale: { to: 1.1 },\n        duration: 400,\n        easing: easeOutElastic\n      }).start()\n    }\n    \n    @on_hover_exit {\n      new Tween(self, {\n        scale: { to: state.baseScale },\n        duration: 300,\n        easing: easeOutCubic\n      }).start()\n    }\n    \n    @on_point {\n      // Quick squish effect\n      new Timeline()\n        .to(self, { scale: 0.9, duration: 50, easing: easeInQuad })\n        .to(self, { scale: 1.15, duration: 200, easing: easeOutBack })\n        .to(self, { scale: 1, duration: 150, easing: easeOutCubic })\n        .start()\n    }\n  }\n  \n  object[] MenuItems {\n    count: 5\n    \n    @on_mount {\n      // Staggered entrance animation\n      stagger(self.items, (item, index) => {\n        item.opacity = 0\n        item.position.x = -2\n        \n        new Tween(item, {\n          opacity: { to: 1 },\n          x: { to: 0 },\n          duration: 500,\n          delay: index * 100,\n          easing: easeOutCubic\n        }).start()\n      })\n    }\n  }\n  \n  object SpringyDoor {\n    @grabbable\n    \n    state {\n      isOpen: false\n      targetRotation: 0\n      velocity: 0\n    }\n    \n    @on_release {\n      state.isOpen = !state.isOpen\n      state.targetRotation = state.isOpen ? 90 : 0\n    }\n    \n    @on_update(delta) {\n      // Spring physics for door\n      let [newPos, newVel] = spring(\n        self.rotation.y,\n        state.targetRotation,\n        state.velocity,\n        {\n          stiffness: 200,\n          damping: 15,\n          mass: 1\n        }\n      )\n      \n      self.rotation.y = newPos\n      state.velocity = newVel\n    }\n  }\n  \n  // Custom bezier curve easing\n  object SwoopIn {\n    state {\n      customEase: bezier(0.68, -0.55, 0.265, 1.55)  // Back-and-forth\n    }\n    \n    action animateIn() {\n      new Tween(self, {\n        y: { from: -5, to: 0 },\n        duration: 800,\n        easing: state.customEase\n      }).start()\n    }\n  }\n}\n```\n\nEasing reference:\n- `easeIn*`: Slow start\n- `easeOut*`: Slow end\n- `easeInOut*`: Slow both ends\n- `elastic`: Springy overshoot\n- `bounce`: Ball bounce effect\n- `back`: Slight overshoot"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Import networking utilities for multiplayer"}, {"role": "assistant", "content": "Here's networking with TypeScript utilities:\n\n**network/sync.ts:**\n```typescript\nimport { NetworkManager } from '@holoscript/networking'\n\nexport interface SyncedState {\n  id: string\n  owner: string\n  data: Record<string, any>\n  version: number\n  lastUpdate: number\n}\n\nexport class StateSynchronizer {\n  private states: Map<string, SyncedState> = new Map()\n  private network: NetworkManager\n  \n  constructor(network: NetworkManager) {\n    this.network = network\n  }\n  \n  sync<T>(id: string, state: T): void {\n    const synced: SyncedState = {\n      id,\n      owner: this.network.localPlayerId,\n      data: state as Record<string, any>,\n      version: (this.states.get(id)?.version || 0) + 1,\n      lastUpdate: Date.now()\n    }\n    \n    this.states.set(id, synced)\n    this.network.broadcast('state_update', synced)\n  }\n  \n  get<T>(id: string): T | null {\n    return this.states.get(id)?.data as T || null\n  }\n}\n\nexport function createRPC<T extends Record<string, (...args: any[]) => any>>(\n  handlers: T\n) {\n  return {\n    call<K extends keyof T>(method: K, ...args: Parameters<T[K]>): ReturnType<T[K]> {\n      return network.rpc(method as string, args)\n    },\n    handle: handlers\n  }\n}\n```\n\n**HoloScript multiplayer scene:**\n```holoscript\n@import { NetworkManager, ReplicationMode } from \"@holoscript/networking\"\n@import { StateSynchronizer, createRPC } from \"./network/sync.ts\"\n@import type { SyncedState } from \"./network/sync.ts\"\n\nscene MultiplayerGame {\n  // Initialize networking\n  const network = NetworkManager.create({\n    serverUrl: 'wss://game-server.example.com',\n    roomId: 'game-room-1'\n  })\n  \n  const sync = new StateSynchronizer(network)\n  \n  // Type-safe RPC system\n  const gameRPC = createRPC({\n    dealDamage(targetId: string, amount: number) {\n      let target = scene.getObjectById(targetId)\n      if (target) target.takeDamage(amount)\n    },\n    \n    spawnItem(itemType: string, position: Vector3) {\n      spawn itemType { position: position }\n    },\n    \n    startRound(roundNumber: number) {\n      game.startRound(roundNumber)\n    }\n  })\n  \n  state {\n    players: new Map(),\n    localPlayer: null\n  }\n  \n  @on_mount {\n    // Connect and join room\n    await network.connect()\n    await network.joinRoom('main-lobby')\n    \n    // Listen for state updates\n    network.on('state_update', (syncedState: SyncedState) => {\n      sync.receive(syncedState)\n    })\n    \n    // Handle RPC calls\n    network.on('rpc', (method, args) => {\n      gameRPC.handle[method]?.(...args)\n    })\n  }\n  \n  object NetworkedPlayer {\n    replicate: true\n    replicationMode: ReplicationMode.Owner\n    \n    state {\n      playerId: network.localPlayerId\n      health: 100\n      score: 0\n    }\n    \n    @on_update {\n      if (self.isLocalPlayer) {\n        // Sync local state to other players\n        sync.sync(state.playerId, {\n          position: self.position,\n          rotation: self.rotation,\n          health: state.health,\n          score: state.score\n        })\n      } else {\n        // Apply remote state\n        let remoteState = sync.get(state.playerId)\n        if (remoteState) {\n          self.position = lerp(self.position, remoteState.position, 0.1)\n          self.rotation = slerp(self.rotation, remoteState.rotation, 0.1)\n        }\n      }\n    }\n    \n    action attack(target) {\n      // RPC to server/all clients\n      gameRPC.call('dealDamage', target.state.playerId, 25)\n    }\n  }\n}\n```\n\nNetworking features:\n- Type-safe RPC calls\n- State synchronization\n- Automatic interpolation\n- Owner-based replication"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "What are all the @import syntax options?"}, {"role": "assistant", "content": "Here's the complete `@import` syntax reference:\n\n```holoscript\n// ============================================\n// IMPORT SYNTAX OPTIONS\n// ============================================\n\n// --- Named imports ---\n@import { A, B, C } from \"module\"\n@import { Component as Comp } from \"module\"  // Alias\n\n// --- Default import ---\n@import DefaultExport from \"module\"\n\n// --- Namespace import ---\n@import * as Utils from \"module\"            // Access as Utils.function()\n\n// --- Combined imports ---\n@import Default, { Named1, Named2 } from \"module\"\n\n// --- Type-only imports (no runtime code) ---\n@import type { TypeA, TypeB } from \"module\"\n@import type * as Types from \"module\"\n\n// --- Side-effect import (runs module code) ---\n@import \"./polyfills.ts\"\n@import \"./global-styles.css\"\n\n// ============================================\n// SOURCE TYPES\n// ============================================\n\n// --- HoloScript built-in packages ---\n@import { Vector3 } from \"@holoscript/math\"\n@import { NetworkManager } from \"@holoscript/networking\"\n@import { AudioManager } from \"@holoscript/audio\"\n@import { UIBuilder } from \"@holoscript/ui\"\n@import { PhysicsWorld } from \"@holoscript/physics\"\n\n// --- Local TypeScript files ---\n@import { myFunction } from \"./utils.ts\"\n@import { Config } from \"../config.ts\"\n@import { helpers } from \"./lib/helpers.ts\"\n\n// --- Local JavaScript files ---\n@import { legacyCode } from \"./legacy.js\"\n\n// --- NPM packages (must be installed) ---\n@import lodash from \"lodash\"\n@import { format } from \"date-fns\"\n@import { z } from \"zod\"\n\n// --- CDN URLs (with optional type declaration) ---\n@import confetti from \"https://cdn.skypack.dev/canvas-confetti\"\n/// @ts-types=\"./types/confetti.d.ts\"\n\n// --- JSON data ---\n@import config from \"./config.json\" assert { type: \"json\" }\n@import items from \"./data/items.json\" assert { type: \"json\" }\n\n// --- Asset imports ---\n@import texture from \"./assets/texture.png\" assert { type: \"asset\" }\n@import model from \"./assets/model.glb\" assert { type: \"asset\" }\n\n// ============================================\n// DYNAMIC IMPORTS\n// ============================================\n\nscene DynamicImportDemo {\n  @on_mount {\n    // Dynamic import for code splitting\n    let HeavyModule = await import(\"./heavy-module.ts\")\n    HeavyModule.initialize()\n    \n    // Conditional import\n    if (platform.isQuest) {\n      let QuestUtils = await import(\"./platform/quest.ts\")\n      QuestUtils.setupTracking()\n    }\n  }\n}\n\n// ============================================\n// RE-EXPORTS\n// ============================================\n\n// In ./index.ts - barrel file\n@export { Component } from \"./Component.ts\"\n@export { default as Utils } from \"./utils.ts\"\n@export * from \"./types.ts\"\n@export * as Helpers from \"./helpers.ts\"\n\n// ============================================\n// IMPORT MAPS (in holoscript.config.json)\n// ============================================\n\n/*\n{\n  \"imports\": {\n    \"@/\": \"./src/\",\n    \"@utils/\": \"./src/utils/\",\n    \"@components/\": \"./src/components/\"\n  }\n}\n*/\n\n// Then use:\n@import { Player } from \"@components/Player.ts\"\n@import { formatTime } from \"@utils/time.ts\"\n```\n\n**Quick reference:**\n| Pattern | Use Case |\n|---------|----------|\n| `{ A }` | Named exports |\n| `Default` | Default export |\n| `* as X` | All as namespace |\n| `type { T }` | Types only |\n| `\"./file.ts\"` | Local file |\n| `\"package\"` | NPM package |\n| `\"https://...\"` | CDN URL |"}]}
