{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "How do I make an object rotatable in VR?"}, {"role": "assistant", "content": "Here's how to use `@rotatable` for VR object rotation:\n\n```holoscript\nobject RotatableCube {\n  geometry: 'box'\n  size: [0.3, 0.3, 0.3]\n  \n  @grabbable\n  @rotatable {\n    axis: 'all'              // all, x, y, z, xy, xz, yz\n    speed: 1.0               // Rotation speed multiplier\n    preserve_momentum: true  // Continue spinning after release\n    friction: 0.98           // Momentum decay (0-1)\n  }\n  \n  @on_rotate(delta) {\n    log(`Rotated by: ${delta.x}, ${delta.y}, ${delta.z}`)\n  }\n}\n```\n\n**Axis options:**\n- `all`: Free rotation in any direction\n- `x`, `y`, `z`: Single axis only\n- `xy`, `xz`, `yz`: Two-axis rotation\n\n**Common use cases:**\n- Examining 3D models: `axis: 'all'`\n- Dials/knobs: `axis: 'z'`\n- Turntables: `axis: 'y'`"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Create a dial or knob that can be rotated"}, {"role": "assistant", "content": "Here's a rotatable dial/knob:\n\n```holoscript\nprefab RotaryDial {\n  object dial {\n    mesh: 'assets/ui/dial_knob.glb'\n    \n    state {\n      value: 0           // 0-100\n      minAngle: -135\n      maxAngle: 135\n      snapToTicks: true\n      tickCount: 11      // 0-10 positions\n    }\n    \n    @grabbable {\n      preserve_position: true  // Only rotate, don't move\n    }\n    @rotatable {\n      axis: 'z'                // Only rotate around Z\n      min_angle: state.minAngle\n      max_angle: state.maxAngle\n      snap_angles: state.snapToTicks \n        ? Array.from({length: state.tickCount}, (_, i) => \n            state.minAngle + (i / (state.tickCount - 1)) * (state.maxAngle - state.minAngle)\n          )\n        : null\n      snap_threshold: 10       // Degrees to snap\n      haptic_on_snap: true\n    }\n    @hoverable {\n      glow: true\n      show_tooltip: () => `Value: ${state.value}`\n    }\n    \n    @on_rotate(delta) {\n      // Update value based on rotation\n      let normalized = (self.rotation.z - state.minAngle) / (state.maxAngle - state.minAngle)\n      state.value = Math.round(normalized * 100)\n      \n      // Emit change event\n      self.emit('valueChanged', state.value)\n    }\n    \n    @on_snap {\n      audio.play_spatial(\"click\", self.position)\n      haptic_pulse(0.3)\n    }\n  }\n}\n\n// Usage: Volume control\nobject VolumeKnob extends RotaryDial {\n  position: [0, 1.5, -1]\n  \n  @on_valueChanged(value) {\n    audio.setMasterVolume(value / 100)\n  }\n}\n```\n\nDial features:\n- Constrained rotation axis\n- Min/max angle limits\n- Snap to discrete values\n- Haptic feedback on snap"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Make a rotatable steering wheel for a driving game"}, {"role": "assistant", "content": "Here's a VR steering wheel:\n\n```holoscript\nprefab SteeringWheel {\n  object wheel {\n    mesh: 'assets/vehicles/steering_wheel.glb'\n    \n    state {\n      steerAngle: 0\n      maxRotation: 450  // Degrees lock-to-lock\n      returnSpeed: 5    // Auto-center speed\n      isGrabbed: false\n    }\n    \n    @grabbable {\n      two_handed: true\n      preserve_position: true\n      grab_points: [\n        { position: [-0.15, 0, 0], rotation: [0, 0, 90] },\n        { position: [0.15, 0, 0], rotation: [0, 0, -90] }\n      ]\n    }\n    @rotatable {\n      axis: 'z'\n      min_angle: -state.maxRotation / 2\n      max_angle: state.maxRotation / 2\n      two_handed_mode: 'steering'  // Natural steering motion\n      return_to_center: !state.isGrabbed\n      return_speed: state.returnSpeed\n      damping: 0.95\n    }\n    \n    @on_grab {\n      state.isGrabbed = true\n    }\n    \n    @on_release {\n      state.isGrabbed = false\n    }\n    \n    @on_rotate(delta) {\n      state.steerAngle = self.rotation.z\n      \n      // Normalize to -1 to 1 range for vehicle\n      let normalizedSteering = state.steerAngle / (state.maxRotation / 2)\n      vehicle.setSteering(normalizedSteering)\n    }\n    \n    // Resistance based on speed\n    @on_update {\n      let speedResistance = lerp(1, 3, vehicle.speed / vehicle.maxSpeed)\n      self.rotatable.damping = 0.9 + (speedResistance * 0.03)\n    }\n  }\n}\n\n// Complete driving setup\nscene DrivingGame {\n  object Vehicle {\n    object SteeringWheel extends SteeringWheel {\n      position: [0, 0.8, 0.3]  // Relative to driver seat\n    }\n    \n    // Gear shifter\n    object GearShifter {\n      @grabbable\n      @rotatable {\n        axis: 'x'\n        snap_angles: [-30, 0, 30, 60]  // R, N, D, L\n      }\n      \n      @on_snap {\n        let gears = ['R', 'N', 'D', 'L']\n        let gearIndex = self.getSnapIndex()\n        vehicle.setGear(gears[gearIndex])\n        audio.play(\"gear_click\")\n      }\n    }\n  }\n}\n```\n\nSteering features:\n- Two-handed natural grip\n- Auto-center when released\n- Speed-based resistance\n- Lock-to-lock rotation limits"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Create a rotatable puzzle lock with combination"}, {"role": "assistant", "content": "Here's a combination lock puzzle:\n\n```holoscript\nprefab CombinationLock {\n  object lock {\n    mesh: 'assets/puzzles/combo_lock.glb'\n    \n    state {\n      combination: [7, 2, 5]  // Secret code\n      currentDigits: [0, 0, 0]\n      selectedDial: 0\n      isUnlocked: false\n    }\n    \n    // Three rotating dials\n    object[] Dials {\n      count: 3\n      \n      distribution: {\n        pattern: 'line'\n        spacing: 0.05\n        axis: 'x'\n      }\n      \n      mesh: 'assets/puzzles/dial_ring.glb'\n      scale: 0.03\n      \n      @grabbable\n      @rotatable {\n        axis: 'z'\n        snap_angles: () => {\n          // 0-9 positions at 36° intervals\n          return Array.from({length: 10}, (_, i) => i * 36)\n        }\n        snap_threshold: 15\n        haptic_on_snap: true\n      }\n      @hoverable {\n        scale_effect: 1.05\n        glow: true\n      }\n      \n      @on_snap {\n        let dialIndex = self.index\n        let digitValue = Math.round(self.rotation.z / 36) % 10\n        \n        state.currentDigits[dialIndex] = digitValue\n        audio.play_spatial(\"dial_click\", self.position)\n        \n        // Check combination\n        self.parent.checkCombination()\n      }\n    }\n    \n    action checkCombination() {\n      let isCorrect = state.currentDigits.every(\n        (digit, i) => digit === state.combination[i]\n      )\n      \n      if (isCorrect && !state.isUnlocked) {\n        state.isUnlocked = true\n        self.unlock()\n      }\n    }\n    \n    action unlock() {\n      audio.play(\"lock_open\")\n      \n      // Open animation\n      animation OpenLock {\n        target: self.shackle\n        property: 'position.y'\n        to: 0.05\n        duration: 500\n        easing: 'ease-out'\n      }\n      \n      animation RotateShackle {\n        target: self.shackle\n        property: 'rotation.z'\n        to: 45\n        duration: 300\n        delay: 400\n      }\n      \n      self.emit('unlocked')\n    }\n    \n    action reset() {\n      state.currentDigits = [0, 0, 0]\n      state.isUnlocked = false\n      \n      self.Dials.forEach(dial => {\n        dial.rotation.z = 0\n      })\n    }\n  }\n}\n```\n\nPuzzle features:\n- Three independent rotating dials\n- 10 snap positions per dial\n- Combination checking\n- Unlock animation sequence"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "What are all the @rotatable options?"}, {"role": "assistant", "content": "Here's the complete `@rotatable` configuration reference:\n\n```holoscript\n@rotatable {\n  // === AXIS CONSTRAINTS ===\n  axis: 'all'               // all, x, y, z, xy, xz, yz\n  local_axis: true          // Use object's local axes\n  \n  // === ANGLE LIMITS ===\n  min_angle: -180           // Minimum rotation (degrees)\n  max_angle: 180            // Maximum rotation (degrees)\n  unlimited: false          // No angle limits (overrides min/max)\n  \n  // === SNAP BEHAVIOR ===\n  snap_angles: [0, 45, 90, 135, 180, 225, 270, 315]  // Snap points\n  snap_threshold: 10        // Degrees to trigger snap\n  snap_duration: 0.1        // Animation time for snap\n  snap_easing: 'ease-out'   // Snap animation curve\n  haptic_on_snap: true      // Vibrate on snap\n  \n  // === SPEED & SENSITIVITY ===\n  speed: 1.0                // Rotation speed multiplier\n  sensitivity: 1.0          // Input sensitivity\n  invert: false             // Invert rotation direction\n  \n  // === MOMENTUM & PHYSICS ===\n  preserve_momentum: true   // Continue spinning after release\n  friction: 0.98            // Momentum decay per frame (0-1)\n  max_velocity: 720         // Max degrees per second\n  damping: 0.95             // Resistance to rotation\n  \n  // === AUTO-RETURN ===\n  return_to_center: false   // Auto-return when released\n  return_speed: 5           // Return animation speed\n  rest_angle: 0             // Target angle for return\n  \n  // === TWO-HANDED ===\n  two_handed: true          // Enable two-handed rotation\n  two_handed_mode: 'twist'  // twist, steering, free\n  two_handed_scale: 1.0     // Sensitivity for two-handed\n  \n  // === AUDIO ===\n  rotate_sound: 'rotate_loop'     // Sound while rotating\n  snap_sound: 'click'             // Sound on snap\n  limit_sound: 'thud'             // Sound at angle limits\n  \n  // === VISUAL FEEDBACK ===\n  show_axis: false          // Show rotation axis indicator\n  show_limits: false        // Show min/max angle indicators\n  highlight_snap_points: true // Glow at snap positions\n}\n\n// === LIFECYCLE EVENTS ===\n@on_rotate(delta) {\n  // delta: { x, y, z } in degrees\n  // Called every frame while rotating\n}\n\n@on_rotate_start {\n  // Called when rotation begins\n}\n\n@on_rotate_end {\n  // Called when rotation stops\n}\n\n@on_snap {\n  // Called when snapping to a position\n}\n\n@on_limit_reached(axis, limit) {\n  // Called when hitting min/max angle\n  // axis: 'x', 'y', or 'z'\n  // limit: 'min' or 'max'\n}\n```\n\n**Common presets:**\n```holoscript\n// Dial/knob\n@rotatable {\n  axis: 'z'\n  min_angle: -135\n  max_angle: 135\n  snap_angles: [-135, -90, -45, 0, 45, 90, 135]\n}\n\n// Steering wheel\n@rotatable {\n  axis: 'z'\n  min_angle: -450\n  max_angle: 450\n  return_to_center: true\n  two_handed: true\n}\n\n// Free inspection\n@rotatable {\n  axis: 'all'\n  preserve_momentum: true\n  friction: 0.97\n}\n\n// Turntable\n@rotatable {\n  axis: 'y'\n  unlimited: true\n  preserve_momentum: true\n}\n```"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Create a rotatable safe dial"}, {"role": "assistant", "content": "Here's a classic safe dial:\n\n```holoscript\nprefab SafeDial {\n  object safe {\n    mesh: 'assets/props/safe_body.glb'\n    \n    state {\n      combination: [32, 16, 48]  // Right-Left-Right\n      attempts: []\n      currentDirection: 'right'\n      isUnlocked: false\n      tolerance: 2  // Degrees of error allowed\n    }\n    \n    object dial {\n      mesh: 'assets/props/safe_dial.glb'\n      position: [0, 0, 0.15]\n      \n      @grabbable\n      @rotatable {\n        axis: 'z'\n        unlimited: true\n        preserve_momentum: false  // Precise control needed\n        damping: 0.99\n        sensitivity: 0.5  // Slower for precision\n      }\n      @hoverable {\n        glow: true\n        show_tooltip: () => `${self.getCurrentNumber()}`\n      }\n      \n      // Number markers (0-99)\n      object[] Numbers {\n        count: 100\n        \n        distribution: {\n          pattern: 'radial'\n          radius: 0.06\n          startAngle: 0\n        }\n        \n        text: (i) => i.toString()\n        fontSize: 8\n        color: '#cccccc'\n      }\n      \n      // Indicator mark at top\n      object Indicator {\n        geometry: 'triangle'\n        position: [0, 0.08, 0.01]\n        scale: [0.01, 0.015, 0.001]\n        color: '#ff0000'\n      }\n      \n      action getCurrentNumber() {\n        // Convert rotation to 0-99\n        let angle = ((self.rotation.z % 360) + 360) % 360\n        return Math.round(angle / 3.6) % 100\n      }\n      \n      @on_rotate(delta) {\n        // Determine direction\n        let direction = delta.z > 0 ? 'right' : 'left'\n        \n        // Detect direction change (new attempt)\n        if (direction !== state.currentDirection) {\n          let currentNum = self.getCurrentNumber()\n          state.attempts.push({\n            number: currentNum,\n            direction: state.currentDirection\n          })\n          state.currentDirection = direction\n          \n          self.parent.checkCombination()\n        }\n        \n        // Tick sound every number\n        let newNum = self.getCurrentNumber()\n        if (self.lastNumber !== newNum) {\n          audio.play_spatial(\"dial_tick\", self.position, { volume: 0.3 })\n          self.lastNumber = newNum\n        }\n      }\n    }\n    \n    action checkCombination() {\n      let combo = state.combination\n      let attempts = state.attempts\n      \n      // Need exactly 3 attempts in R-L-R pattern\n      if (attempts.length < 3) return\n      \n      // Check last 3 attempts\n      let last3 = attempts.slice(-3)\n      \n      let isCorrect = (\n        last3[0].direction === 'right' &&\n        Math.abs(last3[0].number - combo[0]) <= state.tolerance &&\n        last3[1].direction === 'left' &&\n        Math.abs(last3[1].number - combo[1]) <= state.tolerance &&\n        last3[2].direction === 'right' &&\n        Math.abs(last3[2].number - combo[2]) <= state.tolerance\n      )\n      \n      if (isCorrect) {\n        self.unlock()\n      }\n    }\n    \n    action unlock() {\n      state.isUnlocked = true\n      audio.play(\"safe_unlock\")\n      \n      // Heavy door swing open\n      animation OpenDoor {\n        target: self.door\n        property: 'rotation.y'\n        to: -120\n        duration: 2000\n        easing: 'ease-in-out'\n      }\n      \n      self.emit('opened')\n    }\n    \n    action reset() {\n      state.attempts = []\n      state.isUnlocked = false\n      self.dial.rotation.z = 0\n    }\n  }\n}\n```\n\nSafe dial features:\n- Classic right-left-right combination\n- 100-number dial\n- Tolerance for real-world feel\n- Direction change detection\n- Satisfying tick sounds"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Make a 3D model viewer with rotate controls"}, {"role": "assistant", "content": "Here's a 3D model viewer:\n\n```holoscript\nscene ModelViewer {\n  state {\n    currentModel: 'assets/models/helmet.glb'\n    autoRotate: true\n    autoRotateSpeed: 10  // degrees per second\n  }\n  \n  // Turntable base\n  object Turntable {\n    position: [0, 0, -2]\n    \n    @rotatable {\n      axis: 'y'\n      unlimited: true\n      preserve_momentum: true\n      friction: 0.99\n    }\n    \n    @on_grab {\n      state.autoRotate = false\n    }\n    \n    @on_update(delta) {\n      if (state.autoRotate) {\n        self.rotation.y += state.autoRotateSpeed * delta / 1000\n      }\n    }\n    \n    // Model display\n    object ModelDisplay {\n      mesh: () => state.currentModel\n      position: [0, 0.5, 0]\n      \n      @grabbable\n      @rotatable {\n        axis: 'all'\n        preserve_momentum: true\n        friction: 0.97\n        show_axis: true\n      }\n      @scalable {\n        min_scale: 0.5\n        max_scale: 3.0\n        uniform: true\n      }\n      @hoverable {\n        glow: true\n        glow_color: '#4488ff'\n      }\n      \n      // Reset button\n      @on_double_tap {\n        self.resetTransform()\n      }\n      \n      action resetTransform() {\n        animation ResetRotation {\n          property: 'rotation'\n          to: [0, 0, 0]\n          duration: 500\n          easing: 'ease-out'\n        }\n        \n        animation ResetScale {\n          property: 'scale'\n          to: 1\n          duration: 500\n          easing: 'ease-out'\n        }\n      }\n    }\n  }\n  \n  // Control panel\n  ui ControlPanel {\n    position: [0.8, 1.2, -1.5]\n    \n    children {\n      panel Background {\n        color: 'rgba(30, 30, 40, 0.9)'\n        padding: 20\n        borderRadius: 10\n        \n        children {\n          text Title {\n            content: \"Model Viewer\"\n            fontSize: 24\n            color: '#ffffff'\n          }\n          \n          // Auto-rotate toggle\n          toggle AutoRotateToggle {\n            position: [0, 40, 0]\n            label: \"Auto Rotate\"\n            value: () => state.autoRotate\n            onChange: (val) => state.autoRotate = val\n          }\n          \n          // Rotation speed slider\n          slider SpeedSlider {\n            position: [0, 80, 0]\n            label: \"Speed\"\n            min: 1\n            max: 45\n            value: () => state.autoRotateSpeed\n            onChange: (val) => state.autoRotateSpeed = val\n          }\n          \n          // Reset button\n          button ResetBtn {\n            position: [0, 130, 0]\n            label: \"Reset View\"\n            onClick: () => {\n              scene.Turntable.ModelDisplay.resetTransform()\n              scene.Turntable.rotation.y = 0\n            }\n          }\n          \n          // Model selector\n          dropdown ModelSelect {\n            position: [0, 180, 0]\n            label: \"Model\"\n            options: [\n              { label: \"Helmet\", value: \"assets/models/helmet.glb\" },\n              { label: \"Sword\", value: \"assets/models/sword.glb\" },\n              { label: \"Shield\", value: \"assets/models/shield.glb\" },\n              { label: \"Potion\", value: \"assets/models/potion.glb\" }\n            ]\n            value: () => state.currentModel\n            onChange: (val) => state.currentModel = val\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nViewer features:\n- Turntable with auto-rotate\n- Free-rotation on model\n- Pinch-to-scale\n- Double-tap reset\n- Control panel UI"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Create a rotatable valve wheel"}, {"role": "assistant", "content": "Here's a mechanical valve wheel:\n\n```holoscript\nprefab ValveWheel {\n  object valve {\n    mesh: 'assets/industrial/valve_wheel.glb'\n    \n    state {\n      openPercent: 0        // 0 = closed, 100 = open\n      turnsToOpen: 5        // Full turns to fully open\n      totalRotation: 0      // Track total rotation\n      isJammed: false\n      resistance: 0.3       // Base resistance\n    }\n    \n    @grabbable {\n      two_handed: true\n      grab_anywhere: true\n    }\n    @rotatable {\n      axis: 'z'\n      unlimited: true\n      damping: () => state.isJammed ? 0.99 : 0.9\n      two_handed_mode: 'steering'\n      min_velocity: 5        // Minimum to overcome resistance\n    }\n    @hoverable {\n      show_tooltip: () => `${state.openPercent.toFixed(0)}% open`\n    }\n    \n    // Rust/age effect on resistance\n    trait Aged {\n      rustLevel: 0.5  // 0 = new, 1 = rusted shut\n    }\n    \n    @on_rotate(delta) {\n      // Apply resistance\n      let effectiveDelta = delta.z * (1 - state.resistance - self.rustLevel * 0.4)\n      \n      // Accumulate rotation\n      state.totalRotation += effectiveDelta\n      \n      // Calculate open percentage\n      let maxRotation = state.turnsToOpen * 360\n      state.openPercent = clamp(\n        (state.totalRotation / maxRotation) * 100,\n        0,\n        100\n      )\n      \n      // Valve sound effects\n      if (Math.abs(effectiveDelta) > 1) {\n        audio.play_spatial(\"metal_creak\", self.position, {\n          volume: 0.2 + self.rustLevel * 0.3,\n          pitch: 0.8 + Math.random() * 0.4\n        })\n      }\n      \n      // Emit value change\n      self.emit('valueChanged', state.openPercent)\n    }\n    \n    @on_rotate_start {\n      // Random chance of being stuck\n      if (self.rustLevel > 0.7 && Math.random() < 0.3) {\n        state.isJammed = true\n        audio.play(\"metal_stuck\")\n        ui.showHint(\"The valve is stuck! Try harder.\")\n      }\n    }\n    \n    @on_rotate_end {\n      state.isJammed = false\n    }\n    \n    // Connect to pipe system\n    action connectToPipe(pipe) {\n      self.on('valueChanged', (percent) => {\n        pipe.setFlowRate(percent / 100)\n      })\n    }\n  }\n}\n\n// Usage in a puzzle\nscene WaterPuzzle {\n  object MainValve extends ValveWheel {\n    position: [0, 1.5, -2]\n    rustLevel: 0.3\n    \n    @on_mount {\n      self.connectToPipe(pipes.main)\n    }\n  }\n  \n  // Pipe that responds to valve\n  object WaterPipe {\n    state {\n      flowRate: 0\n    }\n    \n    action setFlowRate(rate) {\n      state.flowRate = rate\n      \n      // Visual water flow\n      self.waterParticles.emissionRate = rate * 100\n      \n      // Sound based on flow\n      audio.setVolume('water_flow', rate)\n      audio.setPitch('water_flow', 0.8 + rate * 0.4)\n      \n      // Check puzzle completion\n      if (rate >= 0.95) {\n        puzzle.complete('water_valve')\n      }\n    }\n  }\n}\n```\n\nValve features:\n- Multi-turn rotation\n- Rust/resistance simulation\n- Two-handed operation\n- Connected to pipe system\n- Sound design for realism"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Rotatable turret for a defense game"}, {"role": "assistant", "content": "Here's a rotatable defense turret:\n\n```holoscript\nprefab DefenseTurret {\n  object turret {\n    mesh: 'assets/weapons/turret_base.glb'\n    \n    state {\n      yaw: 0              // Horizontal rotation\n      pitch: 0            // Vertical rotation\n      minPitch: -10       // Can't aim too low\n      maxPitch: 60        // Can't aim straight up\n      rotationSpeed: 90   // Degrees per second\n      isManual: false     // Manual vs auto-aim\n      target: null\n    }\n    \n    // Rotating base (yaw)\n    object Base {\n      @rotatable {\n        axis: 'y'\n        unlimited: true\n        speed: state.rotationSpeed\n        preserve_momentum: false\n      }\n      \n      // Gun mount (pitch)\n      object GunMount {\n        position: [0, 0.3, 0]\n        \n        @rotatable {\n          axis: 'x'\n          min_angle: state.minPitch\n          max_angle: state.maxPitch\n        }\n        \n        // The gun barrel\n        object Barrel {\n          mesh: 'assets/weapons/turret_barrel.glb'\n          \n          object MuzzlePoint {\n            position: [0, 0, 1.5]\n            // Fire point\n          }\n        }\n      }\n    }\n    \n    // Manual control handles\n    object[] Handles {\n      count: 2\n      position: [[−0.4, 0.8, 0], [0.4, 0.8, 0]]\n      \n      @grabbable\n      @hoverable {\n        glow: true\n      }\n      \n      @on_grab {\n        state.isManual = true\n      }\n      \n      @on_release {\n        state.isManual = false\n      }\n      \n      @on_update {\n        if (self.isGrabbed) {\n          // Map hand position to turret rotation\n          let handDelta = self.getHandDelta()\n          \n          // Horizontal aiming\n          self.parent.Base.rotation.y += handDelta.x * state.rotationSpeed * delta\n          \n          // Vertical aiming\n          let newPitch = self.parent.Base.GunMount.rotation.x - handDelta.y * state.rotationSpeed * delta\n          self.parent.Base.GunMount.rotation.x = clamp(newPitch, state.minPitch, state.maxPitch)\n        }\n      }\n    }\n    \n    // Trigger button\n    object TriggerButton {\n      position: [0.4, 0.85, 0.1]\n      \n      @pointable\n      \n      @on_point {\n        self.parent.fire()\n      }\n    }\n    \n    // Auto-aim logic\n    @on_update(delta) {\n      if (!state.isManual && state.target) {\n        self.aimAtTarget(state.target, delta)\n      }\n    }\n    \n    action aimAtTarget(target, delta) {\n      let direction = Vector3.subtract(target.position, self.Base.GunMount.Barrel.MuzzlePoint.worldPosition)\n      \n      // Calculate yaw\n      let targetYaw = Math.atan2(direction.x, direction.z) * (180 / Math.PI)\n      let yawDiff = angleDifference(self.Base.rotation.y, targetYaw)\n      self.Base.rotation.y += clamp(yawDiff, -state.rotationSpeed * delta, state.rotationSpeed * delta)\n      \n      // Calculate pitch\n      let horizontalDist = Math.sqrt(direction.x ** 2 + direction.z ** 2)\n      let targetPitch = Math.atan2(direction.y, horizontalDist) * (180 / Math.PI)\n      let pitchDiff = targetPitch - self.Base.GunMount.rotation.x\n      self.Base.GunMount.rotation.x += clamp(pitchDiff, -state.rotationSpeed * delta, state.rotationSpeed * delta)\n    }\n    \n    action fire() {\n      let muzzle = self.Base.GunMount.Barrel.MuzzlePoint\n      \n      spawn \"Projectile\" {\n        position: muzzle.worldPosition\n        direction: muzzle.forward\n        speed: 50\n      }\n      \n      // Effects\n      audio.play_spatial(\"turret_fire\", muzzle.worldPosition)\n      spawn \"MuzzleFlash\" { position: muzzle.worldPosition }\n      haptic_pulse(0.5)\n      \n      // Recoil\n      animation Recoil {\n        target: self.Base.GunMount.Barrel\n        property: 'position.z'\n        keyframes: [0, -0.1, 0]\n        duration: 100\n      }\n    }\n  }\n}\n```\n\nTurret features:\n- Dual-axis rotation (yaw + pitch)\n- Manual handle controls\n- Auto-aim at target\n- Pitch angle limits\n- Firing with recoil"}]}
