{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "How do I use @snappable for grid-based building?"}, {"role": "assistant", "content": "Here's grid-based building with `@snappable`:\n\n```holoscript\nscene GridBuilding {\n  // Grid floor with snap points\n  object BuildGrid {\n    size: [20, 20]\n    \n    @snappable {\n      type: 'grid'\n      grid_size: [1, 1, 1]     // 1 meter grid\n      show_grid: true           // Visual grid lines\n      grid_color: '#4488ff40'\n    }\n  }\n  \n  prefab BuildingBlock {\n    object block {\n      geometry: 'box'\n      size: [1, 1, 1]\n      \n      @grabbable\n      @snappable {\n        snap_to: ['grid', 'block_face']  // Snap to grid and other blocks\n        snap_distance: 0.3        // Range to trigger snap\n        snap_rotation: true       // Also snap rotation\n        snap_angles: [0, 90, 180, 270]  // 90Â° increments\n        preview: true             // Show ghost at snap position\n        preview_color: '#44ff4480'\n      }\n      @hoverable {\n        glow: true\n      }\n      \n      @on_snap(snapInfo) {\n        audio.play_spatial(\"block_place\", self.position)\n        haptic_pulse(0.3)\n        \n        // Register block in building system\n        building.addBlock(self, snapInfo.gridPosition)\n      }\n      \n      @on_unsnap {\n        building.removeBlock(self)\n      }\n    }\n  }\n}\n```\n\n**Snap types:**\n- `grid`: Snap to regular grid positions\n- `point`: Snap to defined points\n- `surface`: Snap to surfaces\n- `edge`: Snap to edges\n- `vertex`: Snap to corners"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Create snap-together furniture"}, {"role": "assistant", "content": "Here's modular furniture with snap points:\n\n```holoscript\n// Furniture socket system\ntrait FurnitureSocket {\n  @snappable {\n    snap_group: 'furniture'\n    bidirectional: true\n  }\n}\n\nprefab TableTop {\n  object tabletop {\n    mesh: 'assets/furniture/table_top.glb'\n    \n    @grabbable\n    \n    use FurnitureSocket\n    \n    // Define where legs can attach\n    snap_points: [\n      { position: [-0.4, 0, -0.3], group: 'table_leg', rotation: [0, 0, 0] },\n      { position: [0.4, 0, -0.3], group: 'table_leg', rotation: [0, 0, 0] },\n      { position: [-0.4, 0, 0.3], group: 'table_leg', rotation: [0, 0, 0] },\n      { position: [0.4, 0, 0.3], group: 'table_leg', rotation: [0, 0, 0] }\n    ]\n    \n    @snappable {\n      snap_points: self.snap_points\n      snap_distance: 0.15\n      snap_duration: 0.2\n      easing: 'ease-out'\n      magnetic: true\n      magnetic_range: 0.3\n    }\n    \n    @on_snap(info) {\n      audio.play(\"wood_connect\")\n      \n      // Track attached legs\n      if (info.other.type === 'table_leg') {\n        self.attachedLegs.push(info.other)\n        \n        if (self.attachedLegs.length === 4) {\n          self.becomeStable()\n        }\n      }\n    }\n  }\n}\n\nprefab TableLeg {\n  object leg {\n    mesh: 'assets/furniture/table_leg.glb'\n    \n    @grabbable\n    \n    snap_points: [\n      { position: [0, 0.4, 0], group: 'table_leg', type: 'male' }  // Top connects to table\n    ]\n    \n    @snappable {\n      snap_points: self.snap_points\n      snap_to: ['table_leg']  // Only snap to table_leg sockets\n      snap_distance: 0.15\n      snap_rotation: true\n    }\n  }\n}\n\nprefab ShelfUnit {\n  object shelf {\n    mesh: 'assets/furniture/shelf.glb'\n    \n    @grabbable\n    \n    // Shelves can stack\n    snap_points: [\n      { position: [0, 0.4, 0], group: 'shelf_stack', type: 'female' },  // Top\n      { position: [0, -0.4, 0], group: 'shelf_stack', type: 'male' }     // Bottom\n    ]\n    \n    @snappable {\n      snap_points: self.snap_points\n      snap_to: ['shelf_stack']\n      snap_distance: 0.2\n      vertical_only: true  // Only stack vertically\n      max_stack: 5\n    }\n    \n    @on_snap(info) {\n      if (info.type === 'stacked') {\n        // Check stability\n        if (self.getStackHeight() > 4) {\n          ui.showWarning(\"Shelf stack is unstable!\")\n        }\n      }\n    }\n  }\n}\n```\n\nFurniture snap features:\n- Bidirectional connection\n- Magnetic attraction\n- Stack height limits\n- Stability tracking"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Wall mounting system with snap points"}, {"role": "assistant", "content": "Here's a wall mounting snap system:\n\n```holoscript\n// Wall with mounting points\nobject Wall {\n  geometry: 'plane'\n  size: [4, 3]\n  rotation: [0, 0, 0]\n  \n  trait Material {\n    preset: 'drywall'\n  }\n  \n  // Generate grid of mounting points\n  @snappable {\n    type: 'grid'\n    grid_size: [0.3, 0.3]     // 30cm spacing\n    offset: [0.15, 0.15]       // Offset from edge\n    snap_group: 'wall_mount'\n    show_points_on_hover: true\n    point_visual: 'nail_hole'\n  }\n}\n\nprefab WallFrame {\n  object frame {\n    mesh: 'assets/decor/picture_frame.glb'\n    \n    @grabbable\n    @snappable {\n      snap_to: ['wall_mount']\n      snap_distance: 0.2\n      \n      // Frame needs 2 mount points\n      require_points: 2\n      point_spacing: 0.4  // Distance between hooks\n      \n      // Only snap when parallel to wall\n      angle_tolerance: 15\n      \n      // Offset from wall\n      snap_offset: [0, 0, 0.02]\n    }\n    @hoverable {\n      glow: true\n    }\n    \n    // Hanging hooks on back\n    object[] Hooks {\n      count: 2\n      position: [[-0.2, 0.15, -0.02], [0.2, 0.15, -0.02]]\n      snap_group: 'frame_hook'\n    }\n    \n    @on_snap(info) {\n      audio.play(\"frame_hang\")\n      \n      // Slight settle animation\n      animation Settle {\n        property: 'rotation.z'\n        keyframes: [2, -1, 0.5, 0]\n        duration: 500\n      }\n    }\n  }\n}\n\nprefab WallShelf {\n  object shelf {\n    mesh: 'assets/furniture/wall_shelf.glb'\n    \n    @grabbable\n    @snappable {\n      snap_to: ['wall_mount']\n      snap_distance: 0.25\n      \n      // Bracket positions\n      mount_points: [\n        { position: [-0.3, 0, 0], required: true },\n        { position: [0.3, 0, 0], required: true }\n      ]\n      \n      // Must be level\n      level_required: true\n      level_tolerance: 5  // degrees\n      \n      snap_offset: [0, 0, 0.1]  // Stand off from wall\n    }\n    \n    @on_snap(info) {\n      // Shelf is now load-bearing\n      self.physics = 'static'\n      self.collider = 'box'\n      \n      // Enable placing items on shelf\n      self.enableSurface()\n      \n      audio.play(\"shelf_mount\")\n    }\n  }\n}\n\nprefab WallClock {\n  object clock {\n    mesh: 'assets/decor/wall_clock.glb'\n    \n    @grabbable\n    @snappable {\n      snap_to: ['wall_mount']\n      snap_distance: 0.2\n      \n      // Single center mount\n      center_mount: true\n      \n      snap_offset: [0, 0, 0.03]\n    }\n    \n    @on_snap {\n      // Start clock ticking\n      self.startTicking()\n    }\n    \n    @on_unsnap {\n      self.stopTicking()\n    }\n  }\n}\n```\n\nWall mounting features:\n- Grid-based mount points\n- Multi-point mounting\n- Level requirements\n- Visual mount indicators\n- Proper wall offset"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "What are all the @snappable options?"}, {"role": "assistant", "content": "Here's the complete `@snappable` configuration reference:\n\n```holoscript\n@snappable {\n  // === SNAP TARGETS ===\n  snap_to: ['grid', 'points', 'surface']  // What to snap to\n  snap_group: 'my_group'                   // Group name for filtering\n  exclude_groups: ['forbidden']            // Groups to ignore\n  \n  // === SNAP POINTS ===\n  snap_points: [\n    {\n      position: [0, 0, 0],    // Local position\n      rotation: [0, 0, 0],    // Local rotation\n      group: 'socket_a',      // Point group name\n      type: 'male',           // male, female, universal\n      label: 'Top Mount'      // Display label\n    }\n  ]\n  \n  // === DISTANCE & SENSITIVITY ===\n  snap_distance: 0.2          // Range to trigger snap (meters)\n  magnetic: true               // Attract when close\n  magnetic_range: 0.5          // Magnetic attraction range\n  magnetic_strength: 0.5       // Attraction force (0-1)\n  \n  // === ROTATION ===\n  snap_rotation: true          // Also snap rotation\n  snap_angles: [0, 90, 180, 270]  // Allowed angles\n  angle_tolerance: 15          // Degrees of acceptable error\n  auto_orient: true            // Auto-align to surface normal\n  \n  // === ANIMATION ===\n  snap_duration: 0.15          // Snap animation time (seconds)\n  easing: 'ease-out'           // Animation curve\n  \n  // === OFFSET ===\n  snap_offset: [0, 0, 0]       // Offset from snap point\n  surface_offset: 0.01         // Offset from surfaces\n  \n  // === GRID SNAPPING ===\n  type: 'grid'                 // Enable grid mode\n  grid_size: [0.5, 0.5, 0.5]   // Grid cell size\n  grid_offset: [0, 0, 0]       // Grid origin offset\n  \n  // === VISUAL FEEDBACK ===\n  preview: true                // Show snap preview\n  preview_color: '#44ff4480'   // Preview ghost color\n  preview_opacity: 0.5\n  show_grid: true              // Show grid lines\n  grid_color: '#ffffff20'\n  show_points: true            // Show snap points\n  show_points_on_hover: true   // Only show when hovering\n  point_visual: 'dot'          // dot, ring, cross, custom\n  highlight_valid: true        // Highlight valid snap targets\n  \n  // === CONSTRAINTS ===\n  vertical_only: false         // Only vertical stacking\n  horizontal_only: false       // Only horizontal placement\n  plane: 'xz'                  // Constrain to plane: xy, xz, yz\n  level_required: false        // Must be level\n  level_tolerance: 5           // Degrees tolerance for level\n  \n  // === MULTI-POINT ===\n  require_points: 1            // Minimum snap points required\n  point_spacing: null          // Required spacing between points\n  all_points_required: false   // All points must connect\n  \n  // === STACKING ===\n  stackable: true              // Allow stacking\n  max_stack: 10                // Maximum stack height\n  stack_offset: [0, 1, 0]      // Offset per stack level\n  \n  // === AUDIO & HAPTICS ===\n  snap_sound: 'snap'           // Sound on snap\n  unsnap_sound: 'pop'          // Sound on unsnap\n  haptic_on_snap: true         // Vibrate on snap\n  haptic_intensity: 0.3        // Vibration strength\n  \n  // === CONNECTION ===\n  bidirectional: true          // Two-way connection\n  max_connections: 4           // Max simultaneous connections\n  can_initiate: true           // Can start a snap\n  can_receive: true            // Can be snapped to\n}\n\n// === LIFECYCLE EVENTS ===\n\n@on_snap(info) {\n  // info.point - which snap point\n  // info.other - object snapped to\n  // info.position - snap position\n  // info.rotation - snap rotation\n  // info.type - 'grid', 'point', 'surface'\n}\n\n@on_unsnap {\n  // Called when removed from snap\n}\n\n@on_snap_preview(info) {\n  // Called while hovering over valid snap\n}\n\n@on_snap_reject(reason) {\n  // Called when snap is rejected\n  // reason: 'distance', 'angle', 'group', 'occupied'\n}\n```\n\n**Common presets:**\n```holoscript\n// Grid building\n@snappable { type: 'grid', grid_size: [1,1,1], snap_rotation: true, snap_angles: [0,90,180,270] }\n\n// Wall mount\n@snappable { snap_to: ['wall_mount'], snap_distance: 0.2, auto_orient: true }\n\n// Stackable\n@snappable { vertical_only: true, max_stack: 10, stack_offset: [0,0.5,0] }\n\n// Magnetic\n@snappable { magnetic: true, magnetic_range: 0.3, snap_duration: 0.3 }\n```"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Create puzzle pieces that snap together"}, {"role": "assistant", "content": "Here's a jigsaw puzzle with snapping pieces:\n\n```holoscript\nscene JigsawPuzzle {\n  state {\n    gridSize: [4, 4]   // 4x4 = 16 pieces\n    pieceSize: 0.2\n    completedPieces: 0\n    puzzleImage: 'assets/puzzles/landscape.jpg'\n  }\n  \n  // Puzzle frame/board\n  object PuzzleBoard {\n    position: [0, 1, -1.5]\n    rotation: [45, 0, 0]  // Angled for easier viewing\n    \n    geometry: 'plane'\n    size: [state.gridSize[0] * state.pieceSize, state.gridSize[1] * state.pieceSize]\n    \n    trait Material {\n      color: '#3a3a3a'\n    }\n    \n    @snappable {\n      type: 'grid'\n      grid_size: [state.pieceSize, state.pieceSize]\n      snap_group: 'puzzle_grid'\n      show_grid: true\n      grid_color: '#ffffff10'\n    }\n  }\n  \n  // Generate puzzle pieces\n  @on_mount {\n    for (let y = 0; y < state.gridSize[1]; y++) {\n      for (let x = 0; x < state.gridSize[0]; x++) {\n        spawn \"PuzzlePiece\" {\n          // Start scattered nearby\n          position: [\n            -0.5 + Math.random() * 1,\n            0.8 + Math.random() * 0.2,\n            -0.5 + Math.random() * 0.5\n          ]\n          state: {\n            gridX: x,\n            gridY: y,\n            isPlaced: false\n          }\n        }\n      }\n    }\n  }\n  \n  prefab PuzzlePiece {\n    object piece {\n      geometry: 'plane'\n      size: [state.pieceSize * 0.95, state.pieceSize * 0.95]\n      \n      // UV offset for this piece's section of image\n      trait Material {\n        texture: state.puzzleImage\n        uv_offset: [state.gridX / state.gridSize[0], state.gridY / state.gridSize[1]]\n        uv_scale: [1 / state.gridSize[0], 1 / state.gridSize[1]]\n      }\n      \n      @grabbable\n      @snappable {\n        snap_to: ['puzzle_grid']\n        snap_distance: 0.08\n        snap_rotation: true\n        snap_angles: [0]  // Must be right-side up\n        angle_tolerance: 20\n        \n        // Custom validation - must be correct position\n        validate: (snapInfo) => {\n          let gridPos = self.worldToGrid(snapInfo.position)\n          return gridPos.x === state.gridX && gridPos.y === state.gridY\n        }\n      }\n      @hoverable {\n        glow: true\n        scale_effect: 1.05\n      }\n      \n      @on_snap(info) {\n        let gridPos = self.worldToGrid(info.position)\n        \n        // Check if correct position\n        if (gridPos.x === state.gridX && gridPos.y === state.gridY) {\n          state.isPlaced = true\n          self.physics = 'static'  // Lock in place\n          \n          // Success feedback\n          audio.play(\"piece_correct\")\n          spawn \"SuccessSparkle\" { position: self.position }\n          \n          scene.state.completedPieces++\n          \n          // Check if puzzle complete\n          if (scene.state.completedPieces === state.gridSize[0] * state.gridSize[1]) {\n            scene.puzzleComplete()\n          }\n        } else {\n          // Wrong position - reject\n          audio.play(\"piece_wrong\")\n          self.reject()  // Bounce back\n        }\n      }\n      \n      @on_snap_reject(reason) {\n        // Visual feedback for wrong placement\n        animation Shake {\n          property: 'rotation.z'\n          keyframes: [0, 5, -5, 3, -3, 0]\n          duration: 300\n        }\n      }\n      \n      action worldToGrid(worldPos) {\n        let boardPos = PuzzleBoard.worldToLocal(worldPos)\n        return {\n          x: Math.round((boardPos.x + 0.4) / state.pieceSize),\n          y: Math.round((boardPos.y + 0.4) / state.pieceSize)\n        }\n      }\n    }\n  }\n  \n  action puzzleComplete() {\n    audio.play(\"puzzle_complete\")\n    spawn \"Confetti\" { position: [0, 2, -1.5] }\n    ui.showMessage(\"Puzzle Complete! ðŸŽ‰\")\n  }\n}\n```\n\nPuzzle features:\n- Grid snapping for placement\n- Position validation\n- Wrong-piece rejection\n- Completion tracking\n- UV-mapped piece images"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Magnetic snap for electronics/circuits"}, {"role": "assistant", "content": "Here's an electronics circuit building system:\n\n```holoscript\nscene CircuitBuilder {\n  // Circuit breadboard\n  object Breadboard {\n    mesh: 'assets/electronics/breadboard.glb'\n    position: [0, 1, -1]\n    \n    // Generate connection points in rows\n    @snappable {\n      type: 'grid'\n      grid_size: [0.01, 0.01]  // 10mm spacing\n      rows: 30\n      columns: 10\n      snap_group: 'breadboard_holes'\n      show_points_on_hover: true\n      point_visual: 'hole'\n    }\n  }\n  \n  // LED component\n  prefab LED {\n    object led {\n      mesh: 'assets/electronics/led.glb'\n      scale: 0.02\n      \n      state {\n        color: '#ff0000'\n        isOn: false\n        anode: null    // Positive leg\n        cathode: null  // Negative leg\n      }\n      \n      @grabbable\n      @snappable {\n        snap_to: ['breadboard_holes', 'wire_end']\n        snap_distance: 0.02\n        magnetic: true\n        magnetic_range: 0.03\n        magnetic_strength: 0.8\n        \n        // Two pins that need to connect\n        snap_points: [\n          { position: [-0.003, -0.01, 0], group: 'component_pin', id: 'anode' },\n          { position: [0.003, -0.01, 0], group: 'component_pin', id: 'cathode' }\n        ]\n        \n        require_points: 2  // Both pins must connect\n      }\n      \n      @on_snap(info) {\n        if (info.point.id === 'anode') {\n          state.anode = info.connection\n        } else {\n          state.cathode = info.connection\n        }\n        \n        audio.play_spatial(\"component_insert\", self.position)\n        circuit.recalculate()\n      }\n      \n      @on_unsnap(info) {\n        if (info.point.id === 'anode') state.anode = null\n        else state.cathode = null\n        \n        circuit.recalculate()\n      }\n      \n      action updateState() {\n        // LED lights up if power flows through\n        state.isOn = circuit.hasPower(state.anode, state.cathode)\n        \n        self.light.enabled = state.isOn\n        self.light.color = state.color\n      }\n    }\n  }\n  \n  // Resistor component\n  prefab Resistor {\n    object resistor {\n      mesh: 'assets/electronics/resistor.glb'\n      \n      state {\n        ohms: 1000  // 1K ohm\n        terminals: [null, null]\n      }\n      \n      @grabbable\n      @snappable {\n        snap_to: ['breadboard_holes']\n        snap_distance: 0.02\n        magnetic: true\n        magnetic_strength: 0.7\n        \n        snap_points: [\n          { position: [-0.01, -0.005, 0], group: 'component_pin', id: 'term1' },\n          { position: [0.01, -0.005, 0], group: 'component_pin', id: 'term2' }\n        ]\n        \n        require_points: 2\n        point_spacing: 0.02  // Legs are 20mm apart\n      }\n      \n      @on_snap(info) {\n        let idx = info.point.id === 'term1' ? 0 : 1\n        state.terminals[idx] = info.connection\n        audio.play_spatial(\"component_insert\", self.position)\n        circuit.recalculate()\n      }\n    }\n  }\n  \n  // Wire\n  prefab Wire {\n    object wire {\n      state {\n        color: '#ff0000'\n        startPoint: null\n        endPoint: null\n      }\n      \n      @grabbable\n      @snappable {\n        snap_to: ['breadboard_holes', 'component_pin']\n        snap_distance: 0.015\n        magnetic: true\n        \n        snap_points: [\n          { position: [0, 0, 0], group: 'wire_end', id: 'start' },\n          { position: [0.05, 0, 0], group: 'wire_end', id: 'end' }\n        ]\n        \n        flexible: true  // Wire bends to connect\n      }\n      \n      // Dynamic wire mesh\n      @on_update {\n        if (state.startPoint && state.endPoint) {\n          self.mesh = generateWireMesh(\n            state.startPoint.position,\n            state.endPoint.position,\n            state.color\n          )\n        }\n      }\n      \n      @on_snap(info) {\n        if (info.point.id === 'start') {\n          state.startPoint = info.connection\n        } else {\n          state.endPoint = info.connection\n        }\n        \n        circuit.addConnection(state.startPoint, state.endPoint)\n        circuit.recalculate()\n      }\n    }\n  }\n  \n  // Battery\n  prefab Battery {\n    object battery {\n      mesh: 'assets/electronics/9v_battery.glb'\n      \n      state {\n        voltage: 9\n        positive: null\n        negative: null\n      }\n      \n      @grabbable\n      @snappable {\n        snap_to: ['breadboard_holes', 'battery_clip']\n        snap_distance: 0.03\n        magnetic: true\n        \n        snap_points: [\n          { position: [0, 0.02, 0.005], group: 'power', id: 'positive', polarity: '+' },\n          { position: [0, 0.02, -0.005], group: 'power', id: 'negative', polarity: '-' }\n        ]\n      }\n      \n      @on_snap(info) {\n        if (info.point.polarity === '+') {\n          state.positive = info.connection\n        } else {\n          state.negative = info.connection\n        }\n        circuit.setPowerSource(self)\n        circuit.recalculate()\n      }\n    }\n  }\n}\n```\n\nCircuit features:\n- Magnetic snap for precision\n- Multi-pin components\n- Wire flexibility\n- Circuit recalculation on connect"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Snap-to-surface for placing decorations"}, {"role": "assistant", "content": "Here's surface snapping for decorations:\n\n```holoscript\nscene DecoratingRoom {\n  // Room surfaces\n  object Floor {\n    geometry: 'plane'\n    size: [10, 10]\n    \n    @snappable {\n      type: 'surface'\n      surface_group: 'floor'\n      snap_up_vector: [0, 1, 0]  // Items face up\n    }\n  }\n  \n  object[] Walls {\n    count: 4\n    geometry: 'plane'\n    size: [10, 3]\n    // Positioned around room...\n    \n    @snappable {\n      type: 'surface'\n      surface_group: 'wall'\n      auto_orient: true  // Items face outward from wall\n    }\n  }\n  \n  object Ceiling {\n    geometry: 'plane'\n    size: [10, 10]\n    position: [0, 3, 0]\n    rotation: [180, 0, 0]\n    \n    @snappable {\n      type: 'surface'\n      surface_group: 'ceiling'\n      snap_down_vector: [0, -1, 0]  // Items hang down\n    }\n  }\n  \n  // Floor decorations\n  prefab Rug {\n    object rug {\n      mesh: 'assets/decor/rug.glb'\n      \n      @grabbable\n      @snappable {\n        snap_to: ['floor']\n        snap_distance: 0.3\n        auto_orient: true       // Align to floor\n        surface_offset: 0.001   // Tiny offset to prevent z-fighting\n        \n        rotation_snap: true\n        snap_angles: [0, 45, 90, 135, 180, 225, 270, 315]\n      }\n      @hoverable {\n        glow: true\n      }\n      \n      @on_snap {\n        audio.play(\"rug_place\")\n      }\n    }\n  }\n  \n  prefab Lamp {\n    object lamp {\n      mesh: 'assets/decor/floor_lamp.glb'\n      \n      @grabbable\n      @snappable {\n        snap_to: ['floor', 'table_surface']\n        snap_distance: 0.2\n        auto_orient: true\n        \n        // Lamp must be upright\n        up_vector_required: true\n        up_tolerance: 10  // degrees\n      }\n      \n      @on_snap(info) {\n        if (info.surface === 'table_surface') {\n          self.scale = 0.5  // Smaller on table\n        } else {\n          self.scale = 1.0\n        }\n      }\n    }\n  }\n  \n  // Wall decorations\n  prefab Painting {\n    object painting {\n      mesh: 'assets/decor/painting.glb'\n      \n      @grabbable\n      @snappable {\n        snap_to: ['wall']\n        snap_distance: 0.3\n        auto_orient: true\n        surface_offset: 0.02  // Stand off from wall\n        \n        // Prefer center-ish height\n        preferred_height: 1.5\n        height_snap_strength: 0.5\n      }\n      @hoverable {\n        glow: true\n      }\n      \n      @on_snap {\n        audio.play(\"picture_hang\")\n        \n        // Settle animation\n        animation Settle {\n          property: 'rotation.z'\n          keyframes: [3, -2, 1, 0]\n          duration: 400\n        }\n      }\n    }\n  }\n  \n  prefab Mirror {\n    object mirror {\n      mesh: 'assets/decor/mirror.glb'\n      \n      @grabbable\n      @snappable {\n        snap_to: ['wall']\n        snap_distance: 0.3\n        auto_orient: true\n        surface_offset: 0.03\n        \n        // Heavy - needs good placement\n        require_stud: true  // Snap to wall studs\n        stud_spacing: 0.4   // 40cm stud spacing\n      }\n      \n      trait Reflective {\n        reflection_probe: true\n        realtime_reflection: true\n      }\n    }\n  }\n  \n  // Ceiling decorations\n  prefab CeilingLight {\n    object light {\n      mesh: 'assets/decor/ceiling_light.glb'\n      \n      @grabbable\n      @snappable {\n        snap_to: ['ceiling']\n        snap_distance: 0.4\n        auto_orient: true  // Hangs down\n        \n        // Snap to electrical outlet positions\n        electrical_required: true\n        outlet_group: 'ceiling_outlet'\n      }\n      \n      light {\n        type: 'point'\n        color: '#fff5e6'\n        intensity: 2.0\n        range: 8\n      }\n      \n      @on_snap(info) {\n        if (info.hasElectrical) {\n          self.light.enabled = true\n        }\n      }\n    }\n  }\n  \n  prefab HangingPlant {\n    object plant {\n      mesh: 'assets/decor/hanging_plant.glb'\n      \n      @grabbable\n      @snappable {\n        snap_to: ['ceiling', 'ceiling_hook']\n        snap_distance: 0.3\n        \n        // Hang with chain\n        hanging: true\n        chain_length: 0.5\n        sway: true  // Gentle movement\n      }\n      \n      // Plant sway animation\n      @on_snap {\n        animation Sway {\n          property: 'rotation.x'\n          keyframes: [0, 2, 0, -2, 0]\n          duration: 4000\n          loop: infinite\n          easing: 'sine'\n        }\n      }\n    }\n  }\n}\n```\n\nSurface snap features:\n- Auto-orient to surface normal\n- Surface type filtering\n- Height preferences\n- Electrical/stud requirements\n- Hanging physics"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Snap weapons to holster/belt"}, {"role": "assistant", "content": "Here's a weapon holster system:\n\n```holoscript\n// Player equipment belt\nobject PlayerBelt {\n  attachment: 'player.waist'\n  \n  // Hip holster - right side\n  object RightHolster {\n    position: [0.25, 0, 0.1]\n    \n    @snappable {\n      snap_group: 'pistol_holster'\n      snap_distance: 0.15\n      magnetic: true\n      magnetic_range: 0.25\n      magnetic_strength: 0.9\n      \n      // Visual when empty\n      show_empty_indicator: true\n      empty_visual: 'holster_outline'\n      empty_color: '#ffffff30'\n      \n      // Only accept pistols\n      accept_groups: ['pistol']\n      max_items: 1\n    }\n    \n    @on_item_holstered(item) {\n      audio.play(\"holster_in\")\n      item.physics = 'kinematic'  // Disable physics\n    }\n    \n    @on_item_unholstered(item) {\n      audio.play(\"holster_out\")\n      item.physics = 'none'  // Re-enable later\n    }\n  }\n  \n  // Left hip holster\n  object LeftHolster {\n    position: [-0.25, 0, 0.1]\n    \n    @snappable {\n      snap_group: 'pistol_holster'\n      snap_distance: 0.15\n      magnetic: true\n      accept_groups: ['pistol', 'melee']\n      max_items: 1\n    }\n  }\n  \n  // Back slot for large weapons\n  object BackSlot {\n    position: [0, 0.3, -0.2]\n    rotation: [0, 0, 45]\n    \n    @snappable {\n      snap_group: 'back_weapon'\n      snap_distance: 0.2\n      magnetic: true\n      magnetic_range: 0.35\n      \n      accept_groups: ['rifle', 'shotgun', 'sword']\n      max_items: 2  // Can carry two on back\n      \n      // Stacking arrangement\n      stack_offset: [0.08, 0, 0]\n      stack_rotation: [0, 0, -10]\n    }\n  }\n  \n  // Ammo pouches\n  object[] AmmoPouches {\n    count: 4\n    position: [\n      [-0.15, -0.05, 0.12],\n      [-0.08, -0.05, 0.12],\n      [0.08, -0.05, 0.12],\n      [0.15, -0.05, 0.12]\n    ]\n    \n    @snappable {\n      snap_group: 'ammo_pouch'\n      snap_distance: 0.08\n      accept_groups: ['magazine', 'ammo_box']\n      max_items: 1\n      \n      // Quick grab\n      grab_priority: 'highest'\n    }\n  }\n}\n\n// Pistol with holster snapping\nprefab Pistol {\n  object pistol {\n    mesh: 'assets/weapons/pistol.glb'\n    \n    state {\n      isHolstered: false\n    }\n    \n    @grabbable {\n      grab_points: [\n        { position: [0, -0.03, 0], rotation: [0, 0, 0] }  // Grip\n      ]\n    }\n    @snappable {\n      snap_to: ['pistol_holster']\n      snap_group: 'pistol'\n      snap_distance: 0.15\n      magnetic: true\n      \n      // Holster orientation\n      holster_rotation: [0, 180, 0]  // Grip accessible\n      holster_offset: [0, 0.05, 0]\n      \n      // Quick holster on release\n      auto_snap_on_release: true\n      auto_snap_range: 0.3\n    }\n    \n    @on_snap {\n      state.isHolstered = true\n    }\n    \n    @on_grab {\n      if (state.isHolstered) {\n        state.isHolstered = false\n        audio.play(\"draw_weapon\")\n      }\n    }\n  }\n}\n\nprefab Rifle {\n  object rifle {\n    mesh: 'assets/weapons/rifle.glb'\n    \n    @grabbable {\n      two_handed: true\n      grab_points: [\n        { position: [0, -0.05, 0.1], type: 'primary' },\n        { position: [0, -0.05, -0.2], type: 'secondary' }\n      ]\n    }\n    @snappable {\n      snap_to: ['back_weapon']\n      snap_group: 'rifle'\n      snap_distance: 0.2\n      \n      // Slung over shoulder\n      shoulder_sling: true\n      sling_rotation: [0, 90, 45]\n    }\n  }\n}\n\nprefab Magazine {\n  object mag {\n    mesh: 'assets/weapons/magazine.glb'\n    \n    @grabbable\n    @snappable {\n      snap_to: ['ammo_pouch', 'weapon_magwell']\n      snap_group: 'magazine'\n      snap_distance: 0.1\n      \n      // Different snap based on target\n      snap_presets: {\n        'ammo_pouch': {\n          offset: [0, 0.02, 0],\n          rotation: [0, 0, 0]\n        },\n        'weapon_magwell': {\n          offset: [0, -0.08, 0],\n          rotation: [0, 0, 0],\n          insert_animation: 'mag_insert'\n        }\n      }\n    }\n    \n    @on_snap(info) {\n      if (info.target_group === 'weapon_magwell') {\n        audio.play(\"mag_insert\")\n        info.target.reload(self)\n      } else {\n        audio.play(\"mag_pouch\")\n      }\n    }\n  }\n}\n```\n\nWeapon holster features:\n- Magnetic attraction to holsters\n- Weapon type filtering\n- Auto-holster on release\n- Draw sound effects\n- Magazine insertion snapping"}]}
