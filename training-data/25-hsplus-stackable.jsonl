{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Create a stackable block system for building games"}, {"role": "assistant", "content": "Here's a stackable block system:\n\n```holoscript\nprefab StackableBlock {\n  object block {\n    geometry: 'box'\n    size: [0.5, 0.5, 0.5]\n    \n    @grabbable\n    @throwable\n    @stackable {\n      stack_limit: 10\n      snap_offset: [0, 0.5, 0]\n      auto_align: true\n      magnetic: true\n      magnetic_range: 0.3\n    }\n    \n    @on_stack(stackInfo) {\n      audio.play_spatial(\"block_snap\", self.position)\n      haptic_pulse(0.2)\n    }\n    \n    @on_unstack {\n      audio.play_spatial(\"block_remove\", self.position)\n    }\n  }\n}\n```\n\nKey `@stackable` properties:\n- `stack_limit`: Maximum blocks in a stack\n- `snap_offset`: Position offset when stacking\n- `auto_align`: Auto-align to grid\n- `magnetic`: Objects attract when close"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Make stackable inventory items with weight limits"}, {"role": "assistant", "content": "Here's an inventory stacking system with weight limits:\n\n```holoscript\nprefab StackableItem {\n  object item {\n    mesh: 'assets/items/gem.glb'\n    scale: 0.1\n    \n    state {\n      itemType: 'gem'\n      weight: 0.5\n      stackCount: 1\n      maxStack: 64\n    }\n    \n    @grabbable\n    @stackable {\n      stack_limit: state.maxStack\n      snap_offset: [0, 0.02, 0]\n      auto_align: true\n      stack_condition: (other) => {\n        return other.state.itemType === self.state.itemType\n      }\n    }\n    \n    @on_stack(stackInfo) {\n      state.stackCount = stackInfo.totalCount\n      self.updateVisual()\n      \n      // Check weight limit\n      let totalWeight = state.stackCount * state.weight\n      if (totalWeight > 10) {\n        ui.showWarning(\"Stack too heavy!\")\n      }\n    }\n    \n    action updateVisual() {\n      // Scale badge based on count\n      self.badge.text = state.stackCount.toString()\n      self.badge.visible = state.stackCount > 1\n    }\n  }\n}\n```\n\nThis system:\n- Limits stacking to same item types\n- Tracks total weight\n- Shows stack count badge"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Stackable plates that can be picked up as a group"}, {"role": "assistant", "content": "Here's a stackable plate system with group pickup:\n\n```holoscript\nprefab StackablePlate {\n  object plate {\n    mesh: 'assets/props/plate.glb'\n    physics: 'rigid_body'\n    mass: 0.3\n    \n    @grabbable {\n      grab_stack: true  // Pick up entire stack\n    }\n    @stackable {\n      stack_limit: 8\n      snap_offset: [0, 0.03, 0]\n      auto_align: true\n      wobble_on_add: true\n      wobble_intensity: 0.05\n    }\n    @breakable {\n      threshold: 3.0\n      fragments: 'plate_shards'\n    }\n    \n    @on_stack(stackInfo) {\n      audio.play_spatial(\"ceramic_clink\", self.position)\n      \n      // Check stability\n      if (stackInfo.totalCount > 6) {\n        self.startWobble()\n      }\n    }\n    \n    @on_stack_collapse {\n      // Stack fell over\n      audio.play_spatial(\"dishes_crash\", self.position)\n      spawn \"DustCloud\" { position: self.position }\n    }\n  }\n}\n```\n\nFeatures:\n- `grab_stack: true` picks up whole stack\n- `wobble_on_add` adds realistic physics\n- Stack collapse detection"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Create stackable crates for a warehouse game"}, {"role": "assistant", "content": "Here's a warehouse crate stacking system:\n\n```holoscript\nprefab WarehouseCrate {\n  object crate {\n    geometry: 'box'\n    size: [1, 1, 1]\n    \n    trait Material {\n      preset: 'wood'\n      color: '#8B4513'\n    }\n    \n    physics: 'rigid_body'\n    mass: 10\n    \n    state {\n      contents: null\n      crateId: uuid()\n    }\n    \n    @grabbable {\n      two_handed: true\n      require_strength: 0.5\n    }\n    @stackable {\n      stack_limit: 5\n      snap_offset: [0, 1.05, 0]\n      auto_align: true\n      grid_snap: [1, 1, 1]\n      stack_sound: 'crate_thud'\n    }\n    @collidable\n    \n    // Snap to warehouse grid\n    @snappable {\n      snap_to: ['warehouse_grid']\n      snap_distance: 0.5\n    }\n    \n    @on_stack(info) {\n      // Track stack for scoring\n      game.registerStack(info.stackId, info.totalCount)\n      \n      if (info.totalCount >= 5) {\n        game.awardBonus('perfect_stack', 100)\n        spawn \"SuccessParticles\" { position: self.position }\n      }\n    }\n  }\n}\n```\n\nWarehouse features:\n- Two-handed grab for heavy crates\n- Grid snapping for organization\n- Score bonuses for tall stacks"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "How do I configure @stackable options?"}, {"role": "assistant", "content": "Here's the complete `@stackable` configuration reference:\n\n```holoscript\nobject StackableObject {\n  @stackable {\n    // === Core Settings ===\n    stack_limit: 10          // Max items in stack (default: unlimited)\n    snap_offset: [0, 0.5, 0] // Position offset when stacking [x, y, z]\n    auto_align: true         // Auto-align rotation when stacking\n    \n    // === Magnetic Behavior ===\n    magnetic: true           // Objects attract when near\n    magnetic_range: 0.3      // Range of magnetic attraction (meters)\n    magnetic_strength: 0.5   // Attraction force (0-1)\n    \n    // === Grid Snapping ===\n    grid_snap: [0.5, 0.5, 0.5]  // Snap to grid size\n    \n    // === Physics ===\n    wobble_on_add: true      // Add wobble physics when stacking\n    wobble_intensity: 0.1    // Wobble amount (0-1)\n    collapse_threshold: 8    // Stack collapses if exceeded\n    \n    // === Audio ===\n    stack_sound: 'stack_snap' // Sound when stacking\n    unstack_sound: 'unstack'  // Sound when removing\n    \n    // === Conditional Stacking ===\n    stack_condition: (other) => {\n      // Return true if objects can stack\n      return self.type === other.type\n    }\n    \n    // === Stack Groups ===\n    stack_group: 'blocks'    // Only stacks with same group\n  }\n  \n  // === Stack Events ===\n  @on_stack(info) {\n    // info.stackId - unique stack identifier\n    // info.totalCount - items in stack\n    // info.position - stack position\n    log(`Stacked! Total: ${info.totalCount}`)\n  }\n  \n  @on_unstack {\n    log(\"Removed from stack\")\n  }\n  \n  @on_stack_collapse {\n    log(\"Stack collapsed!\")\n  }\n}\n```\n\nCommon patterns:\n- Building blocks: `stack_limit: 20, grid_snap: [1,1,1]`\n- Dishes: `stack_limit: 8, wobble_on_add: true`\n- Cards: `stack_limit: 52, snap_offset: [0, 0.001, 0]`"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Make stackable coins that merge into larger denominations"}, {"role": "assistant", "content": "Here's a coin stacking system with auto-merge:\n\n```holoscript\nprefab StackableCoin {\n  object coin {\n    mesh: 'assets/items/gold_coin.glb'\n    scale: 0.05\n    \n    trait Material {\n      color: '#FFD700'\n      metallic: 0.95\n      roughness: 0.1\n    }\n    \n    state {\n      denomination: 1      // 1, 5, 10, 25, 100\n      totalValue: 1\n    }\n    \n    @grabbable\n    @stackable {\n      stack_limit: 25\n      snap_offset: [0, 0.003, 0]\n      auto_align: true\n      stack_group: 'coins'\n      merge_enabled: true\n      merge_threshold: 10\n    }\n    \n    @on_stack(info) {\n      state.totalValue = info.totalCount * state.denomination\n      audio.play_spatial(\"coin_clink\", self.position)\n      \n      // Auto-convert when stack reaches threshold\n      if (info.totalCount >= 10 && state.denomination < 100) {\n        self.convertStack()\n      }\n      \n      // Update floating label\n      self.valueLabel.text = `$${state.totalValue}`\n    }\n    \n    action convertStack() {\n      let newDenom = state.denomination * 10\n      let position = self.position\n      \n      // Despawn current stack\n      despawn(self.stack)\n      \n      // Spawn converted coin\n      spawn \"StackableCoin\" {\n        position: position\n        state: {\n          denomination: newDenom,\n          totalValue: newDenom\n        }\n        material: getCoinMaterial(newDenom)\n      }\n      \n      audio.play_spatial(\"coin_convert\", position)\n      spawn \"CoinSparkle\" { position: position }\n    }\n  }\n}\n\nfunction getCoinMaterial(denom) {\n  switch(denom) {\n    case 5:   return { color: '#C0C0C0', metallic: 0.9 }  // Silver\n    case 10:  return { color: '#B87333', metallic: 0.85 } // Bronze\n    case 25:  return { color: '#FFD700', metallic: 0.95 } // Gold\n    case 100: return { color: '#E5E4E2', metallic: 1.0 }  // Platinum\n    default:  return { color: '#FFD700', metallic: 0.9 }\n  }\n}\n```\n\nThis system:\n- Tracks total value across stacks\n- Auto-converts 10 coins to higher denomination\n- Visual feedback with sparkles"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Create a Jenga-style tower with physics-based stacking"}, {"role": "assistant", "content": "Here's a physics-based Jenga tower:\n\n```holoscript\nscene JengaGame {\n  config {\n    physics: {\n      gravity: -9.81\n      substeps: 4  // Higher for stability\n    }\n  }\n  \n  prefab JengaBlock {\n    object block {\n      geometry: 'box'\n      size: [0.3, 0.1, 0.1]\n      \n      trait Material {\n        preset: 'wood'\n        roughness: 0.6\n      }\n      \n      physics: 'rigid_body'\n      mass: 0.1\n      friction: 0.8\n      \n      state {\n        layer: 0\n        removed: false\n      }\n      \n      @grabbable {\n        preserve_rotation: true\n        slow_pull: true        // Careful extraction\n        slow_pull_speed: 0.5\n      }\n      @stackable {\n        stack_limit: 54  // Standard Jenga\n        auto_align: false  // Manual placement\n        physics_stack: true\n        stability_check: true\n      }\n      @collidable\n      \n      @on_grab {\n        state.removed = true\n        game.checkStability()\n      }\n      \n      @on_release {\n        // Must place on top\n        if (self.position.y < game.tower.topY) {\n          ui.showWarning(\"Place on top!\")\n          self.returnToOriginalPosition()\n        }\n      }\n      \n      @on_collision(other, impulse) {\n        if (impulse > 0.5 && state.removed) {\n          game.towerFell()\n        }\n      }\n    }\n  }\n  \n  object Tower {\n    position: [0, 0, -2]\n    \n    @on_mount {\n      self.buildTower(18)  // 18 layers = 54 blocks\n    }\n    \n    action buildTower(layers) {\n      for (let layer = 0; layer < layers; layer++) {\n        let isRotated = layer % 2 === 1\n        \n        for (let block = 0; block < 3; block++) {\n          spawn \"JengaBlock\" {\n            position: self.calculateBlockPosition(layer, block, isRotated)\n            rotation: isRotated ? [0, 90, 0] : [0, 0, 0]\n            state: { layer: layer }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nFeatures:\n- `slow_pull` for careful block extraction\n- `physics_stack` for realistic physics\n- `stability_check` monitors tower balance\n- Collision detection for tower collapse"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Stackable food items for a cooking game"}, {"role": "assistant", "content": "Here's a cooking game stacking system:\n\n```holoscript\n// Base ingredient trait\ntrait StackableIngredient {\n  @grabbable\n  @stackable {\n    stack_limit: 5\n    snap_offset: [0, 0.05, 0]\n    auto_align: true\n    stack_group: 'ingredients'\n    allow_mixed: true  // Different ingredients can stack\n  }\n  @hoverable {\n    glow: true\n    show_tooltip: true\n  }\n}\n\nprefab BurgerPatty {\n  object patty {\n    mesh: 'assets/food/patty.glb'\n    scale: 0.15\n    \n    use StackableIngredient\n    \n    state {\n      ingredient: 'patty'\n      cooked: false\n    }\n    \n    @on_stack(info) {\n      game.updateRecipe(info.stack)\n    }\n  }\n}\n\nprefab LettuceLeaf {\n  object lettuce {\n    mesh: 'assets/food/lettuce.glb'\n    scale: 0.12\n    \n    use StackableIngredient\n    state { ingredient: 'lettuce' }\n  }\n}\n\nprefab TomatoSlice {\n  object tomato {\n    mesh: 'assets/food/tomato_slice.glb'\n    scale: 0.1\n    \n    use StackableIngredient\n    state { ingredient: 'tomato' }\n  }\n}\n\nprefab BunTop {\n  object bun {\n    mesh: 'assets/food/bun_top.glb'\n    scale: 0.15\n    \n    @stackable {\n      stack_limit: 1\n      snap_offset: [0, 0.06, 0]\n      stack_group: 'ingredients'\n      finishes_stack: true  // Completes the burger\n    }\n    \n    @on_stack(info) {\n      // Check if valid burger\n      if (game.validateBurger(info.stack)) {\n        spawn \"CompleteBurger\" {\n          position: info.stack[0].position\n          ingredients: info.stack.map(i => i.state.ingredient)\n        }\n        \n        // Clear ingredient stack\n        info.stack.forEach(item => despawn(item))\n        \n        audio.play(\"order_complete\")\n        game.scorePoints(calculateScore(info.stack))\n      }\n    }\n  }\n}\n```\n\nCooking features:\n- Mixed ingredient stacking\n- Recipe validation on bun top\n- Auto-combine into finished dish"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Card deck with stackable cards"}, {"role": "assistant", "content": "Here's a stackable card deck system:\n\n```holoscript\nprefab PlayingCard {\n  object card {\n    geometry: 'plane'\n    size: [0.063, 0.088]  // Standard card ratio\n    \n    trait Material {\n      texture: () => `assets/cards/${state.suit}_${state.value}.png`\n      backTexture: 'assets/cards/card_back.png'\n      doubleSided: true\n    }\n    \n    state {\n      suit: 'hearts'    // hearts, diamonds, clubs, spades\n      value: 'A'        // A, 2-10, J, Q, K\n      faceUp: false\n      inDeck: true\n    }\n    \n    @grabbable {\n      grab_from_stack: 'top'  // Only grab top card\n    }\n    @stackable {\n      stack_limit: 52\n      snap_offset: [0, 0.001, 0]  // Very thin offset\n      auto_align: true\n      stack_group: 'cards'\n      shuffle_on_combine: false\n    }\n    @hoverable {\n      scale_effect: 1.02\n    }\n    \n    @on_grab {\n      state.inDeck = false\n    }\n    \n    @on_release {\n      // Check if dropped on valid zone\n      let zone = self.getDropZone()\n      if (zone) {\n        zone.acceptCard(self)\n      }\n    }\n    \n    action flip() {\n      state.faceUp = !state.faceUp\n      animation FlipCard {\n        property: 'rotation.x'\n        to: state.faceUp ? 0 : 180\n        duration: 300\n        easing: 'ease-out'\n      }\n    }\n  }\n}\n\nobject CardDeck {\n  position: [0, 1, -1]\n  \n  @stackable {\n    stack_limit: 52\n    initial_count: 52\n  }\n  \n  @pointable {\n    onPoint: () => self.drawCard()\n  }\n  \n  @on_mount {\n    self.initializeDeck()\n  }\n  \n  action initializeDeck() {\n    const suits = ['hearts', 'diamonds', 'clubs', 'spades']\n    const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n    \n    suits.forEach(suit => {\n      values.forEach(value => {\n        spawn \"PlayingCard\" {\n          parent: self\n          state: { suit, value, faceUp: false, inDeck: true }\n        }\n      })\n    })\n    \n    self.shuffle()\n  }\n  \n  action shuffle() {\n    // Fisher-Yates shuffle\n    for (let i = self.cards.length - 1; i > 0; i--) {\n      let j = Math.floor(Math.random() * (i + 1))\n      [self.cards[i], self.cards[j]] = [self.cards[j], self.cards[i]]\n    }\n    self.rearrangeStack()\n    audio.play(\"card_shuffle\")\n  }\n  \n  action drawCard() {\n    let card = self.cards.pop()\n    if (card) {\n      card.state.faceUp = true\n      card.flip()\n      return card\n    }\n  }\n}\n```\n\nCard features:\n- 52-card deck with suits\n- Shuffle animation\n- Flip to reveal\n- Stack offset for realistic look"}]}
{"messages": [{"role": "system", "content": "You are Brittney, a spatial programming assistant. Generate HoloScript code from natural language descriptions."}, {"role": "user", "content": "Stackable building blocks with connection points"}, {"role": "assistant", "content": "Here's a LEGO-style building block system:\n\n```holoscript\nprefab BuildingBlock {\n  object block {\n    geometry: 'box'\n    size: [0.032, 0.019, 0.032]  // LEGO-ish scale\n    \n    trait Material {\n      preset: 'plastic'\n      color: state.color\n    }\n    \n    state {\n      color: '#FF0000'\n      studsX: 2\n      studsZ: 2\n      connected: []\n    }\n    \n    @grabbable\n    @stackable {\n      stack_limit: 100\n      auto_align: true\n      connection_type: 'studs'\n    }\n    @snappable {\n      snap_points: self.generateSnapPoints()\n      snap_distance: 0.01\n      snap_rotation: true\n      snap_to: ['block_studs', 'block_holes']\n    }\n    \n    // Studs on top\n    children {\n      object[] Studs {\n        count: state.studsX * state.studsZ\n        geometry: 'cylinder'\n        radius: 0.0024\n        height: 0.0017\n        color: state.color\n        \n        distribution: {\n          pattern: 'grid'\n          columns: state.studsX\n          rows: state.studsZ\n          spacing: 0.008\n        }\n        \n        snap_group: 'block_studs'\n      }\n    }\n    \n    action generateSnapPoints() {\n      let points = []\n      for (let x = 0; x < state.studsX; x++) {\n        for (let z = 0; z < state.studsZ; z++) {\n          // Top connection (stud)\n          points.push({\n            position: [x * 0.008 - 0.008, 0.0095, z * 0.008 - 0.008],\n            group: 'block_studs',\n            type: 'male'\n          })\n          // Bottom connection (hole)\n          points.push({\n            position: [x * 0.008 - 0.008, -0.0095, z * 0.008 - 0.008],\n            group: 'block_holes',\n            type: 'female'\n          })\n        }\n      }\n      return points\n    }\n    \n    @on_snap(other) {\n      state.connected.push(other.id)\n      audio.play_spatial(\"block_click\", self.position)\n      haptic_pulse(0.3)\n    }\n    \n    @on_unsnap(other) {\n      state.connected = state.connected.filter(id => id !== other.id)\n    }\n  }\n}\n\n// Block variations\nprefab Block2x4 extends BuildingBlock {\n  state { studsX: 4, studsZ: 2 }\n  size: [0.064, 0.019, 0.032]\n}\n\nprefab Block2x2 extends BuildingBlock {\n  state { studsX: 2, studsZ: 2 }\n  size: [0.032, 0.019, 0.032]\n}\n\nprefab Block1x4 extends BuildingBlock {\n  state { studsX: 4, studsZ: 1 }\n  size: [0.064, 0.019, 0.016]\n}\n```\n\nBuilding block features:\n- Stud-based connections\n- Grid-aligned snapping\n- Multiple block sizes\n- Connection tracking"}]}
