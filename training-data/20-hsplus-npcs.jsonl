{"prompt": "Create an NPC creature that patrols and attacks when player is near", "completion": "<thinking>\nNPC behavior in HoloScript+ should be declarative:\n1. Use template for reusable creature definition\n2. State machine for patrol/alert/attack states\n3. Events for state transitions, not polling\n4. Spatial triggers rather than distance checks in loops\n5. Action functions for attack behavior\n</thinking>\n\n```holoscript\ntemplate \"PatrolCreature\" {\n  model: \"assets/creatures/goblin.glb\"\n  scale: 0.9\n  physics: \"character_controller\"\n  \n  state {\n    currentState: \"patrol\"\n    health: 100\n    damage: 15\n    patrolSpeed: 2\n    chaseSpeed: 4\n    attackRange: 2\n    detectionRange: 10\n    target: null\n  }\n  \n  // Patrol waypoints\n  patrol_path {\n    points: [[0, 0, 0], [5, 0, 0], [5, 0, 5], [0, 0, 5]]\n    loop: true\n  }\n  \n  // Detection trigger zone\n  trigger_zone \"detection\" {\n    shape: \"sphere\"\n    radius: state.detectionRange\n    \n    @on_enter(other) {\n      if (other.tag == \"player\") {\n        self.state.target = other\n        self.transition(\"alert\")\n      }\n    }\n    \n    @on_exit(other) {\n      if (other == self.state.target) {\n        self.state.target = null\n        self.transition(\"patrol\")\n      }\n    }\n  }\n  \n  // State machine\n  states {\n    \n    \"patrol\" {\n      @on_enter {\n        anim.play(\"walk\", { loop: true })\n      }\n      \n      @on_update {\n        move_along_path(self.patrol_path, self.state.patrolSpeed)\n      }\n    }\n    \n    \"alert\" {\n      @on_enter {\n        anim.play(\"alert\")\n        audio.play_spatial(\"growl\", self.position)\n        await delay(500)\n        self.transition(\"chase\")\n      }\n    }\n    \n    \"chase\" {\n      @on_enter {\n        anim.play(\"run\", { loop: true })\n      }\n      \n      @on_update {\n        if (self.state.target) {\n          move_toward(self.state.target.position, self.state.chaseSpeed)\n          look_at(self.state.target.position)\n          \n          if (distance(self.position, self.state.target.position) < self.state.attackRange) {\n            self.transition(\"attack\")\n          }\n        }\n      }\n    }\n    \n    \"attack\" {\n      @on_enter {\n        anim.play(\"attack\")\n        audio.play_spatial(\"attack_sound\", self.position)\n      }\n      \n      @on_anim_event(\"hit_frame\") {\n        if (self.state.target && distance(self.position, self.state.target.position) < self.state.attackRange) {\n          self.state.target.take_damage(self.state.damage)\n        }\n      }\n      \n      @on_anim_complete {\n        if (self.state.target) {\n          self.transition(\"chase\")\n        } else {\n          self.transition(\"patrol\")\n        }\n      }\n    }\n  }\n  \n  action take_damage(amount) {\n    self.state.health = self.state.health - amount\n    anim.play(\"hit_react\")\n    audio.play_spatial(\"pain\", self.position)\n    \n    if (self.state.health <= 0) {\n      self.die()\n    }\n  }\n  \n  action die() {\n    anim.play(\"death\")\n    audio.play_spatial(\"death_sound\", self.position)\n    self.collider.enabled = false\n    \n    // Drop loot\n    spawn \"LootDrop\" {\n      position: self.position\n      loot_table: \"goblin_drops\"\n    }\n    \n    despawn(self, 3000)\n  }\n}\n```"}
{"prompt": "Create a friendly NPC shopkeeper with dialogue", "completion": "<thinking>\nShopkeeper NPC needs:\n1. Static position (no patrol)\n2. @hoverable and @pointable for interaction\n3. Dialogue system integration\n4. Shop UI trigger\n5. Idle animations\n6. Greeting based on player proximity\n</thinking>\n\n```holoscript\ntemplate \"Shopkeeper\" {\n  model: \"assets/npcs/merchant.glb\"\n  physics: \"static\"\n  \n  state {\n    shopId: \"general_store\"\n    hasGreeted: false\n    greetingCooldown: 30000\n  }\n  \n  @hoverable\n  @pointable\n  \n  // Idle behavior\n  behavior idle {\n    @on_update {\n      // Randomly play idle animations\n      every(5000) {\n        random_choice {\n          anim.play(\"idle_look_around\")\n          anim.play(\"idle_scratch\")\n          anim.play(\"idle_yawn\")\n        }\n      }\n    }\n  }\n  \n  // Proximity greeting\n  trigger_zone \"greeting_range\" {\n    shape: \"sphere\"\n    radius: 5\n    \n    @on_enter(other) {\n      if (other.tag == \"player\" && !self.state.hasGreeted) {\n        self.greet(other)\n      }\n    }\n  }\n  \n  @on_hover_enter {\n    // Show interaction hint\n    ui.show_tooltip(\"Talk to \" + self.name)\n    anim.play(\"acknowledge\")\n  }\n  \n  @on_hover_exit {\n    ui.hide_tooltip()\n  }\n  \n  @on_point {\n    self.open_dialogue()\n  }\n  \n  action greet(player) {\n    self.state.hasGreeted = true\n    look_at(player.position)\n    anim.play(\"wave\")\n    audio.play_spatial(\"greeting_voice\", self.position)\n    \n    // Speech bubble\n    ui.speech_bubble(self, \"Welcome, traveler!\")\n    \n    // Reset greeting after cooldown\n    await delay(self.state.greetingCooldown)\n    self.state.hasGreeted = false\n  }\n  \n  action open_dialogue() {\n    look_at(user.position)\n    \n    dialogue {\n      speaker: self.name\n      portrait: \"merchant_portrait\"\n      \n      node \"greeting\" {\n        text: \"Welcome to my shop! What can I help you with today?\"\n        \n        option \"Browse wares\" {\n          action: self.open_shop()\n        }\n        \n        option \"Tell me about this town\" {\n          goto: \"town_info\"\n        }\n        \n        option \"Goodbye\" {\n          action: close_dialogue()\n        }\n      }\n      \n      node \"town_info\" {\n        text: \"This is the village of Millbrook. We're a peaceful folk, mostly farmers and craftsmen.\"\n        \n        option \"Any work available?\" {\n          goto: \"quest_offer\"\n          condition: !player.has_quest(\"merchant_delivery\")\n        }\n        \n        option \"I see. Thanks.\" {\n          goto: \"greeting\"\n        }\n      }\n      \n      node \"quest_offer\" {\n        text: \"Actually, yes! I need someone to deliver a package to the next town. Interested?\"\n        \n        option \"I'll do it\" {\n          action: player.accept_quest(\"merchant_delivery\")\n          goto: \"quest_accepted\"\n        }\n        \n        option \"Not right now\" {\n          goto: \"greeting\"\n        }\n      }\n      \n      node \"quest_accepted\" {\n        text: \"Wonderful! Here's the package. Deliver it to Marcus in Riverdale.\"\n        action: player.add_item(\"merchant_package\")\n      }\n    }\n  }\n  \n  action open_shop() {\n    ui.open_shop(self.state.shopId)\n  }\n}\n```"}
{"prompt": "Create a boss with multiple attack phases", "completion": "<thinking>\nBoss design in HoloScript+ needs:\n1. Health-based phase transitions (declarative thresholds)\n2. Different attack patterns per phase\n3. Visual/audio feedback for phase changes\n4. Arena mechanics (avoid areas, etc.)\n5. Death sequence with rewards\n</thinking>\n\n```holoscript\ntemplate \"DragonBoss\" {\n  model: \"assets/bosses/dragon.glb\"\n  scale: 3.0\n  physics: \"character_controller\"\n  \n  state {\n    health: 5000\n    maxHealth: 5000\n    phase: 1\n    isEnraged: false\n    target: null\n  }\n  \n  // Health bar UI\n  boss_ui {\n    health_bar: true\n    name: \"Drakorath the Flame\"\n    phase_indicators: 3\n  }\n  \n  // Phase thresholds (declarative!)\n  phase_triggers {\n    phase_2: health_percent <= 0.66\n    phase_3: health_percent <= 0.33\n    enrage: health_percent <= 0.10\n  }\n  \n  @on_phase_change(newPhase) {\n    audio.play(\"boss_roar\")\n    screen.flash(0xff4400, 200)\n    \n    if (newPhase == 2) {\n      ui.boss_message(\"Drakorath takes flight!\")\n      self.enter_phase_2()\n    } else if (newPhase == 3) {\n      ui.boss_message(\"Drakorath's fury intensifies!\")\n      self.enter_phase_3()\n    }\n  }\n  \n  @on_enrage {\n    self.state.isEnraged = true\n    ui.boss_message(\"Drakorath is ENRAGED!\")\n    self.material.emissive = 0xff2200\n    \n    // Faster attacks when enraged\n    self.attack_speed_multiplier = 1.5\n  }\n  \n  // Phase 1: Ground combat\n  states {\n    \n    \"phase_1\" {\n      initial: true\n      \n      attack_pattern {\n        sequence: [\"claw_swipe\", \"tail_sweep\", \"fire_breath\"]\n        delay_between: 2000\n        loop: true\n      }\n    }\n    \n    \"phase_2\" {\n      @on_enter {\n        anim.play(\"take_flight\")\n        self.position.y = 10  // Fly up\n      }\n      \n      attack_pattern {\n        sequence: [\"dive_bomb\", \"fireball_barrage\", \"hover_breath\"]\n        delay_between: 3000\n        loop: true\n      }\n      \n      // Periodically land\n      every(20000) {\n        self.land_attack()\n      }\n    }\n    \n    \"phase_3\" {\n      @on_enter {\n        // Summon adds\n        spawn_group \"DragonWhelps\" {\n          prefab: \"DragonWhelp\"\n          count: 4\n          positions: arena.get_spawn_points()\n        }\n      }\n      \n      attack_pattern {\n        sequence: [\"claw_swipe\", \"fire_breath\", \"tail_sweep\", \"fireball_barrage\", \"summon_adds\"]\n        delay_between: 1500\n        loop: true\n      }\n    }\n  }\n  \n  // Attack definitions\n  attacks {\n    \n    \"claw_swipe\" {\n      anim: \"attack_claw\"\n      damage: 50\n      range: 5\n      arc: 120\n      \n      @on_hit(target) {\n        target.knockback(self.forward * 5)\n      }\n    }\n    \n    \"fire_breath\" {\n      anim: \"attack_breath\"\n      damage: 30\n      damage_type: \"fire\"\n      range: 15\n      arc: 45\n      duration: 3000\n      tick_rate: 500\n      \n      @on_start {\n        spawn \"FireBreathVFX\" {\n          attach_to: self.bone(\"jaw\")\n          duration: 3000\n        }\n      }\n    }\n    \n    \"dive_bomb\" {\n      @on_execute {\n        // Target area warning\n        spawn \"TargetCircle\" {\n          position: self.state.target.position\n          radius: 5\n          duration: 2000\n          color: 0xff0000\n        }\n        \n        await delay(2000)\n        \n        // Dive attack\n        anim.play(\"dive\")\n        move_to(self.state.target.position, 30)  // Fast!\n        \n        // Impact\n        aoe_damage {\n          center: self.position\n          radius: 5\n          damage: 100\n          knockback: 10\n        }\n        \n        screen.shake(0.5, 500)\n        spawn \"ImpactCrater\" { position: self.position }\n      }\n    }\n  }\n  \n  action take_damage(amount, source) {\n    self.state.health = self.state.health - amount\n    \n    // Damage number popup\n    ui.damage_number(amount, self.position + [0, 4, 0])\n    \n    // Check phase transitions (handled by phase_triggers)\n    self.check_phase_triggers()\n    \n    if (self.state.health <= 0) {\n      self.die()\n    }\n  }\n  \n  action die() {\n    // Epic death sequence\n    anim.play(\"death_dramatic\")\n    audio.play(\"boss_death_roar\")\n    screen.shake(1.0, 2000)\n    \n    await delay(3000)\n    \n    // Rewards\n    spawn \"LootChest\" {\n      position: self.position\n      loot_table: \"dragon_boss_loot\"\n      tier: \"legendary\"\n    }\n    \n    // Achievement\n    player.unlock_achievement(\"dragon_slayer\")\n    \n    // Victory fanfare\n    audio.play(\"victory_theme\")\n    ui.boss_message(\"VICTORY!\")\n    \n    despawn(self, 5000)\n  }\n}\n```"}
{"prompt": "Create networked multiplayer objects", "completion": "<thinking>\nMultiplayer sync in HoloScript+ uses:\n1. @networked trait for sync\n2. Specify which state to replicate\n3. Authority model (who controls object)\n4. Interpolation for smooth movement\n5. RPC for events\n</thinking>\n\n```holoscript\n// Networked grabbable object\nprefab NetworkedCube {\n  object cube {\n    mesh: \"cube\"\n    collider: \"box\"\n    mass: 1.0\n    \n    trait Material {\n      color: 0x4488ff\n    }\n    \n    @grabbable\n    @throwable\n    @networked\n    \n    // What to sync across network\n    network_sync {\n      transform: true\n      velocity: true\n      state: [\"holder\", \"color\"]\n      \n      interpolation: {\n        position: \"smooth\"\n        rotation: \"slerp\"\n      }\n      \n      authority: \"dynamic\"  // Transfers to grabber\n    }\n    \n    state {\n      holder: null\n      color: 0x4488ff\n    }\n    \n    @on_grab {\n      // Claim network authority\n      network.claim_authority(self)\n      self.state.holder = network.local_player_id\n      \n      // RPC to all clients\n      network.rpc(\"on_grabbed\", { player: network.local_player_id })\n    }\n    \n    @on_release {\n      self.state.holder = null\n      network.rpc(\"on_released\", {})\n    }\n    \n    // RPC handlers\n    @rpc on_grabbed(data) {\n      ui.toast(data.player + \" grabbed the cube\")\n    }\n    \n    @rpc on_released(data) {\n      // Physics authority returns to server\n      network.release_authority(self)\n    }\n  }\n}\n\n// Networked player avatar\nprefab PlayerAvatar {\n  object avatar {\n    model: \"assets/avatars/default.glb\"\n    \n    @networked\n    \n    network_sync {\n      // Sync head and hands for VR\n      bones: [\"head\", \"hand_l\", \"hand_r\"]\n      transform: true\n      \n      // Only owner can control\n      authority: \"owner\"\n      \n      // High frequency for smooth VR\n      update_rate: 30\n      interpolation: {\n        position: \"smooth\"\n        rotation: \"slerp\"\n      }\n    }\n    \n    state {\n      displayName: \"\"\n      isReady: false\n    }\n    \n    // Voice chat indicator\n    object voice_indicator {\n      mesh: \"sphere\"\n      scale: 0.1\n      position: [0, 0.3, 0]  // Above head\n      visible: false\n      \n      trait Material {\n        color: 0x00ff00\n        emissive: 0x00ff00\n      }\n    }\n    \n    @on_voice_start {\n      self.voice_indicator.visible = true\n    }\n    \n    @on_voice_end {\n      self.voice_indicator.visible = false\n    }\n    \n    // Emotes (synced via RPC)\n    action emote(emoteName) {\n      network.rpc(\"play_emote\", { emote: emoteName })\n    }\n    \n    @rpc play_emote(data) {\n      anim.play(\"emote_\" + data.emote)\n      audio.play_spatial(\"emote_\" + data.emote, self.position)\n    }\n  }\n}\n\n// Networked game state manager\nobject GameStateManager {\n  @networked\n  \n  network_sync {\n    authority: \"server\"\n    state: [\"gamePhase\", \"scores\", \"timeRemaining\"]\n  }\n  \n  state {\n    gamePhase: \"lobby\"\n    scores: {}\n    timeRemaining: 0\n    maxPlayers: 8\n  }\n  \n  @on_player_join(player) {\n    if (network.is_server) {\n      self.state.scores[player.id] = 0\n      network.rpc(\"announce_join\", { name: player.name })\n    }\n  }\n  \n  @on_player_leave(player) {\n    if (network.is_server) {\n      delete self.state.scores[player.id]\n      network.rpc(\"announce_leave\", { name: player.name })\n    }\n  }\n  \n  @rpc announce_join(data) {\n    ui.toast(data.name + \" joined the game\")\n  }\n  \n  @rpc announce_leave(data) {\n    ui.toast(data.name + \" left the game\")\n  }\n  \n  // Server-only functions\n  action start_game() {\n    if (!network.is_server) return\n    \n    self.state.gamePhase = \"playing\"\n    self.state.timeRemaining = 300  // 5 minutes\n    \n    network.rpc(\"game_started\", {})\n  }\n  \n  @rpc game_started(data) {\n    ui.show_countdown(3)\n    audio.play(\"game_start\")\n  }\n}\n```"}
