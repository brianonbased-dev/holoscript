{"prompt": "Why isn't my NPC attacking the player?", "completion": "There are several common reasons an NPC might not attack. Let's troubleshoot:\n\n**1. Check Behavior Trigger Condition**\n```\n// Make sure condition is correct\nbehaviors: [{\n  name: \"attack\",\n  trigger: \"player_near\",\n  condition: player.distance < 5,  // Is this range correct?\n  actions: [...]\n}]\n```\n**Issue:** Player might not be close enough. Try increasing the distance.\n\n**2. Verify NPC Type**\n```\nnpc(\"Enemy\", {\n  type: \"enemy\",  // Must be \"enemy\" not \"friendly\" or \"neutral\"\n  ...\n})\n```\n**Issue:** Friendly NPCs won't attack by default.\n\n**3. Check Behavior Priority**\n```\nbehaviors: [\n  { name: \"idle\", trigger: \"idle\", priority: 1, ... },\n  { name: \"attack\", trigger: \"player_near\", priority: 2, ... }  // Higher priority\n]\n```\n**Issue:** Lower priority behaviors may be blocking attack.\n\n**4. Check Cooldown**\n```\n{\n  name: \"attack\",\n  actions: [{ damage: { target: player, amount: 10 } }],\n  cooldown: 1.5  // Attack every 1.5 seconds\n}\n```\n**Issue:** Very long cooldown prevents attacks.\n\n**5. Verify Damage Action Syntax**\n```\n// Correct\nactions: [\n  { damage: { target: player, amount: 15 } }\n]\n\n// Wrong - missing target\nactions: [\n  { damage: 15 }  // Won't work!\n]\n```\n\n**6. Check if NPC is Alive**\n```\ncondition: this.health > 0 && player.distance < 5\n```\n**Issue:** Dead NPCs can't attack.\n\n**7. Check State Machine Conflicts**\nIf using `stateMachine()`, ensure the combat state is being entered:\n```\nstateMachine(\"npc_ai\", {\n  states: {\n    \"combat\": {\n      entry: () => console.log(\"Entered combat\"),  // Debug log\n      ...\n    }\n  }\n})\n```\n\n**Quick Debug Test:**\nAdd this to verify behavior is triggering:\n```\nactions: [\n  { log: \"Attack behavior triggered!\" },\n  { sound: \"attack_sound\" },  // Audio confirmation\n  { damage: { target: player, amount: 15 } }\n]\n```"}
{"prompt": "My quest won't complete even though I did all objectives", "completion": "Let's troubleshoot why your quest isn't completing:\n\n**1. Check All Objectives Have Proper IDs**\n```\nobjectives: [\n  { id: \"obj_1\", ... },  // Each needs unique id\n  { id: \"obj_2\", ... },\n  { id: \"obj_3\", ... }   // No duplicates!\n]\n```\n\n**2. Verify Objective Types Match Actions**\n```\n// For item collection:\n{ type: \"collect\", target: \"item_id\", count: 3 }\n// Make sure player is picking up items with matching id\n\n// For NPC kills:\n{ type: \"defeat\", target: \"enemy_type\", count: 5 }\n// Make sure killed NPCs have matching type\n\n// For location discovery:\n{ type: \"discover\", target: location(\"location_id\") }\n// Make sure location trigger exists in scene\n```\n\n**3. Check Target Names Match Exactly**\n```\n// Quest objective\n{ type: \"defeat\", target: \"goblin\" }\n\n// NPC definition - must match!\nnpc(\"Goblin Warrior\", {\n  type: \"goblin\",  // This must match target\n  ...\n})\n```\n**Common Issue:** Case sensitivity - \"Goblin\" â‰  \"goblin\"\n\n**4. Verify Count is Reached**\n```\n{ type: \"collect\", target: \"herb\", count: 10 }\n// Player needs exactly 10 or more\n```\nCheck: `player.inventory.count(\"herb\") >= 10`\n\n**5. Check for Optional Objectives Blocking**\n```\nobjectives: [\n  { id: \"main\", type: \"defeat\", ... },\n  { id: \"bonus\", type: \"collect\", ..., optional: true }  // Mark optional!\n]\n```\n**Issue:** Non-optional objectives block completion.\n\n**6. Verify Delivery Target Exists**\n```\n{ \n  type: \"deliver\", \n  target: \"Elder Theron\",  // NPC must exist and be accessible\n  location: \"village_center\" \n}\n```\n**Issue:** Delivery NPCs must be in correct location.\n\n**7. Check Quest State**\n```\n// Is quest active?\nconsole.log(player.activeQuests.includes(\"quest_id\"));\n\n// Check objective progress\nconsole.log(player.getQuestProgress(\"quest_id\"));\n```\n\n**8. Manual Completion Test**\n```\n// Force complete to test rewards\ncompleteQuest(\"quest_id\");\n\n// Or complete specific objective\ncompleteObjective(\"quest_id\", \"objective_id\");\n```\n\n**Debug Output:**\n```\nquest(\"Test Quest\", {\n  onObjectiveComplete: (objId) => {\n    console.log(`Objective ${objId} completed!`);\n  },\n  onComplete: () => {\n    console.log(\"Quest completed!\");\n  }\n})\n```"}
{"prompt": "My dialogue options aren't showing up", "completion": "Let's troubleshoot missing dialogue options:\n\n**1. Check Option Unlocked Conditions**\n```\noptions: [\n  {\n    text: \"Tell me about the quest\",\n    action: () => startQuest(\"quest_id\"),\n    unlocked: true  // Always visible\n  },\n  {\n    text: \"I have the item\",\n    action: () => completeQuest(\"quest_id\"),\n    unlocked: player.hasItem(\"quest_item\")  // Check this condition!\n  }\n]\n```\n**Issue:** `unlocked` condition evaluating to false.\n\n**Debug:** Add console log:\n```\nunlocked: (() => {\n  console.log(\"Has item:\", player.hasItem(\"quest_item\"));\n  return player.hasItem(\"quest_item\");\n})()\n```\n\n**2. Check Dialogue Condition**\n```\ndialogue(\"npc_greeting\", {\n  condition: player.level >= 10,  // Dialogue itself has condition!\n  ...\n})\n```\n**Issue:** Entire dialogue blocked by condition.\n\n**3. Verify Options Array Exists**\n```\n// Wrong - no options array\ndialogue(\"greeting\", {\n  content: \"Hello!\"\n})\n\n// Correct\ndialogue(\"greeting\", {\n  content: \"Hello!\",\n  options: [\n    { text: \"Hi!\", action: () => closeDialogue() }\n  ]\n})\n```\n\n**4. Check for JavaScript Errors**\n```\n// This will break all options:\noptions: [\n  {\n    text: \"Option 1\",\n    unlocked: player.nonExistentMethod()  // Error!\n  }\n]\n```\n**Fix:** Wrap in try-catch or check method exists.\n\n**5. Check Player State References**\n```\n// Wrong - 'player' might not be defined\nunlocked: player.hasQuest(\"quest\")\n\n// Safer\nunlocked: typeof player !== 'undefined' && player.hasQuest(\"quest\")\n```\n\n**6. Verify Dialogue ID Matches**\n```\n// NPC references\nnpc(\"Merchant\", {\n  dialogue: \"merchant_greeting\"  // Must match!\n})\n\n// Dialogue definition\ndialogue(\"merchant_greeting\", {  // This ID\n  ...\n})\n```\n\n**7. Check for Syntax Errors in Options**\n```\n// Wrong - missing comma\noptions: [\n  { text: \"A\", action: () => {} }  // Missing comma!\n  { text: \"B\", action: () => {} }\n]\n\n// Correct\noptions: [\n  { text: \"A\", action: () => {} },\n  { text: \"B\", action: () => {} }\n]\n```\n\n**8. Test with Simple Options**\n```\noptions: [\n  {\n    text: \"TEST - Always visible\",\n    action: () => console.log(\"clicked\"),\n    unlocked: true\n  }\n]\n```\nIf this works, issue is in your conditions."}
{"prompt": "My ability isn't dealing damage", "completion": "Let's troubleshoot why your ability isn't dealing damage:\n\n**1. Check Damage Object Structure**\n```\n// Correct structure\neffects: {\n  damage: {\n    type: \"fire\",\n    amount: 50,  // Or use baseDamage in scaling\n    target: player  // Or enemy\n  }\n}\n\n// Or in scaling\nscaling: {\n  baseDamage: 30,\n  spellPower: 0.8\n}\n```\n\n**2. Verify Target Exists**\n```\n// Wrong - undefined target\nprojectile: {\n  onHit: (target) => {\n    damage(target, 50);  // target might be undefined\n  }\n}\n\n// Correct - check target\nonHit: (target) => {\n  if (target && target.health) {\n    damage(target, 50);\n  }\n}\n```\n\n**3. Check Projectile Hit Detection**\n```\nprojectile: {\n  geometry: { type: \"sphere\", radius: 0.3 },  // Collision size\n  speed: 25,\n  lifetime: 10,  // Doesn't expire too fast?\n  \n  // Add hit callback\n  onHit: (target) => {\n    console.log(\"Hit:\", target);  // Debug\n    damageTarget(target, 50);\n  }\n}\n```\n**Issue:** Projectile too small or too fast to detect collisions.\n\n**4. Verify Cast Time Completes**\n```\nstats: {\n  castTime: 1.5  // Must complete cast!\n}\n```\n**Issue:** If interrupted, ability won't fire.\n\n**5. Check Mana/Resource Cost**\n```\nstats: {\n  manaCost: 50  // Do you have enough mana?\n}\n```\n**Debug:** `console.log(\"Mana:\", player.mana)`\n\n**6. Verify Ability is Unlocked**\n```\n// Check if player can use ability\nif (player.abilities.includes(\"fireball\")) {\n  useAbility(\"fireball\");\n}\n```\n\n**7. Check Damage Type Immunity**\n```\n// Enemy might be immune\nnpc(\"FireElemental\", {\n  immunities: [\"fire\"],  // Takes no fire damage!\n  ...\n})\n```\n\n**8. Verify Range**\n```\nstats: {\n  range: 20  // Target must be within range\n}\n```\n**Issue:** Target too far away.\n\n**9. Check Cooldown**\n```\nstats: {\n  cooldown: 6  // Seconds between uses\n}\n```\n**Debug:** Check if ability is on cooldown.\n\n**10. Debug with Console**\n```\nability(\"DebugFireball\", {\n  ...\n  onCast: () => console.log(\"Cast started\"),\n  onHit: (target) => {\n    console.log(\"Hit target:\", target);\n    console.log(\"Dealing damage:\", this.calculateDamage());\n  },\n  onComplete: () => console.log(\"Ability complete\")\n})\n```\n\n**Quick Fix Test:**\n```\n// Simplest damage test\nability(\"TestDamage\", {\n  type: \"instant\",\n  effects: {\n    damage: { amount: 100, target: \"current_target\" }\n  }\n})\n```"}
{"prompt": "My scene isn't loading correctly", "completion": "Let's troubleshoot scene loading issues:\n\n**1. Check Scene Name/ID**\n```\nscene(\"ForestClearing\", {  // This exact name\n  ...\n})\n\n// When loading\nloadScene(\"ForestClearing\");  // Must match exactly!\n```\n**Issue:** Case sensitivity matters.\n\n**2. Verify Required Properties**\n```\nscene(\"MyScene\", {\n  environment: {  // Required\n    lighting: { ... },  // Required\n    terrain: { ... }    // Recommended\n  },\n  objects: [],  // Can be empty but should exist\n  audio: { ... }  // Optional\n})\n```\n\n**3. Check Lighting Configuration**\n```\nlighting: {\n  ambient: {\n    color: \"#ffffff\",\n    intensity: 0.5  // 0 = pitch black!\n  },\n  directional: {\n    direction: { x: 1, y: 2, z: 1 },\n    intensity: 0.8\n  }\n}\n```\n**Issue:** Scene appears black if no lighting defined.\n\n**4. Verify Object Positions**\n```\nobjects: [\n  {\n    type: \"npc\",\n    id: \"guard\",\n    position: { x: 0, y: 0, z: 5 },  // y=0 is ground level\n    ...\n  }\n]\n```\n**Issue:** Objects at wrong Y position may be underground or floating.\n\n**5. Check Terrain Definition**\n```\nterrain: {\n  type: \"grassland\",\n  texture: \"grass_texture\",  // Asset must exist!\n  geometry: {\n    width: 100,\n    height: 100,\n    segments: 32\n  }\n}\n```\n**Issue:** Missing texture makes terrain invisible.\n\n**6. Verify Asset References**\n```\nobjects: [\n  {\n    model: \"human_warrior\",  // This asset must exist!\n    ...\n  }\n]\n```\n**Debug:** Check console for \"Asset not found\" errors.\n\n**7. Check Skybox**\n```\nenvironment: {\n  skybox: \"forest_sky\"  // Asset must exist\n}\n```\n**Issue:** Missing skybox = gray/black background.\n\n**8. Verify Spawn Point**\n```\nobjects: [\n  {\n    type: \"spawn_point\",\n    id: \"player_spawn\",\n    position: { x: 0, y: 0, z: 0 }  // Where player appears\n  }\n]\n```\n**Issue:** No spawn point = player at 0,0,0 or doesn't load.\n\n**9. Check for Circular Dependencies**\n```\n// Scene A loads Scene B\n// Scene B loads Scene A\n// = Infinite loop!\n```\n\n**10. Memory/Performance Issues**\n```\nobjects: [\n  // Too many high-poly objects\n  { model: \"detailed_tree\" },  // x1000 = crash\n]\n```\n\n**Debug Scene Loading:**\n```\nloadScene(\"MyScene\", {\n  onStart: () => console.log(\"Loading started\"),\n  onProgress: (p) => console.log(\"Progress:\", p),\n  onComplete: () => console.log(\"Scene loaded!\"),\n  onError: (e) => console.error(\"Load error:\", e)\n});\n```\n\n**Minimal Test Scene:**\n```\nscene(\"TestScene\", {\n  environment: {\n    lighting: {\n      ambient: { color: \"#ffffff\", intensity: 0.8 }\n    },\n    skybox: \"default_sky\"\n  },\n  objects: []\n})\n```\nIf this loads, add objects one by one to find the problem."}
{"prompt": "My state machine isn't transitioning between states", "completion": "Let's troubleshoot state machine transition issues:\n\n**1. Check Transition Call**\n```\n// Correct\nonDamage: (amount) => {\n  if (this.health < 50) {\n    transition(\"phase2\");  // Must call transition()\n  }\n}\n\n// Wrong - just setting a variable\nonDamage: (amount) => {\n  if (this.health < 50) {\n    this.state = \"phase2\";  // Won't work!\n  }\n}\n```\n\n**2. Verify State Names Match**\n```\nstates: {\n  \"phase1\": { ... },\n  \"phase2\": { ... }  // Must match exactly\n}\n\n// Transition call\ntransition(\"phase2\");  // Case-sensitive!\ntransition(\"Phase2\");  // Won't find it!\n```\n\n**3. Check Initial State**\n```\nstateMachine(\"boss_ai\", {\n  states: { ... },\n  initialState: \"phase1\"  // Must specify starting state!\n})\n```\n**Issue:** No initial state = machine never starts.\n\n**4. Verify Condition Logic**\n```\n// Check your condition\nonDamage: (amount) => {\n  console.log(\"Health:\", this.health);  // Debug\n  console.log(\"Should transition:\", this.health < 60);\n  \n  if (this.health < 60) {\n    transition(\"phase2\");\n  }\n}\n```\n**Issue:** Condition may never be true.\n\n**5. Check for Competing Transitions**\n```\nonDamage: (amount) => {\n  if (this.health < 60) transition(\"phase2\");\n  if (this.health < 30) transition(\"phase3\");  // Both may trigger!\n}\n\n// Better\nonDamage: (amount) => {\n  if (this.health < 30) {\n    transition(\"phase3\");\n  } else if (this.health < 60) {\n    transition(\"phase2\");\n  }\n}\n```\n\n**6. Verify Event Triggers**\n```\n// onDamage only fires when damage is taken\nonDamage: (amount) => { ... }\n\n// onSensory only fires on sensory events\nonSensory: (event) => { ... }\n\n// onTimeout only fires when timeout expires\ntimeout: 5,\nonTimeout: () => { ... }\n```\n\n**7. Check Timeout Configuration**\n```\n\"alert\": {\n  timeout: 5,  // Required for onTimeout!\n  onTimeout: () => transition(\"patrol\")\n}\n```\n**Issue:** onTimeout without timeout value never fires.\n\n**8. Debug State Changes**\n```\n\"phase1\": {\n  entry: () => {\n    console.log(\"ENTERED: phase1\");\n  },\n  exit: () => {\n    console.log(\"EXITED: phase1\");\n  }\n},\n\"phase2\": {\n  entry: () => {\n    console.log(\"ENTERED: phase2\");\n  }\n}\n```\n\n**9. Check for State Machine Assignment**\n```\nnpc(\"Boss\", {\n  stateMachine: \"boss_ai\",  // Must reference the state machine!\n  ...\n})\n```\n\n**10. Verify State Machine is Running**\n```\n// Start the state machine\nthis.stateMachine.start();\n\n// Or in NPC definition\nautoStartAI: true\n```\n\n**Minimal Test:**\n```\nstateMachine(\"test_ai\", {\n  states: {\n    \"state_a\": {\n      entry: () => console.log(\"In A\"),\n      timeout: 3,\n      onTimeout: () => transition(\"state_b\")\n    },\n    \"state_b\": {\n      entry: () => console.log(\"In B - Transition worked!\")\n    }\n  },\n  initialState: \"state_a\"\n})\n```\nIf this works, your issue is in conditions."}
