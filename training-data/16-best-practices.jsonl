{"prompt": "What's the best practice for optimizing HoloScript performance?", "completion": "Here are the best practices for HoloScript performance optimization:\n\n**1. Object Pooling**\nDon't create/destroy objects frequently. Use pools:\n```\nobjectPool(\"bullets\", {\n  prefab: \"bullet\",\n  initialSize: 50,\n  maxSize: 100,\n  autoExpand: true\n})\n\n// Get from pool instead of creating\nconst bullet = pool.get(\"bullets\");\nbullet.activate(position, direction);\n\n// Return to pool instead of destroying\nbullet.deactivate();\npool.return(\"bullets\", bullet);\n```\n\n**2. LOD (Level of Detail)**\nReduce detail for distant objects:\n```\nnpc(\"Villager\", {\n  lod: [\n    { distance: 0, model: \"villager_high\" },\n    { distance: 20, model: \"villager_medium\" },\n    { distance: 50, model: \"villager_low\" },\n    { distance: 100, model: \"villager_billboard\" }\n  ]\n})\n```\n\n**3. Culling**\nDon't process invisible objects:\n```\nnpc(\"Enemy\", {\n  culling: {\n    frustum: true,      // Don't render if off-screen\n    occlusion: true,    // Don't render if behind walls\n    distance: 150       // Don't render beyond this distance\n  },\n  aiCulling: {\n    distance: 100,      // Reduce AI complexity when far\n    offscreenBehavior: \"simplified\"\n  }\n})\n```\n\n**4. Batch Similar Objects**\n```\nobjectGroup(\"forest_trees\", {\n  objects: treePositions.map(pos => ({\n    model: \"tree_pine\",\n    position: pos\n  })),\n  instanced: true,      // GPU instancing\n  staticBatching: true  // Combine meshes\n})\n```\n\n**5. Optimize Behaviors**\n```\n// Bad - runs every frame\nbehaviors: [{\n  trigger: \"always\",\n  actions: [{ checkDistanceToPlayer: true }]\n}]\n\n// Good - runs periodically\nbehaviors: [{\n  trigger: \"interval\",\n  interval: 0.5,  // Every 500ms instead of every frame\n  actions: [{ checkDistanceToPlayer: true }]\n}]\n```\n\n**6. Use Events Instead of Polling**\n```\n// Bad - checking every frame\nupdate: () => {\n  if (player.health < 50) { ... }\n}\n\n// Good - react to events\nonEvent(\"player_damaged\", () => {\n  if (player.health < 50) { ... }\n})\n```\n\n**7. Preload Assets**\n```\nscene(\"DungeonBoss\", {\n  preload: [\"boss_model\", \"boss_abilities\", \"boss_sounds\"],\n  ...\n})\n```\n\n**8. Limit Particle Systems**\n```\nparticle(\"magic_effect\", {\n  maxParticles: 100,      // Cap particle count\n  autoDestroy: true,\n  lifetime: 2,\n  quality: \"adaptive\"     // Reduce on low-end devices\n})\n```\n\n**9. Optimize Collision Detection**\n```\nnpc(\"Enemy\", {\n  collision: {\n    type: \"sphere\",      // Faster than mesh\n    layers: [\"player\", \"projectile\"],  // Limit what to check\n    static: false\n  }\n})\n```\n\n**10. Use Spatial Partitioning**\n```\nscene(\"LargeWorld\", {\n  spatialHash: {\n    cellSize: 50,\n    updateFrequency: 0.2\n  }\n})\n```"}
{"prompt": "How should I organize a large HoloScript project?", "completion": "Here's the recommended structure for organizing large HoloScript projects:\n\n**1. Directory Structure**\n```\nmygame/\n├── main.hs                 # Entry point\n├── config/\n│   ├── game.config.hs     # Game settings\n│   ├── audio.config.hs    # Audio settings\n│   └── graphics.config.hs # Graphics settings\n├── scenes/\n│   ├── hub/\n│   │   ├── hub.scene.hs\n│   │   ├── hub.npcs.hs\n│   │   └── hub.objects.hs\n│   ├── dungeon/\n│   └── boss/\n├── entities/\n│   ├── npcs/\n│   │   ├── enemies/\n│   │   ├── friendlies/\n│   │   └── bosses/\n│   ├── items/\n│   └── props/\n├── systems/\n│   ├── combat.system.hs\n│   ├── quest.system.hs\n│   ├── dialogue.system.hs\n│   └── inventory.system.hs\n├── data/\n│   ├── abilities.data.hs\n│   ├── items.data.hs\n│   ├── quests.data.hs\n│   └── dialogues.data.hs\n├── ui/\n│   ├── hud.hs\n│   ├── menus.hs\n│   └── dialogueBox.hs\n├── localization/\n│   ├── en.lang.hs\n│   ├── es.lang.hs\n│   └── fr.lang.hs\n└── utils/\n    ├── helpers.hs\n    └── constants.hs\n```\n\n**2. Module Pattern**\n```\n// systems/combat.system.hs\nmodule(\"combat\", {\n  exports: [\n    \"calculateDamage\",\n    \"applyDamage\",\n    \"checkHit\"\n  ],\n  \n  functions: {\n    calculateDamage: (attacker, defender, skill) => {\n      // Implementation\n    },\n    applyDamage: (target, damage) => {\n      // Implementation\n    },\n    checkHit: (attacker, defender) => {\n      // Implementation\n    }\n  }\n})\n\n// Using the module\nimport { calculateDamage } from \"./systems/combat.system\"\n```\n\n**3. Entity Templates**\n```\n// entities/npcs/enemies/base_enemy.template.hs\ntemplate(\"base_enemy\", {\n  type: \"enemy\",\n  health: 100,\n  behaviors: [\n    { name: \"patrol\", trigger: \"idle\", ... },\n    { name: \"chase\", trigger: \"player_spotted\", ... },\n    { name: \"attack\", trigger: \"player_near\", ... }\n  ]\n})\n\n// entities/npcs/enemies/goblin.hs\nnpc(\"Goblin\", {\n  extends: \"base_enemy\",\n  health: 50,\n  model: \"goblin_warrior\"\n  // Inherits behaviors from template\n})\n```\n\n**4. Configuration Files**\n```\n// config/game.config.hs\nconfig(\"game\", {\n  version: \"1.0.0\",\n  difficulty: {\n    easy: { damageMultiplier: 0.75 },\n    normal: { damageMultiplier: 1.0 },\n    hard: { damageMultiplier: 1.5 }\n  },\n  features: {\n    pvp: false,\n    permadeath: false\n  }\n})\n```\n\n**5. Data-Driven Design**\n```\n// data/abilities.data.hs\ndata(\"abilities\", [\n  {\n    id: \"fireball\",\n    name: \"Fireball\",\n    damage: 50,\n    manaCost: 30,\n    cooldown: 5\n  },\n  // ... more abilities\n])\n\n// Load dynamically\nconst abilities = loadData(\"abilities\");\n```\n\n**6. Scene Composition**\n```\n// scenes/dungeon/dungeon.scene.hs\nscene(\"Dungeon\", {\n  includes: [\n    \"./dungeon.environment.hs\",\n    \"./dungeon.enemies.hs\",\n    \"./dungeon.loot.hs\",\n    \"./dungeon.traps.hs\"\n  ],\n  \n  onLoad: () => {\n    // Scene-specific initialization\n  }\n})\n```\n\n**7. Naming Conventions**\n- Files: `kebab-case.type.hs` (e.g., `fire-mage.npc.hs`)\n- NPCs: PascalCase (e.g., `\"Merchant Marcus\"`)\n- Functions: camelCase (e.g., `calculateDamage`)\n- Constants: SCREAMING_SNAKE_CASE (e.g., `MAX_HEALTH`)\n- IDs: snake_case (e.g., `quest_save_village`)"}
{"prompt": "How do I make my HoloScript code more reusable?", "completion": "Here are strategies for making HoloScript code reusable:\n\n**1. Use Templates/Base Classes**\n```\n// Define a base template\ntemplate(\"base_humanoid_enemy\", {\n  type: \"enemy\",\n  geometry: { type: \"humanoid\", height: 1.8 },\n  behaviors: [\n    { name: \"idle\", trigger: \"idle\", actions: [{ animate: \"idle\" }] },\n    { name: \"patrol\", trigger: \"no_target\", actions: [...] },\n    { name: \"chase\", trigger: \"target_spotted\", actions: [...] },\n    { name: \"attack\", trigger: \"target_in_range\", actions: [...] }\n  ]\n})\n\n// Extend for specific enemies\nnpc(\"Goblin Warrior\", {\n  extends: \"base_humanoid_enemy\",\n  model: \"goblin_warrior\",\n  health: 50,\n  damage: 10\n})\n\nnpc(\"Orc Berserker\", {\n  extends: \"base_humanoid_enemy\",\n  model: \"orc_berserker\",\n  health: 150,\n  damage: 25\n})\n```\n\n**2. Factory Functions**\n```\n// Create enemies dynamically\nfunction createEnemy(type, level, position) {\n  const baseStats = enemyData[type];\n  const scaledStats = {\n    health: baseStats.health * (1 + level * 0.1),\n    damage: baseStats.damage * (1 + level * 0.05)\n  };\n  \n  return npc(`${type}_${generateId()}`, {\n    extends: baseStats.template,\n    position: position,\n    level: level,\n    ...scaledStats\n  });\n}\n\n// Usage\ncreateEnemy(\"goblin\", 5, { x: 10, y: 0, z: 20 });\ncreateEnemy(\"orc\", 8, { x: 15, y: 0, z: 25 });\n```\n\n**3. Composable Behaviors**\n```\n// Define behavior modules\nconst PatrolBehavior = {\n  name: \"patrol\",\n  trigger: \"no_target\",\n  actions: [\n    { move: { path: \"patrol_path\", speed: 2 } },\n    { wait: 2 },\n    { animate: \"look_around\" }\n  ]\n};\n\nconst AggroBehavior = {\n  name: \"aggro\",\n  trigger: \"player_spotted\",\n  condition: player.distance < 15,\n  actions: [\n    { setTarget: player },\n    { animate: \"alert\" },\n    { sound: \"enemy_alert\" }\n  ]\n};\n\n// Compose behaviors\nnpc(\"Guard\", {\n  behaviors: [PatrolBehavior, AggroBehavior, AttackBehavior]\n})\n```\n\n**4. Mixins for Shared Functionality**\n```\nconst HasInventory = {\n  inventory: [],\n  addItem: (item) => this.inventory.push(item),\n  removeItem: (item) => this.inventory = this.inventory.filter(i => i !== item),\n  hasItem: (itemId) => this.inventory.some(i => i.id === itemId)\n};\n\nconst HasDialogue = {\n  canTalk: true,\n  dialogue: null,\n  startDialogue: () => openDialogue(this.dialogue)\n};\n\nnpc(\"Merchant\", {\n  ...HasInventory,\n  ...HasDialogue,\n  type: \"merchant\",\n  dialogue: \"merchant_greeting\"\n})\n```\n\n**5. Data-Driven Definitions**\n```\n// abilities.json\n[\n  { \"id\": \"fireball\", \"type\": \"projectile\", \"element\": \"fire\", \"baseDamage\": 50 },\n  { \"id\": \"ice_spike\", \"type\": \"projectile\", \"element\": \"ice\", \"baseDamage\": 40 }\n]\n\n// Generate abilities from data\nabilities.forEach(data => {\n  ability(data.id, {\n    type: data.type,\n    effects: {\n      damage: {\n        type: data.element,\n        amount: data.baseDamage\n      }\n    }\n  });\n});\n```\n\n**6. Higher-Order Functions**\n```\n// Create behavior generator\nfunction createTimedBehavior(name, interval, actions) {\n  return {\n    name: name,\n    trigger: \"interval\",\n    interval: interval,\n    actions: actions\n  };\n}\n\n// Usage\nnpc(\"Beacon\", {\n  behaviors: [\n    createTimedBehavior(\"pulse\", 5, [\n      { particle: \"light_pulse\" },\n      { sound: \"beacon_pulse\" }\n    ])\n  ]\n})\n```\n\n**7. Event Systems**\n```\n// Decoupled event handling\nconst gameEvents = createEventSystem();\n\n// Any NPC can listen\ngameEvents.on(\"player_level_up\", (data) => {\n  // React to player leveling\n});\n\n// Anywhere in code can emit\ngameEvents.emit(\"player_level_up\", { newLevel: 10 });\n```"}
{"prompt": "What are common HoloScript anti-patterns to avoid?", "completion": "Here are common HoloScript anti-patterns and how to fix them:\n\n**1. ❌ Hardcoded Values**\n```\n// Bad\nnpc(\"Enemy\", {\n  health: 100,\n  damage: 15,\n  attackRange: 5\n})\n\n// Good - Use constants or config\nconst ENEMY_STATS = {\n  health: 100,\n  damage: 15,\n  attackRange: 5\n};\n\nnpc(\"Enemy\", { ...ENEMY_STATS })\n```\n\n**2. ❌ Deeply Nested Conditions**\n```\n// Bad\nif (player.hasQuest(\"q1\")) {\n  if (player.level >= 10) {\n    if (player.reputation >= 50) {\n      if (player.hasItem(\"key\")) {\n        // Do something\n      }\n    }\n  }\n}\n\n// Good - Early returns or combined conditions\nconst canProceed = player.hasQuest(\"q1\") \n  && player.level >= 10 \n  && player.reputation >= 50 \n  && player.hasItem(\"key\");\n\nif (canProceed) {\n  // Do something\n}\n```\n\n**3. ❌ Copy-Paste Code**\n```\n// Bad - Repeated code\nnpc(\"Goblin1\", { health: 50, model: \"goblin\", behaviors: [...] })\nnpc(\"Goblin2\", { health: 50, model: \"goblin\", behaviors: [...] })\nnpc(\"Goblin3\", { health: 50, model: \"goblin\", behaviors: [...] })\n\n// Good - Use templates or loops\nconst goblinPositions = [[0,0,0], [5,0,0], [10,0,0]];\ngoblinPositions.forEach((pos, i) => {\n  npc(`Goblin${i}`, {\n    extends: \"goblin_template\",\n    position: { x: pos[0], y: pos[1], z: pos[2] }\n  });\n});\n```\n\n**4. ❌ God Objects**\n```\n// Bad - One NPC does everything\nnpc(\"GameManager\", {\n  // Quest logic\n  // Combat logic\n  // Inventory logic\n  // Weather logic\n  // Save/Load logic\n  // 500 lines of code...\n})\n\n// Good - Separate systems\nmodule(\"quest_system\", { ... })\nmodule(\"combat_system\", { ... })\nmodule(\"inventory_system\", { ... })\n```\n\n**5. ❌ Polling Instead of Events**\n```\n// Bad - Checking every frame\nupdate: () => {\n  if (player.health < 20) {\n    showLowHealthWarning();\n  }\n}\n\n// Good - Event-driven\nonEvent(\"player_damaged\", () => {\n  if (player.health < 20) {\n    showLowHealthWarning();\n  }\n})\n```\n\n**6. ❌ Magic Numbers**\n```\n// Bad - What does 5 mean? 0.8? 1000?\nif (player.distance < 5) {\n  damage(player, player.health * 0.8);\n  giveXP(1000);\n}\n\n// Good - Named constants\nconst ATTACK_RANGE = 5;\nconst DAMAGE_PERCENT = 0.8;\nconst BOSS_XP_REWARD = 1000;\n\nif (player.distance < ATTACK_RANGE) {\n  damage(player, player.health * DAMAGE_PERCENT);\n  giveXP(BOSS_XP_REWARD);\n}\n```\n\n**7. ❌ String-Typed Actions**\n```\n// Bad - Error-prone strings\nsetState(\"combta\");  // Typo won't be caught!\n\n// Good - Use enums/constants\nconst States = {\n  IDLE: \"idle\",\n  COMBAT: \"combat\",\n  FLEE: \"flee\"\n};\n\nsetState(States.COMBAT);  // Typo = error\n```\n\n**8. ❌ Ignoring Edge Cases**\n```\n// Bad - No null checks\nfunction attackTarget(target) {\n  damage(target, 50);\n}\n\n// Good - Handle edge cases\nfunction attackTarget(target) {\n  if (!target || target.health <= 0) return;\n  if (!this.canAttack()) return;\n  \n  damage(target, 50);\n}\n```\n\n**9. ❌ Tight Coupling**\n```\n// Bad - NPC directly references specific quest\nnpc(\"Guard\", {\n  onInteract: () => {\n    if (quest_save_village.isComplete) {  // Tight coupling!\n      openDoor(\"castle_gate\");\n    }\n  }\n})\n\n// Good - Use flags or events\nnpc(\"Guard\", {\n  onInteract: () => {\n    if (player.hasFlag(\"village_saved\")) {\n      openDoor(\"castle_gate\");\n    }\n  }\n})\n```\n\n**10. ❌ Massive Behavior Arrays**\n```\n// Bad - Unreadable behavior list\nbehaviors: [/* 50 behaviors inline */]\n\n// Good - Organize and compose\nconst IdleBehaviors = [...];\nconst CombatBehaviors = [...];\nconst DialogueBehaviors = [...];\n\nbehaviors: [...IdleBehaviors, ...CombatBehaviors, ...DialogueBehaviors]\n```"}
{"prompt": "How do I handle errors and edge cases in HoloScript?", "completion": "Here's how to properly handle errors and edge cases in HoloScript:\n\n**1. Null/Undefined Checks**\n```\n// Always verify targets exist\nonHit: (target) => {\n  if (!target) {\n    console.warn(\"No target hit\");\n    return;\n  }\n  \n  if (!target.health) {\n    console.warn(\"Target has no health property\");\n    return;\n  }\n  \n  damage(target, 50);\n}\n\n// Optional chaining\nconst health = target?.health ?? 0;\nconst name = target?.name ?? \"Unknown\";\n```\n\n**2. Validation Functions**\n```\nfunction validateNPCConfig(config) {\n  const errors = [];\n  \n  if (!config.model) errors.push(\"Missing model\");\n  if (!config.health || config.health <= 0) errors.push(\"Invalid health\");\n  if (!config.behaviors?.length) errors.push(\"No behaviors defined\");\n  \n  if (errors.length > 0) {\n    console.error(\"Invalid NPC config:\", errors);\n    return false;\n  }\n  \n  return true;\n}\n\n// Use before creating NPCs\nif (validateNPCConfig(config)) {\n  npc(\"Enemy\", config);\n}\n```\n\n**3. Try-Catch for Risky Operations**\n```\nfunction loadQuest(questId) {\n  try {\n    const questData = loadQuestData(questId);\n    return quest(questData.name, questData);\n  } catch (error) {\n    console.error(`Failed to load quest ${questId}:`, error);\n    return null;\n  }\n}\n```\n\n**4. Default Values**\n```\nnpc(\"Enemy\", {\n  health: config.health ?? 100,          // Default if undefined\n  damage: config.damage || 10,           // Default if falsy\n  model: config.model ?? \"default_enemy\",\n  behaviors: config.behaviors ?? [DefaultIdleBehavior]\n})\n```\n\n**5. State Validation**\n```\nstateMachine(\"safe_ai\", {\n  states: {\n    \"patrol\": {\n      onEnter: () => {\n        // Validate before acting\n        if (!this.patrolPath || this.patrolPath.length < 2) {\n          console.warn(\"Invalid patrol path, staying idle\");\n          transition(\"idle\");\n          return;\n        }\n        this.startPatrol();\n      }\n    }\n  }\n})\n```\n\n**6. Boundary Checks**\n```\nability(\"Fireball\", {\n  onCast: (target) => {\n    // Range check\n    const distance = getDistance(caster.position, target.position);\n    if (distance > this.stats.range) {\n      showMessage(\"Target out of range!\");\n      return { success: false, reason: \"out_of_range\" };\n    }\n    \n    // Line of sight check\n    if (!hasLineOfSight(caster, target)) {\n      showMessage(\"No line of sight!\");\n      return { success: false, reason: \"no_los\" };\n    }\n    \n    // Resource check\n    if (caster.mana < this.stats.manaCost) {\n      showMessage(\"Not enough mana!\");\n      return { success: false, reason: \"no_mana\" };\n    }\n    \n    // All checks passed\n    this.execute(target);\n    return { success: true };\n  }\n})\n```\n\n**7. Graceful Degradation**\n```\nscene(\"Forest\", {\n  onLoad: async () => {\n    // Try to load high-quality assets\n    try {\n      await loadAsset(\"forest_hd\");\n    } catch (error) {\n      console.warn(\"HD assets failed, using standard\");\n      try {\n        await loadAsset(\"forest_standard\");\n      } catch (error) {\n        console.warn(\"Standard assets failed, using low quality\");\n        await loadAsset(\"forest_low\");\n      }\n    }\n  }\n})\n```\n\n**8. Event Error Handling**\n```\nonEvent(\"player_action\", (data) => {\n  if (!data || typeof data !== 'object') {\n    console.error(\"Invalid event data\");\n    return;\n  }\n  \n  const { action, target } = data;\n  \n  if (!action) {\n    console.error(\"Missing action in event\");\n    return;\n  }\n  \n  handleAction(action, target);\n})\n```\n\n**9. Timeout Protection**\n```\nfunction safeMoveToTarget(target, timeout = 10) {\n  let timeElapsed = 0;\n  \n  return {\n    update: (deltaTime) => {\n      timeElapsed += deltaTime;\n      \n      if (timeElapsed > timeout) {\n        console.warn(\"Movement timed out\");\n        return \"failed\";\n      }\n      \n      if (!target || target.destroyed) {\n        console.warn(\"Target no longer valid\");\n        return \"failed\";\n      }\n      \n      moveToward(target.position);\n      \n      if (reachedTarget()) return \"success\";\n      return \"running\";\n    }\n  };\n}\n```\n\n**10. Debug Mode**\n```\nconst DEBUG = true;\n\nfunction debugLog(...args) {\n  if (DEBUG) console.log(\"[DEBUG]\", ...args);\n}\n\nfunction assert(condition, message) {\n  if (DEBUG && !condition) {\n    throw new Error(`Assertion failed: ${message}`);\n  }\n}\n\n// Usage\ndebugLog(\"Player health:\", player.health);\nassert(player.level > 0, \"Player level must be positive\");\n```"}
