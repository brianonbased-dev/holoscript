system "TimeManipulation" {
  @time_engine {
    base_time_scale: 1.0
    max_rewind_buffer: 30  // seconds
    max_slow_factor: 0.01  // 1% speed
    max_fast_factor: 10.0  // 10x speed
  }
  
  // Time state recording
  @time_buffer {
    frame_rate: 60  // States recorded per second
    buffer_size: 1800  // 30 seconds * 60 fps
    
    recorded_properties: {
      entities: ["position", "rotation", "velocity", "health", "state"],
      particles: ["position", "lifetime", "color"],
      audio: ["playing", "position", "volume"],
      physics: ["forces", "contacts", "constraints"]
    }
    
    compression: {
      method: "delta_encoding",
      keyframe_interval: 60  // Full state every second
    }
  }
  
  // Time manipulation abilities
  @time_abilities {
    object "Slow Motion" {
      cost: 10  // per second
      resource: "time_energy"
      
      effects: {
        world_time_scale: 0.1,
        player_time_scale: 0.5,  // Player is faster relative to world
        audio_pitch: 0.1,
        visual: { motion_blur: true, desaturation: 0.3 }
      }
      
      @on_activate {
        time_engine.set_world_scale(effects.world_time_scale)
        time_engine.set_player_scale(effects.player_time_scale)
        post_processing.enable("time_slow")
        audio_mixer.set_pitch(effects.audio_pitch)
      }
      
      @on_deactivate {
        time_engine.restore_scales()
        post_processing.disable("time_slow")
        audio_mixer.set_pitch(1.0)
      }
    }
    
    object "Time Stop" {
      cost: 50  // instant
      duration: 5  // seconds of stopped time
      cooldown: 30
      
      effects: {
        world_time_scale: 0,
        player_time_scale: 1,
        frozen_visual: { grayscale: 0.8, frozen_particles: true }
      }
      
      logic {
        constraints: {
          player_can_move: true,
          player_can_attack: true,
          damage_is_stored: true,  // Applied when time resumes
          projectiles_frozen: true,
          new_projectiles_frozen: true
        }
      
        @on_activate {
          stored_damage = []
          time_engine.stop_world()
          freeze_all_non_player()
          post_processing.enable("time_stop")
        }
      
        @on_deactivate {
          // Apply all stored damage simultaneously
          for (damage_event of stored_damage) {
            damage_event.target.take_damage(damage_event.amount)
          }
          time_engine.resume_world()
          unfreeze_all()
        }
      }
    }
    
    object "Rewind" {
      cost: 30  // per second of rewind
      max_rewind: 10  // seconds
      
      logic {
        function "rewind" : void {
          if (seconds > time_buffer.available_seconds) {
            seconds = time_buffer.available_seconds
          }
        
          const target_frame = time_buffer.current_frame - (seconds * frame_rate)
        
          // Visual rewind object post_processing.enable("rewind")
          audio_mixer.play_reversed()
        
          // Playback recorded states in reverse
          for (frame from time_buffer.current_frame downto target_frame) {
            time_buffer.apply_state(frame)
            wait(1 / (frame_rate * 2))  // 2x speed rewind
          }
        
          post_processing.disable("rewind")
          audio_mixer.play_forward()
        
          // Clear future buffer (branching timeline)
          time_buffer.clear_after(target_frame)
        }
      }
    }
    
    object "Time Clone" {
      cost: 100
      duration: 10
      
      logic {
        function "create_time_clone" : TimeClone {
          // Record player actions for 10 seconds
          const recording = time_buffer.start_recording_player()
        
          wait(duration)
        
          recording.stop()
        
          // Rewind time
          rewind(duration)
        
          // Create clone that replays recorded actions
          const clone = spawn("TimeClone", {
            recording: recording,
            duration: duration
          })
        
          clone.start_playback()
        
          return clone
        }
      }
    }
    
    object "Temporal Anchor" {
      cost: 50
      
      state anchor_state: RecordedState | null = null
      state anchor_time: number = 0
      
      logic {
        function "set_anchor" : void {
          anchor_state = time_buffer.capture_full_state()
          anchor_time = time_engine.current_time
        
          spawn_visual("temporal_anchor", player.position)
        }
      
        function "return_to_anchor" : void {
          if (!anchor_state) return
        
          // Teleport back in space and state
          time_buffer.apply_full_state(anchor_state)
        
          visual_effect("temporal_teleport")
        
          anchor_state = null
        }
      }
    }
  }
  
  // Time zones - areas with different time flow
  @time_zones {
    object "Slow Field" {
      shape: "sphere"
      radius: 10
      
      time_scale: 0.2
      affects: ["projectiles", "enemies"]
      excludes: ["player"]
      
      visual: {
        distortion: true,
        particles: "slow_time_particles",
        tint: "#4466FF"
      }
    }
    
    object "Haste Field" {
      shape: "cylinder"
      radius: 5
      height: 10
      
      time_scale: 3.0
      affects: ["player", "allies"]
      
      visual: {
        particles: "speed_lines",
        tint: "#FFAA22"
      }
    }
    
    object "Stasis Trap" {
      shape: "box"
      size: [3, 3, 3]
      
      time_scale: 0
      affects: ["all"]
      duration: 5
      triggered_by: "enemy_enter"
      
      visual: {
        frozen_crystal: true,
        ice_particles: true
      }
    }
  }
  
  // Paradox prevention
  @paradox_prevention {
    rules: [
      {
        name: "grandfather_paradox",
        condition: "entity_prevents_own_creation",
        resolution: "create_parallel_timeline"
      }
      {
        name: "bootstrap_paradox",
        condition: "information_has_no_origin",
        resolution: "allow_with_warning"
      }
      {
        name: "predestination_paradox",
        condition: "future_causes_past",
        resolution: "closed_loop_allowed"
      }
    ]
  }
}
