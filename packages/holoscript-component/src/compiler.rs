//! Compiler module for generating output code for various targets.

use crate::exports::holoscript::core::parser::{
    CompositionNode, ObjectNode, PropertyValue, Diagnostic, DiagnosticSeverity,
    Span, Position,
};

/// Compile to Unity C#
pub fn compile_unity(ast: &CompositionNode) -> Result<String, Diagnostic> {
    let mut code = String::new();
    
    code.push_str("// Generated by HoloScript Compiler\n");
    code.push_str("using UnityEngine;\n");
    code.push_str("using System.Collections;\n\n");
    
    code.push_str(&format!("public class {} : MonoBehaviour\n{{\n", 
        sanitize_name(&ast.name)));
    
    // Generate fields for objects
    for obj in &ast.objects {
        code.push_str(&format!("    public GameObject {};\n", sanitize_name(&obj.name)));
    }
    code.push('\n');
    
    // Start method
    code.push_str("    void Start()\n    {\n");
    
    for obj in &ast.objects {
        code.push_str(&generate_unity_object(obj, "        "));
    }
    
    code.push_str("    }\n");
    code.push_str("}\n");
    
    Ok(code)
}

fn generate_unity_object(obj: &ObjectNode, indent: &str) -> String {
    let mut code = String::new();
    let var_name = sanitize_name(&obj.name);
    
    // Get geometry
    let geometry = get_property_string(&obj.properties, "geometry");
    let primitive = match geometry.as_str() {
        "cube" => "PrimitiveType.Cube",
        "sphere" => "PrimitiveType.Sphere",
        "cylinder" => "PrimitiveType.Cylinder",
        "capsule" => "PrimitiveType.Capsule",
        "plane" => "PrimitiveType.Plane",
        _ => "PrimitiveType.Cube",
    };
    
    code.push_str(&format!("{}{} = GameObject.CreatePrimitive({});\n", indent, var_name, primitive));
    code.push_str(&format!("{}{}.name = \"{}\";\n", indent, var_name, obj.name));
    
    // Position
    if let Some(pos) = get_property_array(&obj.properties, "position") {
        if pos.len() >= 3 {
            code.push_str(&format!(
                "{}{}.transform.position = new Vector3({}f, {}f, {}f);\n",
                indent, var_name, pos[0], pos[1], pos[2]
            ));
        }
    }
    
    // Rotation
    if let Some(rot) = get_property_array(&obj.properties, "rotation") {
        if rot.len() >= 3 {
            code.push_str(&format!(
                "{}{}.transform.eulerAngles = new Vector3({}f, {}f, {}f);\n",
                indent, var_name, rot[0], rot[1], rot[2]
            ));
        }
    }
    
    // Scale
    if let Some(scale) = get_property_array(&obj.properties, "scale") {
        if scale.len() >= 3 {
            code.push_str(&format!(
                "{}{}.transform.localScale = new Vector3({}f, {}f, {}f);\n",
                indent, var_name, scale[0], scale[1], scale[2]
            ));
        }
    }
    
    // Physics traits
    if obj.traits.contains(&"physics".to_string()) || obj.traits.contains(&"rigid".to_string()) {
        code.push_str(&format!("{}{}.AddComponent<Rigidbody>();\n", indent, var_name));
    }
    
    if obj.traits.contains(&"collidable".to_string()) {
        code.push_str(&format!("{}// Collider is auto-added by primitive\n", indent));
    }
    
    code.push('\n');
    code
}

/// Compile to Godot GDScript
pub fn compile_godot(ast: &CompositionNode) -> Result<String, Diagnostic> {
    let mut code = String::new();
    
    code.push_str("# Generated by HoloScript Compiler\n");
    code.push_str("extends Node3D\n\n");
    
    code.push_str("func _ready():\n");
    
    for obj in &ast.objects {
        code.push_str(&generate_godot_object(obj, "    "));
    }
    
    if ast.objects.is_empty() {
        code.push_str("    pass\n");
    }
    
    Ok(code)
}

fn generate_godot_object(obj: &ObjectNode, indent: &str) -> String {
    let mut code = String::new();
    let var_name = sanitize_name(&obj.name).to_lowercase();
    
    // Get geometry
    let geometry = get_property_string(&obj.properties, "geometry");
    let mesh_type = match geometry.as_str() {
        "cube" => "BoxMesh",
        "sphere" => "SphereMesh",
        "cylinder" => "CylinderMesh",
        "capsule" => "CapsuleMesh",
        "plane" => "PlaneMesh",
        "cone" => "PrismMesh",
        "torus" => "TorusMesh",
        _ => "BoxMesh",
    };
    
    code.push_str(&format!("{}var {} = MeshInstance3D.new()\n", indent, var_name));
    code.push_str(&format!("{}{}.mesh = {}.new()\n", indent, var_name, mesh_type));
    code.push_str(&format!("{}{}.name = \"{}\"\n", indent, var_name, obj.name));
    
    // Position
    if let Some(pos) = get_property_array(&obj.properties, "position") {
        if pos.len() >= 3 {
            code.push_str(&format!(
                "{}{}.position = Vector3({}, {}, {})\n",
                indent, var_name, pos[0], pos[1], pos[2]
            ));
        }
    }
    
    // Rotation
    if let Some(rot) = get_property_array(&obj.properties, "rotation") {
        if rot.len() >= 3 {
            code.push_str(&format!(
                "{}{}.rotation_degrees = Vector3({}, {}, {})\n",
                indent, var_name, rot[0], rot[1], rot[2]
            ));
        }
    }
    
    // Scale
    if let Some(scale) = get_property_array(&obj.properties, "scale") {
        if scale.len() >= 3 {
            code.push_str(&format!(
                "{}{}.scale = Vector3({}, {}, {})\n",
                indent, var_name, scale[0], scale[1], scale[2]
            ));
        }
    }
    
    code.push_str(&format!("{}add_child({})\n", indent, var_name));
    
    // Physics
    if obj.traits.contains(&"physics".to_string()) || obj.traits.contains(&"rigid".to_string()) {
        code.push_str(&format!("{}# TODO: Add RigidBody3D wrapper\n", indent));
    }
    
    code.push('\n');
    code
}

/// Compile to A-Frame HTML
pub fn compile_aframe(ast: &CompositionNode) -> Result<String, Diagnostic> {
    let mut code = String::new();
    
    code.push_str("<!-- Generated by HoloScript Compiler -->\n");
    code.push_str("<!DOCTYPE html>\n");
    code.push_str("<html>\n");
    code.push_str("<head>\n");
    code.push_str("  <script src=\"https://aframe.io/releases/1.4.0/aframe.min.js\"></script>\n");
    code.push_str(&format!("  <title>{}</title>\n", ast.name));
    code.push_str("</head>\n");
    code.push_str("<body>\n");
    code.push_str("  <a-scene>\n");
    
    // Environment
    if let Some(env) = &ast.environment {
        if let Some(skybox) = &env.skybox {
            code.push_str(&format!("    <a-sky color=\"{}\">\n</a-sky>\n", 
                if skybox == "gradient" { "#7EC0EE" } else { "#000000" }));
        }
    }
    
    // Objects
    for obj in &ast.objects {
        code.push_str(&generate_aframe_object(obj, "    "));
    }
    
    // Lights
    for light in &ast.lights {
        let (light_type, color, intensity) = get_light_props(&light.properties);
        code.push_str(&format!(
            "    <a-light type=\"{}\" color=\"{}\" intensity=\"{}\"></a-light>\n",
            light.light_type, color, intensity
        ));
    }
    
    // Cameras
    if ast.cameras.is_empty() {
        code.push_str("    <a-camera></a-camera>\n");
    }
    
    code.push_str("  </a-scene>\n");
    code.push_str("</body>\n");
    code.push_str("</html>\n");
    
    Ok(code)
}

fn generate_aframe_object(obj: &ObjectNode, indent: &str) -> String {
    let geometry = get_property_string(&obj.properties, "geometry");
    let primitive = match geometry.as_str() {
        "cube" => "box",
        "sphere" => "sphere",
        "cylinder" => "cylinder",
        "plane" => "plane",
        "cone" => "cone",
        "torus" => "torus",
        _ => "box",
    };
    
    let position = get_property_array(&obj.properties, "position")
        .map(|p| format!("{} {} {}", p.get(0).unwrap_or(&0.0), p.get(1).unwrap_or(&0.0), p.get(2).unwrap_or(&0.0)))
        .unwrap_or_else(|| "0 0 0".to_string());
    
    let color = get_property_string(&obj.properties, "color");
    let color_attr = if !color.is_empty() {
        format!(" color=\"{}\"", color)
    } else {
        String::new()
    };
    
    format!("{}<a-{} position=\"{}\"{}></a-{}>\n", 
        indent, primitive, position, color_attr, primitive)
}

/// Compile to Three.js JavaScript
pub fn compile_threejs(ast: &CompositionNode) -> Result<String, Diagnostic> {
    let mut code = String::new();
    
    code.push_str("// Generated by HoloScript Compiler\n");
    code.push_str("import * as THREE from 'three';\n\n");
    
    code.push_str(&format!("export function create{}Scene() {{\n", sanitize_name(&ast.name)));
    code.push_str("  const scene = new THREE.Scene();\n\n");
    
    for obj in &ast.objects {
        code.push_str(&generate_threejs_object(obj, "  "));
    }
    
    // Lights
    for light in &ast.lights {
        code.push_str(&generate_threejs_light(light, "  "));
    }
    
    code.push_str("  return scene;\n");
    code.push_str("}\n");
    
    Ok(code)
}

fn generate_threejs_object(obj: &ObjectNode, indent: &str) -> String {
    let mut code = String::new();
    let var_name = sanitize_name(&obj.name).to_lowercase();
    
    let geometry = get_property_string(&obj.properties, "geometry");
    let (geo_class, geo_args) = match geometry.as_str() {
        "cube" => ("BoxGeometry", "1, 1, 1"),
        "sphere" => ("SphereGeometry", "0.5, 32, 32"),
        "cylinder" => ("CylinderGeometry", "0.5, 0.5, 1, 32"),
        "plane" => ("PlaneGeometry", "1, 1"),
        "cone" => ("ConeGeometry", "0.5, 1, 32"),
        "torus" => ("TorusGeometry", "0.5, 0.2, 16, 100"),
        "capsule" => ("CapsuleGeometry", "0.5, 1, 4, 8"),
        _ => ("BoxGeometry", "1, 1, 1"),
    };
    
    let color = get_property_string(&obj.properties, "color");
    let color_hex = if color.starts_with('#') {
        format!("0x{}", &color[1..])
    } else {
        "0x3399ff".to_string()
    };
    
    code.push_str(&format!("{}const {}_geo = new THREE.{}({});\n", 
        indent, var_name, geo_class, geo_args));
    code.push_str(&format!("{}const {}_mat = new THREE.MeshStandardMaterial({{ color: {} }});\n", 
        indent, var_name, color_hex));
    code.push_str(&format!("{}const {} = new THREE.Mesh({}_geo, {}_mat);\n", 
        indent, var_name, var_name, var_name));
    
    // Position
    if let Some(pos) = get_property_array(&obj.properties, "position") {
        if pos.len() >= 3 {
            code.push_str(&format!("{}{}.position.set({}, {}, {});\n", 
                indent, var_name, pos[0], pos[1], pos[2]));
        }
    }
    
    code.push_str(&format!("{}scene.add({});\n\n", indent, var_name));
    code
}

fn generate_threejs_light(light: &crate::exports::holoscript::core::parser::LightNode, indent: &str) -> String {
    let (_, color, intensity) = get_light_props(&light.properties);
    let color_hex = if color.starts_with('#') {
        format!("0x{}", &color[1..])
    } else {
        "0xffffff".to_string()
    };
    
    let var_name = sanitize_name(&light.name).to_lowercase();
    
    let light_class = match light.light_type.as_str() {
        "directional" => "DirectionalLight",
        "point" => "PointLight",
        "spot" => "SpotLight",
        "ambient" => "AmbientLight",
        _ => "PointLight",
    };
    
    format!(
        "{}const {} = new THREE.{}({}, {});\n{}scene.add({});\n\n",
        indent, var_name, light_class, color_hex, intensity, indent, var_name
    )
}

/// Compile to Babylon.js JavaScript
pub fn compile_babylonjs(ast: &CompositionNode) -> Result<String, Diagnostic> {
    let mut code = String::new();
    
    code.push_str("// Generated by HoloScript Compiler\n\n");
    
    code.push_str(&format!("export function create{}Scene(engine, canvas) {{\n", 
        sanitize_name(&ast.name)));
    code.push_str("  const scene = new BABYLON.Scene(engine);\n\n");
    
    // Camera
    code.push_str("  const camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI/3, 10, BABYLON.Vector3.Zero(), scene);\n");
    code.push_str("  camera.attachControl(canvas, true);\n\n");
    
    // Light
    code.push_str("  const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);\n\n");
    
    for obj in &ast.objects {
        code.push_str(&generate_babylonjs_object(obj, "  "));
    }
    
    code.push_str("  return scene;\n");
    code.push_str("}\n");
    
    Ok(code)
}

fn generate_babylonjs_object(obj: &ObjectNode, indent: &str) -> String {
    let mut code = String::new();
    let var_name = sanitize_name(&obj.name).to_lowercase();
    
    let geometry = get_property_string(&obj.properties, "geometry");
    let mesh_create = match geometry.as_str() {
        "cube" => format!("BABYLON.MeshBuilder.CreateBox('{}', {{}}, scene)", obj.name),
        "sphere" => format!("BABYLON.MeshBuilder.CreateSphere('{}', {{ diameter: 1 }}, scene)", obj.name),
        "cylinder" => format!("BABYLON.MeshBuilder.CreateCylinder('{}', {{}}, scene)", obj.name),
        "plane" => format!("BABYLON.MeshBuilder.CreateGround('{}', {{ width: 1, height: 1 }}, scene)", obj.name),
        "cone" => format!("BABYLON.MeshBuilder.CreateCylinder('{}', {{ diameterTop: 0 }}, scene)", obj.name),
        "torus" => format!("BABYLON.MeshBuilder.CreateTorus('{}', {{}}, scene)", obj.name),
        _ => format!("BABYLON.MeshBuilder.CreateBox('{}', {{}}, scene)", obj.name),
    };
    
    code.push_str(&format!("{}const {} = {};\n", indent, var_name, mesh_create));
    
    // Position
    if let Some(pos) = get_property_array(&obj.properties, "position") {
        if pos.len() >= 3 {
            code.push_str(&format!("{}{}.position = new BABYLON.Vector3({}, {}, {});\n", 
                indent, var_name, pos[0], pos[1], pos[2]));
        }
    }
    
    code.push('\n');
    code
}

/// Compile to glTF JSON
pub fn compile_gltf_json(ast: &CompositionNode) -> Result<String, Diagnostic> {
    let mut gltf = serde_json::json!({
        "asset": {
            "version": "2.0",
            "generator": "HoloScript Compiler"
        },
        "scene": 0,
        "scenes": [{
            "name": ast.name,
            "nodes": (0..ast.objects.len()).collect::<Vec<_>>()
        }],
        "nodes": [],
        "meshes": [],
        "accessors": [],
        "bufferViews": [],
        "buffers": []
    });
    
    for (i, obj) in ast.objects.iter().enumerate() {
        let position = get_property_array(&obj.properties, "position")
            .unwrap_or_else(|| vec![0.0, 0.0, 0.0]);
        
        let node = serde_json::json!({
            "name": obj.name,
            "mesh": i,
            "translation": position
        });
        
        gltf["nodes"].as_array_mut().unwrap().push(node);
        
        let mesh = serde_json::json!({
            "name": format!("{}_mesh", obj.name),
            "primitives": [{
                "attributes": {},
                "mode": 4
            }]
        });
        
        gltf["meshes"].as_array_mut().unwrap().push(mesh);
    }
    
    serde_json::to_string_pretty(&gltf).map_err(|e| Diagnostic {
        severity: DiagnosticSeverity::Error,
        message: format!("JSON serialization failed: {}", e),
        span: Span {
            start: Position { line: 0, column: 0, offset: 0 },
            end: Position { line: 0, column: 0, offset: 0 },
        },
        code: Some("E100".to_string()),
    })
}

/// Compile to GLB binary
pub fn compile_glb(ast: &CompositionNode) -> Result<Vec<u8>, Diagnostic> {
    // Get JSON first
    let json_string = compile_gltf_json(ast)?;
    let json_bytes = json_string.as_bytes();
    
    // Pad to 4-byte boundary
    let json_padded_len = (json_bytes.len() + 3) & !3;
    let json_padding = json_padded_len - json_bytes.len();
    
    // Build GLB structure
    let mut glb = Vec::new();
    
    // Header (12 bytes)
    glb.extend_from_slice(b"glTF"); // magic
    glb.extend_from_slice(&2u32.to_le_bytes()); // version
    let total_length = 12 + 8 + json_padded_len as u32; // header + chunk header + json
    glb.extend_from_slice(&total_length.to_le_bytes()); // length
    
    // JSON chunk header (8 bytes)
    glb.extend_from_slice(&(json_padded_len as u32).to_le_bytes()); // chunk length
    glb.extend_from_slice(b"JSON"); // chunk type
    
    // JSON data
    glb.extend_from_slice(json_bytes);
    glb.extend(std::iter::repeat(0x20u8).take(json_padding)); // padding with spaces
    
    Ok(glb)
}

// Helper functions

fn sanitize_name(name: &str) -> String {
    name.chars()
        .map(|c| if c.is_alphanumeric() { c } else { '_' })
        .collect()
}

fn get_property_string(props: &[(String, PropertyValue)], key: &str) -> String {
    props.iter()
        .find(|(k, _)| k == key)
        .and_then(|(_, v)| match v {
            PropertyValue::Str(s) => Some(s.clone()),
            _ => None,
        })
        .unwrap_or_default()
}

fn get_property_array(props: &[(String, PropertyValue)], key: &str) -> Option<Vec<f64>> {
    props.iter()
        .find(|(k, _)| k == key)
        .and_then(|(_, v)| match v {
            PropertyValue::Array(arr) => {
                let values: Vec<f64> = arr.iter().filter_map(|v| match v {
                    PropertyValue::Number(n) => Some(*n),
                    _ => None,
                }).collect();
                if values.is_empty() { None } else { Some(values) }
            }
            _ => None,
        })
}

fn get_light_props(props: &[(String, PropertyValue)]) -> (String, String, f64) {
    let color = get_property_string(props, "color");
    let color = if color.is_empty() { "#ffffff".to_string() } else { color };
    
    let intensity = props.iter()
        .find(|(k, _)| k == "intensity")
        .and_then(|(_, v)| match v {
            PropertyValue::Number(n) => Some(*n),
            _ => None,
        })
        .unwrap_or(1.0);
    
    ("point".to_string(), color, intensity)
}

#[cfg(test)]
mod tests {
    use super::*;
    
    fn make_test_ast() -> CompositionNode {
        CompositionNode {
            name: "TestScene".to_string(),
            templates: vec![],
            objects: vec![
                ObjectNode {
                    name: "Cube".to_string(),
                    traits: vec!["grabbable".to_string()],
                    template: None,
                    properties: vec![
                        ("geometry".to_string(), PropertyValue::Str("cube".to_string())),
                        ("position".to_string(), PropertyValue::Array(vec![
                            PropertyValue::Number(0.0),
                            PropertyValue::Number(1.0),
                            PropertyValue::Number(0.0),
                        ])),
                        ("color".to_string(), PropertyValue::Str("#ff0000".to_string())),
                    ],
                    span: None,
                }
            ],
            groups: vec![],
            animations: vec![],
            timelines: vec![],
            lights: vec![],
            cameras: vec![],
            environment: None,
            span: None,
        }
    }
    
    #[test]
    fn test_compile_unity() {
        let ast = make_test_ast();
        let result = compile_unity(&ast);
        assert!(result.is_ok());
        let code = result.unwrap();
        assert!(code.contains("public class TestScene"));
        assert!(code.contains("PrimitiveType.Cube"));
    }
    
    #[test]
    fn test_compile_godot() {
        let ast = make_test_ast();
        let result = compile_godot(&ast);
        assert!(result.is_ok());
        let code = result.unwrap();
        assert!(code.contains("extends Node3D"));
        assert!(code.contains("BoxMesh"));
    }
    
    #[test]
    fn test_compile_aframe() {
        let ast = make_test_ast();
        let result = compile_aframe(&ast);
        assert!(result.is_ok());
        let code = result.unwrap();
        assert!(code.contains("<a-scene>"));
        assert!(code.contains("<a-box"));
    }
    
    #[test]
    fn test_compile_threejs() {
        let ast = make_test_ast();
        let result = compile_threejs(&ast);
        assert!(result.is_ok());
        let code = result.unwrap();
        assert!(code.contains("THREE.BoxGeometry"));
        assert!(code.contains("0xff0000")); // color
    }
    
    #[test]
    fn test_compile_babylonjs() {
        let ast = make_test_ast();
        let result = compile_babylonjs(&ast);
        assert!(result.is_ok());
        let code = result.unwrap();
        assert!(code.contains("BABYLON.MeshBuilder.CreateBox"));
    }
    
    #[test]
    fn test_compile_gltf() {
        let ast = make_test_ast();
        let result = compile_gltf_json(&ast);
        assert!(result.is_ok());
        let json = result.unwrap();
        assert!(json.contains("\"version\": \"2.0\""));
        assert!(json.contains("\"name\": \"TestScene\""));
    }
    
    #[test]
    fn test_compile_glb() {
        let ast = make_test_ast();
        let result = compile_glb(&ast);
        assert!(result.is_ok());
        let bytes = result.unwrap();
        // Check GLB magic bytes
        assert_eq!(&bytes[0..4], b"glTF");
    }
}
