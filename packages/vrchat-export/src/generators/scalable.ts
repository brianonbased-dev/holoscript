/**
 * @scalable Trait Generator
 *
 * Converts HoloScript @scalable trait to VRChat two-handed scaling.
 * Allows users to pinch/stretch objects with both controllers.
 */

import type { HSPlusNode } from '../types.js';
import type {
  TraitMapping,
  ExportContext,
  UdonSharpScript,
  UdonSyncedVariable,
} from '../types.js';

interface ScalableConfig {
  min_scale?: number;
  max_scale?: number;
  uniform?: boolean;
  pivot?: [number, number, number];
}

export function generateScalable(
  node: HSPlusNode,
  config: ScalableConfig,
  context: ExportContext
): TraitMapping {
  const objectName = node.id || 'ScalableObject';
  const scriptName = `${objectName}_Scalable`;

  const syncedVariables: UdonSyncedVariable[] = [
    {
      name: 'syncedScale',
      type: 'Vector3',
      syncMode: 'Smooth',
    },
  ];

  const udonScript: UdonSharpScript = {
    name: scriptName,
    source: generateScalableUdonSharp(objectName, config, context),
    trait: 'scalable',
    requiredComponents: ['VRC_Pickup', 'Rigidbody'],
    syncedVariables,
    networkEvents: ['OnScaleChanged'],
    dependencies: [],
  };

  return {
    trait: 'scalable',
    components: ['VRC_Pickup', 'VRC_ObjectSync', 'Rigidbody', 'BoxCollider'],
    udonScript,
    prefabModifications: {
      'VRC_Pickup': {
        allowTheft: true,
        pickupable: true,
      },
      'Rigidbody': {
        useGravity: false,
        isKinematic: true,
      },
    },
    requiredFeatures: ['VRC_Pickup', 'VRC_ObjectSync', 'UdonBehaviour'],
  };
}

function generateScalableUdonSharp(
  objectName: string,
  config: ScalableConfig,
  context: ExportContext
): string {
  const className = `${objectName.replace(/[^a-zA-Z0-9]/g, '')}_Scalable`;
  const minScale = config.min_scale ?? 0.1;
  const maxScale = config.max_scale ?? 10;
  const uniformScale = config.uniform ?? true;
  const pivot = config.pivot ?? [0, 0, 0];
  const debug = context.config.debug;

  return `/*
 * Generated by @holoscript/vrchat-export
 * Original HoloScript: ${objectName} @scalable
 *
 * This object can be scaled using two-handed pinch gesture.
 * Try the full HoloScript experience at https://hololand.dev
 */

using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;

[UdonBehaviourSyncMode(BehaviourSyncMode.Continuous)]
public class ${className} : UdonSharpBehaviour
{
    [Header("HoloScript @scalable Configuration")]
    [Tooltip("Minimum scale")]
    public float minScale = ${minScale}f;

    [Tooltip("Maximum scale")]
    public float maxScale = ${maxScale}f;

    [Tooltip("Force uniform scaling (same on all axes)")]
    public bool uniformScale = ${uniformScale};

    [Tooltip("Scale pivot point")]
    public Vector3 pivot = new Vector3(${pivot[0]}f, ${pivot[1]}f, ${pivot[2]}f);

    // Synced state
    [UdonSynced] private Vector3 _syncedScale;

    // Tracking
    private VRCPlayerApi _localPlayer;
    private bool _isScaling = false;
    private float _initialHandDistance;
    private Vector3 _initialScale;

    // Hand positions
    private Vector3 _leftHandPos;
    private Vector3 _rightHandPos;

    void Start()
    {
        _localPlayer = Networking.LocalPlayer;
        _syncedScale = transform.localScale;
        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} @scalable initialized");' : ''}
    }

    void Update()
    {
        if (!Networking.IsOwner(gameObject)) return;

        // Check for two-handed interaction
        if (_localPlayer == null) return;

        bool leftGrip = Input.GetAxis("Oculus_CrossPlatform_PrimaryHandTrigger") > 0.5f;
        bool rightGrip = Input.GetAxis("Oculus_CrossPlatform_SecondaryHandTrigger") > 0.5f;

        // Get hand positions
        _leftHandPos = _localPlayer.GetTrackingData(VRCPlayerApi.TrackingDataType.LeftHand).position;
        _rightHandPos = _localPlayer.GetTrackingData(VRCPlayerApi.TrackingDataType.RightHand).position;

        // Check if hands are near the object
        float distToLeft = Vector3.Distance(_leftHandPos, transform.position);
        float distToRight = Vector3.Distance(_rightHandPos, transform.position);
        float interactDistance = Mathf.Max(transform.localScale.magnitude, 1f);

        bool handsNearObject = distToLeft < interactDistance && distToRight < interactDistance;

        if (leftGrip && rightGrip && handsNearObject)
        {
            if (!_isScaling)
            {
                // Start scaling
                _isScaling = true;
                _initialHandDistance = Vector3.Distance(_leftHandPos, _rightHandPos);
                _initialScale = transform.localScale;
                ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} scaling started");' : ''}
            }

            // Calculate new scale
            float currentHandDistance = Vector3.Distance(_leftHandPos, _rightHandPos);
            float scaleMultiplier = currentHandDistance / _initialHandDistance;

            Vector3 newScale;
            if (uniformScale)
            {
                float uniformValue = _initialScale.x * scaleMultiplier;
                uniformValue = Mathf.Clamp(uniformValue, minScale, maxScale);
                newScale = Vector3.one * uniformValue;
            }
            else
            {
                newScale = _initialScale * scaleMultiplier;
                newScale.x = Mathf.Clamp(newScale.x, minScale, maxScale);
                newScale.y = Mathf.Clamp(newScale.y, minScale, maxScale);
                newScale.z = Mathf.Clamp(newScale.z, minScale, maxScale);
            }

            // Apply scale around pivot
            Vector3 pivotWorld = transform.TransformPoint(pivot);
            transform.localScale = newScale;
            Vector3 newPivotWorld = transform.TransformPoint(pivot);
            transform.position += pivotWorld - newPivotWorld;

            _syncedScale = newScale;
        }
        else if (_isScaling)
        {
            // Stop scaling
            _isScaling = false;
            ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} scaling stopped at {transform.localScale}");' : ''}
            SendCustomNetworkEvent(VRC.Udon.Common.Interfaces.NetworkEventTarget.All, nameof(OnScaleChanged));
        }
    }

    public override void OnDeserialization()
    {
        // Apply synced scale
        transform.localScale = _syncedScale;
    }

    public void OnScaleChanged()
    {
        // Network event when scale changes
    }

    // Public API
    public void SetScale(Vector3 scale)
    {
        if (!Networking.IsOwner(gameObject))
        {
            Networking.SetOwner(_localPlayer, gameObject);
        }

        scale.x = Mathf.Clamp(scale.x, minScale, maxScale);
        scale.y = Mathf.Clamp(scale.y, minScale, maxScale);
        scale.z = Mathf.Clamp(scale.z, minScale, maxScale);

        transform.localScale = scale;
        _syncedScale = scale;
    }

    public void ResetScale()
    {
        SetScale(Vector3.one);
    }

    public bool IsScaling()
    {
        return _isScaling;
    }
}
`;
}

export default generateScalable;
