/**
 * @hoverable Trait Generator
 *
 * Converts HoloScript @hoverable trait to VRChat highlight/glow effects.
 * Uses trigger colliders and material property changes.
 */

import type { HSPlusNode } from '../types.js';
import type {
  TraitMapping,
  ExportContext,
  UdonSharpScript,
  UdonSyncedVariable,
} from '../types.js';

/**
 * HoloScript @hoverable configuration
 */
interface HoverableConfig {
  highlight_color?: string;
  scale_on_hover?: number;
  show_tooltip?: string | boolean;
  tooltip_offset?: [number, number, number];
  glow?: boolean;
  glow_intensity?: number;
}

/**
 * Generate VRChat mapping for @hoverable trait
 */
export function generateHoverable(
  node: HSPlusNode,
  config: HoverableConfig,
  context: ExportContext
): TraitMapping {
  const objectName = node.id || 'HoverableObject';
  const scriptName = `${objectName}_Hoverable`;

  const syncedVariables: UdonSyncedVariable[] = [];

  const udonScript: UdonSharpScript = {
    name: scriptName,
    source: generateHoverableUdonSharp(objectName, config, context),
    trait: 'hoverable',
    requiredComponents: ['Collider'],
    syncedVariables,
    networkEvents: [],
    dependencies: [],
  };

  return {
    trait: 'hoverable',
    components: ['BoxCollider', 'MeshRenderer'],
    udonScript,
    prefabModifications: {
      'BoxCollider': {
        isTrigger: true,
        // Slightly larger than object for hover detection
        size: [1.2, 1.2, 1.2],
      },
    },
    requiredFeatures: ['UdonBehaviour'],
  };
}

/**
 * Convert hex color to Unity Color
 */
function hexToUnityColor(hex: string): string {
  const cleanHex = hex.replace('#', '');
  const r = parseInt(cleanHex.substring(0, 2), 16) / 255;
  const g = parseInt(cleanHex.substring(2, 4), 16) / 255;
  const b = parseInt(cleanHex.substring(4, 6), 16) / 255;
  return `new Color(${r.toFixed(3)}f, ${g.toFixed(3)}f, ${b.toFixed(3)}f, 1f)`;
}

/**
 * Generate UdonSharp C# code for hoverable behavior
 */
function generateHoverableUdonSharp(
  objectName: string,
  config: HoverableConfig,
  context: ExportContext
): string {
  const className = `${objectName.replace(/[^a-zA-Z0-9]/g, '')}_Hoverable`;
  const highlightColor = config.highlight_color
    ? hexToUnityColor(config.highlight_color)
    : 'new Color(1f, 1f, 0.5f, 1f)';
  const scaleMultiplier = config.scale_on_hover ?? 1.1;
  const enableGlow = config.glow ?? false;
  const glowIntensity = config.glow_intensity ?? 0.5;
  const tooltipText = typeof config.show_tooltip === 'string' ? config.show_tooltip : '';
  const tooltipOffset = config.tooltip_offset ?? [0, 0.5, 0];
  const debug = context.config.debug;

  return `/*
 * Generated by @holoscript/vrchat-export
 * Original HoloScript: ${objectName} @hoverable
 *
 * This object responds to player proximity/gaze with visual feedback.
 * Try the full HoloScript experience at https://hololand.dev
 */

using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using TMPro;

public class ${className} : UdonSharpBehaviour
{
    [Header("HoloScript @hoverable Configuration")]
    [Tooltip("Color when hovered")]
    public Color highlightColor = ${highlightColor};

    [Tooltip("Scale multiplier on hover")]
    public float scaleOnHover = ${scaleMultiplier}f;

    [Tooltip("Enable glow effect")]
    public bool enableGlow = ${enableGlow};

    [Tooltip("Glow intensity")]
    [Range(0f, 2f)]
    public float glowIntensity = ${glowIntensity}f;

    [Tooltip("Tooltip text (leave empty to disable)")]
    public string tooltipText = "${tooltipText}";

    [Tooltip("Tooltip offset from object center")]
    public Vector3 tooltipOffset = new Vector3(${tooltipOffset[0]}f, ${tooltipOffset[1]}f, ${tooltipOffset[2]}f);

    [Header("Optional References")]
    [Tooltip("Text component for tooltip (auto-created if null)")]
    public TextMeshPro tooltipLabel;

    // State
    private bool _isHovered = false;
    private MeshRenderer _renderer;
    private Color _originalColor;
    private Vector3 _originalScale;
    private float _originalEmission;
    private MaterialPropertyBlock _propertyBlock;

    // Animation
    private float _hoverTransition = 0f;
    private const float TRANSITION_SPEED = 8f;

    void Start()
    {
        _renderer = GetComponent<MeshRenderer>();
        _originalScale = transform.localScale;
        _propertyBlock = new MaterialPropertyBlock();

        if (_renderer != null && _renderer.material != null)
        {
            _originalColor = _renderer.material.color;
            if (_renderer.material.HasProperty("_EmissionColor"))
            {
                _originalEmission = _renderer.material.GetColor("_EmissionColor").maxColorComponent;
            }
        }

        // Setup tooltip if needed
        if (!string.IsNullOrEmpty(tooltipText) && tooltipLabel == null)
        {
            CreateTooltip();
        }

        if (tooltipLabel != null)
        {
            tooltipLabel.gameObject.SetActive(false);
        }

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} @hoverable initialized");' : ''}
    }

    void Update()
    {
        // Smooth transition
        float targetTransition = _isHovered ? 1f : 0f;
        _hoverTransition = Mathf.Lerp(_hoverTransition, targetTransition, Time.deltaTime * TRANSITION_SPEED);

        // Apply scale
        if (scaleOnHover != 1f)
        {
            transform.localScale = Vector3.Lerp(_originalScale, _originalScale * scaleOnHover, _hoverTransition);
        }

        // Apply color/glow
        if (_renderer != null)
        {
            _renderer.GetPropertyBlock(_propertyBlock);

            Color currentColor = Color.Lerp(_originalColor, highlightColor, _hoverTransition);
            _propertyBlock.SetColor("_Color", currentColor);

            if (enableGlow && _renderer.material.HasProperty("_EmissionColor"))
            {
                Color emissionColor = highlightColor * Mathf.Lerp(0, glowIntensity, _hoverTransition);
                _propertyBlock.SetColor("_EmissionColor", emissionColor);
            }

            _renderer.SetPropertyBlock(_propertyBlock);
        }

        // Billboard tooltip to face player
        if (tooltipLabel != null && _isHovered)
        {
            VRCPlayerApi localPlayer = Networking.LocalPlayer;
            if (localPlayer != null)
            {
                Vector3 playerHead = localPlayer.GetTrackingData(VRCPlayerApi.TrackingDataType.Head).position;
                tooltipLabel.transform.LookAt(playerHead);
                tooltipLabel.transform.Rotate(0, 180, 0);
            }
        }
    }

    public override void OnPlayerTriggerEnter(VRCPlayerApi player)
    {
        if (player.isLocal)
        {
            _isHovered = true;
            if (tooltipLabel != null)
            {
                tooltipLabel.gameObject.SetActive(true);
            }
            ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} hover enter");' : ''}
        }
    }

    public override void OnPlayerTriggerExit(VRCPlayerApi player)
    {
        if (player.isLocal)
        {
            _isHovered = false;
            if (tooltipLabel != null)
            {
                tooltipLabel.gameObject.SetActive(false);
            }
            ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} hover exit");' : ''}
        }
    }

    private void CreateTooltip()
    {
        GameObject tooltipObj = new GameObject("Tooltip");
        tooltipObj.transform.SetParent(transform);
        tooltipObj.transform.localPosition = tooltipOffset;
        tooltipObj.transform.localScale = Vector3.one * 0.1f;

        tooltipLabel = tooltipObj.AddComponent<TextMeshPro>();
        tooltipLabel.text = tooltipText;
        tooltipLabel.fontSize = 2;
        tooltipLabel.alignment = TextAlignmentOptions.Center;
        tooltipLabel.color = Color.white;
    }

    // Public API
    public void SetHighlightColor(Color color)
    {
        highlightColor = color;
    }

    public void SetTooltipText(string text)
    {
        tooltipText = text;
        if (tooltipLabel != null)
        {
            tooltipLabel.text = text;
        }
    }

    public bool IsHovered()
    {
        return _isHovered;
    }
}
`;
}

export default generateHoverable;
