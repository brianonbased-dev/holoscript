/**
 * @snappable Trait Generator
 *
 * Converts HoloScript @snappable trait to VRChat snap point system.
 * Objects snap to predefined positions when released nearby.
 */

import type { HSPlusNode } from '../types.js';
import type {
  TraitMapping,
  ExportContext,
  UdonSharpScript,
  UdonSyncedVariable,
} from '../types.js';

interface SnappableConfig {
  snap_points?: [number, number, number][];
  snap_distance?: number;
  snap_rotation?: boolean;
  magnetic?: boolean;
}

export function generateSnappable(
  node: HSPlusNode,
  config: SnappableConfig,
  context: ExportContext
): TraitMapping {
  const objectName = node.id || 'SnappableObject';
  const scriptName = `${objectName}_Snappable`;

  const syncedVariables: UdonSyncedVariable[] = [
    {
      name: 'snappedPointIndex',
      type: 'int',
      syncMode: 'Manual',
      defaultValue: '-1',
    },
  ];

  const udonScript: UdonSharpScript = {
    name: scriptName,
    source: generateSnappableUdonSharp(objectName, config, context),
    trait: 'snappable',
    requiredComponents: ['VRC_Pickup'],
    syncedVariables,
    networkEvents: ['OnSnapped', 'OnUnsnapped'],
    dependencies: [],
  };

  return {
    trait: 'snappable',
    components: ['VRC_Pickup', 'VRC_ObjectSync', 'Rigidbody', 'BoxCollider'],
    udonScript,
    prefabModifications: {
      'VRC_Pickup': {
        allowTheft: true,
        pickupable: true,
      },
      'Rigidbody': {
        useGravity: true,
        isKinematic: false,
      },
    },
    requiredFeatures: ['VRC_Pickup', 'VRC_ObjectSync', 'UdonBehaviour'],
  };
}

function generateSnappableUdonSharp(
  objectName: string,
  config: SnappableConfig,
  context: ExportContext
): string {
  const className = `${objectName.replace(/[^a-zA-Z0-9]/g, '')}_Snappable`;
  const snapDistance = config.snap_distance ?? 0.3;
  const snapRotation = config.snap_rotation ?? true;
  const magnetic = config.magnetic ?? false;

  // Convert snap points to C# array initialization
  const snapPoints = config.snap_points ?? [];
  const snapPointsInit = snapPoints.length > 0
    ? snapPoints.map(p => `new Vector3(${p[0]}f, ${p[1]}f, ${p[2]}f)`).join(',\n            ')
    : '';

  const debug = context.config.debug;

  return `/*
 * Generated by @holoscript/vrchat-export
 * Original HoloScript: ${objectName} @snappable
 *
 * This object snaps to predefined positions when released nearby.
 * Try the full HoloScript experience at https://hololand.dev
 */

using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;

[UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]
public class ${className} : UdonSharpBehaviour
{
    [Header("HoloScript @snappable Configuration")]
    [Tooltip("World-space snap points")]
    public Vector3[] snapPoints = new Vector3[] {
        ${snapPointsInit}
    };

    [Tooltip("Distance to trigger snap")]
    public float snapDistance = ${snapDistance}f;

    [Tooltip("Also snap rotation to align with snap point")]
    public bool snapRotation = ${snapRotation};

    [Tooltip("Magnetic pull toward snap point while held")]
    public bool magnetic = ${magnetic};

    [Tooltip("Magnetic pull strength")]
    public float magneticStrength = 5f;

    [Header("Optional: Transform-based snap points")]
    [Tooltip("Use child transforms as snap points instead of Vector3 array")]
    public Transform[] snapPointTransforms;

    // State
    [UdonSynced] public int snappedPointIndex = -1;

    private VRC_Pickup _pickup;
    private Rigidbody _rigidbody;
    private bool _isHeld = false;
    private bool _isSnapped = false;

    void Start()
    {
        _pickup = GetComponent<VRC_Pickup>();
        _rigidbody = GetComponent<Rigidbody>();

        // If transform snap points provided, use those
        if (snapPointTransforms != null && snapPointTransforms.Length > 0)
        {
            snapPoints = new Vector3[snapPointTransforms.Length];
            for (int i = 0; i < snapPointTransforms.Length; i++)
            {
                if (snapPointTransforms[i] != null)
                {
                    snapPoints[i] = snapPointTransforms[i].position;
                }
            }
        }

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} @snappable initialized with {snapPoints.Length} snap points");' : ''}
    }

    void Update()
    {
        if (_isHeld && magnetic)
        {
            // Apply magnetic pull toward nearest snap point
            int nearestIndex;
            float nearestDist;
            FindNearestSnapPoint(out nearestIndex, out nearestDist);

            if (nearestIndex >= 0 && nearestDist < snapDistance * 2f)
            {
                Vector3 targetPos = GetSnapPointPosition(nearestIndex);
                Vector3 pullDir = (targetPos - transform.position).normalized;
                float pullStrength = Mathf.Lerp(magneticStrength, 0f, nearestDist / (snapDistance * 2f));

                // Visual feedback - gentle pull
                transform.position = Vector3.Lerp(
                    transform.position,
                    transform.position + pullDir * pullStrength * Time.deltaTime,
                    0.5f
                );
            }
        }
    }

    public override void OnPickup()
    {
        _isHeld = true;

        // Unsnap when picked up
        if (_isSnapped)
        {
            Unsnap();
        }
    }

    public override void OnDrop()
    {
        _isHeld = false;

        // Check for snap opportunity
        int nearestIndex;
        float nearestDist;
        FindNearestSnapPoint(out nearestIndex, out nearestDist);

        if (nearestIndex >= 0 && nearestDist <= snapDistance)
        {
            SnapToPoint(nearestIndex);
        }
    }

    private void FindNearestSnapPoint(out int index, out float distance)
    {
        index = -1;
        distance = float.MaxValue;

        for (int i = 0; i < snapPoints.Length; i++)
        {
            Vector3 snapPos = GetSnapPointPosition(i);
            float dist = Vector3.Distance(transform.position, snapPos);

            if (dist < distance)
            {
                distance = dist;
                index = i;
            }
        }
    }

    private Vector3 GetSnapPointPosition(int index)
    {
        if (snapPointTransforms != null && index < snapPointTransforms.Length && snapPointTransforms[index] != null)
        {
            return snapPointTransforms[index].position;
        }
        return snapPoints[index];
    }

    private Quaternion GetSnapPointRotation(int index)
    {
        if (snapPointTransforms != null && index < snapPointTransforms.Length && snapPointTransforms[index] != null)
        {
            return snapPointTransforms[index].rotation;
        }
        return Quaternion.identity;
    }

    private void SnapToPoint(int index)
    {
        if (!Networking.IsOwner(gameObject))
        {
            Networking.SetOwner(Networking.LocalPlayer, gameObject);
        }

        Vector3 targetPos = GetSnapPointPosition(index);
        transform.position = targetPos;

        if (snapRotation)
        {
            transform.rotation = GetSnapPointRotation(index);
        }

        // Disable physics while snapped
        if (_rigidbody != null)
        {
            _rigidbody.isKinematic = true;
            _rigidbody.velocity = Vector3.zero;
            _rigidbody.angularVelocity = Vector3.zero;
        }

        _isSnapped = true;
        snappedPointIndex = index;

        RequestSerialization();

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} snapped to point {index}");' : ''}

        SendCustomNetworkEvent(VRC.Udon.Common.Interfaces.NetworkEventTarget.All, nameof(OnSnapped));
    }

    private void Unsnap()
    {
        _isSnapped = false;
        snappedPointIndex = -1;

        // Re-enable physics
        if (_rigidbody != null)
        {
            _rigidbody.isKinematic = false;
        }

        RequestSerialization();

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} unsnapped");' : ''}

        SendCustomNetworkEvent(VRC.Udon.Common.Interfaces.NetworkEventTarget.All, nameof(OnUnsnapped));
    }

    public override void OnDeserialization()
    {
        // Sync snap state
        if (snappedPointIndex >= 0 && !_isHeld)
        {
            transform.position = GetSnapPointPosition(snappedPointIndex);
            if (snapRotation)
            {
                transform.rotation = GetSnapPointRotation(snappedPointIndex);
            }
            _isSnapped = true;
            if (_rigidbody != null) _rigidbody.isKinematic = true;
        }
    }

    public void OnSnapped()
    {
        // Network event when snapped
    }

    public void OnUnsnapped()
    {
        // Network event when unsnapped
    }

    // Public API
    public bool IsSnapped()
    {
        return _isSnapped;
    }

    public int GetSnappedPointIndex()
    {
        return snappedPointIndex;
    }

    public void ForceSnapToPoint(int index)
    {
        if (index >= 0 && index < snapPoints.Length)
        {
            SnapToPoint(index);
        }
    }

    public void AddSnapPoint(Vector3 point)
    {
        Vector3[] newPoints = new Vector3[snapPoints.Length + 1];
        for (int i = 0; i < snapPoints.Length; i++)
        {
            newPoints[i] = snapPoints[i];
        }
        newPoints[snapPoints.Length] = point;
        snapPoints = newPoints;
    }
}
`;
}

export default generateSnappable;
