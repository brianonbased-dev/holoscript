/**
 * @stackable Trait Generator
 *
 * Converts HoloScript @stackable trait to VRChat stacking behavior.
 * Allows objects to stack on top of each other.
 */

import type { HSPlusNode } from '../types.js';
import type {
  TraitMapping,
  ExportContext,
  UdonSharpScript,
  UdonSyncedVariable,
} from '../types.js';

interface StackableConfig {
  stack_axis?: 'x' | 'y' | 'z';
  stack_offset?: number;
  max_stack?: number;
  snap_distance?: number;
}

export function generateStackable(
  node: HSPlusNode,
  config: StackableConfig,
  context: ExportContext
): TraitMapping {
  const objectName = node.id || 'StackableObject';
  const scriptName = `${objectName}_Stackable`;

  const syncedVariables: UdonSyncedVariable[] = [
    {
      name: 'stackIndex',
      type: 'int',
      syncMode: 'Manual',
      defaultValue: '0',
    },
    {
      name: 'stackParentId',
      type: 'int',
      syncMode: 'Manual',
      defaultValue: '-1',
    },
  ];

  const udonScript: UdonSharpScript = {
    name: scriptName,
    source: generateStackableUdonSharp(objectName, config, context),
    trait: 'stackable',
    requiredComponents: ['VRC_Pickup', 'Rigidbody', 'Collider'],
    syncedVariables,
    networkEvents: ['OnStacked', 'OnUnstacked'],
    dependencies: [],
  };

  return {
    trait: 'stackable',
    components: ['VRC_Pickup', 'VRC_ObjectSync', 'Rigidbody', 'BoxCollider'],
    udonScript,
    prefabModifications: {
      'VRC_Pickup': {
        allowTheft: true,
        pickupable: true,
      },
      'Rigidbody': {
        useGravity: true,
        isKinematic: false,
        constraints: 'FreezeRotation', // Keep upright for stacking
      },
    },
    requiredFeatures: ['VRC_Pickup', 'VRC_ObjectSync', 'UdonBehaviour'],
  };
}

function generateStackableUdonSharp(
  objectName: string,
  config: StackableConfig,
  context: ExportContext
): string {
  const className = `${objectName.replace(/[^a-zA-Z0-9]/g, '')}_Stackable`;
  const stackAxis = config.stack_axis ?? 'y';
  const stackOffset = config.stack_offset ?? 0.5;
  const maxStack = config.max_stack ?? 10;
  const snapDistance = config.snap_distance ?? 0.3;
  const debug = context.config.debug;

  const axisVector = stackAxis === 'x' ? 'Vector3.right' :
                     stackAxis === 'z' ? 'Vector3.forward' : 'Vector3.up';

  return `/*
 * Generated by @holoscript/vrchat-export
 * Original HoloScript: ${objectName} @stackable
 *
 * This object can be stacked on other stackable objects.
 * Try the full HoloScript experience at https://hololand.dev
 */

using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;

[UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]
public class ${className} : UdonSharpBehaviour
{
    [Header("HoloScript @stackable Configuration")]
    [Tooltip("Stacking axis")]
    public Vector3 stackAxis = ${axisVector};

    [Tooltip("Offset between stacked objects")]
    public float stackOffset = ${stackOffset}f;

    [Tooltip("Maximum stack height")]
    public int maxStack = ${maxStack};

    [Tooltip("Distance to snap to stack")]
    public float snapDistance = ${snapDistance}f;

    [Header("Runtime State")]
    [UdonSynced] public int stackIndex = 0;
    [UdonSynced] public int stackParentId = -1;

    // References
    private VRC_Pickup _pickup;
    private Rigidbody _rigidbody;
    private ${className} _stackParent;
    private ${className}[] _stackChildren;

    // State
    private bool _isHeld = false;
    private bool _isStacked = false;

    void Start()
    {
        _pickup = GetComponent<VRC_Pickup>();
        _rigidbody = GetComponent<Rigidbody>();
        _stackChildren = new ${className}[maxStack];
        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} @stackable initialized");' : ''}
    }

    public override void OnPickup()
    {
        _isHeld = true;

        // Unstack when picked up
        if (_isStacked)
        {
            Unstack();
        }
    }

    public override void OnDrop()
    {
        _isHeld = false;

        // Check for stacking opportunity
        CheckForStackTarget();
    }

    private void CheckForStackTarget()
    {
        // Raycast downward to find stackable surface
        RaycastHit hit;
        Vector3 rayStart = transform.position + stackAxis * 0.1f;

        if (Physics.Raycast(rayStart, -stackAxis, out hit, snapDistance * 2f))
        {
            ${className} targetStack = hit.collider.GetComponent<${className}>();

            if (targetStack != null && targetStack != this)
            {
                // Check if we can stack
                int targetStackHeight = GetStackHeight(targetStack);
                if (targetStackHeight < maxStack)
                {
                    StackOn(targetStack, targetStackHeight);
                }
            }
        }
    }

    private int GetStackHeight(${className} baseStack)
    {
        int height = 1;
        ${className} current = baseStack;

        // Walk up the stack
        for (int i = 0; i < _stackChildren.Length; i++)
        {
            if (current._stackChildren[0] != null)
            {
                height++;
                current = current._stackChildren[0];
            }
            else break;
        }

        return height;
    }

    private void StackOn(${className} target, int stackHeight)
    {
        if (!Networking.IsOwner(gameObject))
        {
            Networking.SetOwner(Networking.LocalPlayer, gameObject);
        }

        _stackParent = target;
        _isStacked = true;
        stackIndex = stackHeight;
        stackParentId = target.gameObject.GetInstanceID();

        // Calculate stacked position
        Vector3 stackedPos = target.transform.position + stackAxis * stackOffset * stackHeight;
        transform.position = stackedPos;

        // Disable physics while stacked
        if (_rigidbody != null)
        {
            _rigidbody.isKinematic = true;
        }

        // Parent for organization (optional)
        transform.SetParent(target.transform);

        // Register as child
        target._stackChildren[stackHeight - 1] = this;

        RequestSerialization();

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} stacked at index {stackIndex}");' : ''}

        SendCustomNetworkEvent(VRC.Udon.Common.Interfaces.NetworkEventTarget.All, nameof(OnStacked));
    }

    private void Unstack()
    {
        if (_stackParent != null)
        {
            // Unregister from parent
            for (int i = 0; i < _stackParent._stackChildren.Length; i++)
            {
                if (_stackParent._stackChildren[i] == this)
                {
                    _stackParent._stackChildren[i] = null;
                    break;
                }
            }
        }

        _stackParent = null;
        _isStacked = false;
        stackIndex = 0;
        stackParentId = -1;

        // Re-enable physics
        if (_rigidbody != null)
        {
            _rigidbody.isKinematic = false;
        }

        // Unparent
        transform.SetParent(null);

        RequestSerialization();

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} unstacked");' : ''}

        SendCustomNetworkEvent(VRC.Udon.Common.Interfaces.NetworkEventTarget.All, nameof(OnUnstacked));
    }

    public void OnStacked()
    {
        // Network event when stacked
    }

    public void OnUnstacked()
    {
        // Network event when unstacked
    }

    // Public API
    public bool IsStacked()
    {
        return _isStacked;
    }

    public int GetStackIndex()
    {
        return stackIndex;
    }

    public void ForceUnstack()
    {
        if (_isStacked && !_isHeld)
        {
            Unstack();
        }
    }
}
`;
}

export default generateStackable;
