/**
 * @breakable Trait Generator
 *
 * Converts HoloScript @breakable trait to VRChat destructible object.
 * Uses object pooling for fragments (VRChat doesn't support runtime instantiation).
 */

import type { HSPlusNode } from '../types.js';
import type {
  TraitMapping,
  ExportContext,
  UdonSharpScript,
  UdonSyncedVariable,
} from '../types.js';

interface BreakableConfig {
  break_velocity?: number;
  fragments?: number;
  fragment_mesh?: string;
  sound_on_break?: string;
  respawn?: boolean;
  respawn_delay?: string;
}

/**
 * Parse duration string (e.g., "3s", "500ms") to milliseconds
 */
function parseDuration(duration: string): number {
  if (duration.endsWith('ms')) {
    return parseInt(duration.replace('ms', ''), 10);
  } else if (duration.endsWith('s')) {
    return parseFloat(duration.replace('s', '')) * 1000;
  } else if (duration.endsWith('m')) {
    return parseFloat(duration.replace('m', '')) * 60000;
  }
  return parseInt(duration, 10);
}

export function generateBreakable(
  node: HSPlusNode,
  config: BreakableConfig,
  context: ExportContext
): TraitMapping {
  const objectName = node.id || 'BreakableObject';
  const scriptName = `${objectName}_Breakable`;

  const syncedVariables: UdonSyncedVariable[] = [
    {
      name: 'isBroken',
      type: 'bool',
      syncMode: 'Manual',
      defaultValue: 'false',
    },
  ];

  const udonScript: UdonSharpScript = {
    name: scriptName,
    source: generateBreakableUdonSharp(objectName, config, context),
    trait: 'breakable',
    requiredComponents: ['Rigidbody', 'Collider', 'AudioSource'],
    syncedVariables,
    networkEvents: ['OnBreak', 'OnRespawn'],
    dependencies: [],
  };

  // Breakable adds complexity - needs fragment pool
  context.warnings.push({
    code: 'BREAKABLE_POOL_REQUIRED',
    message: `@breakable on "${objectName}" requires pre-spawned fragment objects in scene. See generated README for setup instructions.`,
    node,
    suggestion: 'Create fragment GameObjects as children of a "FragmentPool" object and assign them in the inspector.',
  });

  return {
    trait: 'breakable',
    components: ['Rigidbody', 'BoxCollider', 'AudioSource'],
    udonScript,
    prefabModifications: {
      'Rigidbody': {
        useGravity: true,
        isKinematic: false,
        collisionDetectionMode: 'Continuous',
      },
      'AudioSource': {
        playOnAwake: false,
        spatialBlend: 1.0, // 3D audio
      },
    },
    requiredFeatures: ['VRC_ObjectPool', 'UdonBehaviour'],
  };
}

function generateBreakableUdonSharp(
  objectName: string,
  config: BreakableConfig,
  context: ExportContext
): string {
  const className = `${objectName.replace(/[^a-zA-Z0-9]/g, '')}_Breakable`;
  const breakVelocity = config.break_velocity ?? 5;
  const fragmentCount = config.fragments ?? 5;
  const respawn = config.respawn ?? true;
  const respawnDelayMs = config.respawn_delay ? parseDuration(config.respawn_delay) : 3000;
  const respawnDelaySec = respawnDelayMs / 1000;
  const debug = context.config.debug;

  return `/*
 * Generated by @holoscript/vrchat-export
 * Original HoloScript: ${objectName} @breakable
 *
 * This object can break into fragments on impact.
 * IMPORTANT: Requires pre-spawned fragment objects (VRChat doesn't support runtime instantiation).
 *
 * Try the full HoloScript experience at https://hololand.dev
 */

using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;

[UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]
public class ${className} : UdonSharpBehaviour
{
    [Header("HoloScript @breakable Configuration")]
    [Tooltip("Minimum impact velocity to break")]
    public float breakVelocity = ${breakVelocity}f;

    [Tooltip("Enable respawn after breaking")]
    public bool enableRespawn = ${respawn};

    [Tooltip("Delay before respawn (seconds)")]
    public float respawnDelay = ${respawnDelaySec}f;

    [Header("Fragment Pool (REQUIRED)")]
    [Tooltip("Pre-spawned fragment objects - assign ${fragmentCount} in inspector")]
    public GameObject[] fragmentPool;

    [Tooltip("Audio clip to play on break")]
    public AudioClip breakSound;

    // State
    [UdonSynced] public bool isBroken = false;

    // References
    private MeshRenderer _renderer;
    private Collider _collider;
    private Rigidbody _rigidbody;
    private AudioSource _audioSource;

    // Original state for respawn
    private Vector3 _originalPosition;
    private Quaternion _originalRotation;

    void Start()
    {
        _renderer = GetComponent<MeshRenderer>();
        _collider = GetComponent<Collider>();
        _rigidbody = GetComponent<Rigidbody>();
        _audioSource = GetComponent<AudioSource>();

        _originalPosition = transform.position;
        _originalRotation = transform.rotation;

        // Hide fragments initially
        if (fragmentPool != null)
        {
            for (int i = 0; i < fragmentPool.Length; i++)
            {
                if (fragmentPool[i] != null)
                {
                    fragmentPool[i].SetActive(false);
                }
            }
        }

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} @breakable initialized with {fragmentPool?.Length ?? 0} fragments");' : ''}
    }

    private void OnCollisionEnter(Collision collision)
    {
        if (isBroken) return;

        float impactVelocity = collision.relativeVelocity.magnitude;

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} impact: {impactVelocity:F2} (threshold: {breakVelocity})");' : ''}

        if (impactVelocity >= breakVelocity)
        {
            // Take ownership and break
            if (!Networking.IsOwner(gameObject))
            {
                Networking.SetOwner(Networking.LocalPlayer, gameObject);
            }

            Break(collision.contacts[0].point, collision.relativeVelocity);
        }
    }

    private void Break(Vector3 impactPoint, Vector3 impactVelocity)
    {
        isBroken = true;
        RequestSerialization();

        // Hide main object
        if (_renderer != null) _renderer.enabled = false;
        if (_collider != null) _collider.enabled = false;
        if (_rigidbody != null) _rigidbody.isKinematic = true;

        // Play break sound
        if (_audioSource != null && breakSound != null)
        {
            _audioSource.PlayOneShot(breakSound);
        }

        // Activate and scatter fragments
        if (fragmentPool != null)
        {
            for (int i = 0; i < fragmentPool.Length; i++)
            {
                if (fragmentPool[i] != null)
                {
                    fragmentPool[i].SetActive(true);
                    fragmentPool[i].transform.position = transform.position + Random.insideUnitSphere * 0.1f;
                    fragmentPool[i].transform.rotation = Random.rotation;

                    Rigidbody fragRb = fragmentPool[i].GetComponent<Rigidbody>();
                    if (fragRb != null)
                    {
                        fragRb.isKinematic = false;
                        // Explode fragments outward from impact
                        Vector3 explosionDir = (fragmentPool[i].transform.position - impactPoint).normalized;
                        fragRb.velocity = explosionDir * impactVelocity.magnitude * 0.5f + Random.insideUnitSphere * 2f;
                        fragRb.angularVelocity = Random.insideUnitSphere * 10f;
                    }
                }
            }
        }

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} BROKEN!");' : ''}

        SendCustomNetworkEvent(VRC.Udon.Common.Interfaces.NetworkEventTarget.All, nameof(OnBreak));

        // Schedule respawn
        if (enableRespawn)
        {
            SendCustomEventDelayedSeconds(nameof(Respawn), respawnDelay);
        }
    }

    public void Respawn()
    {
        if (!Networking.IsOwner(gameObject))
        {
            Networking.SetOwner(Networking.LocalPlayer, gameObject);
        }

        isBroken = false;
        RequestSerialization();

        // Reset main object
        transform.position = _originalPosition;
        transform.rotation = _originalRotation;

        if (_renderer != null) _renderer.enabled = true;
        if (_collider != null) _collider.enabled = true;
        if (_rigidbody != null)
        {
            _rigidbody.isKinematic = false;
            _rigidbody.velocity = Vector3.zero;
            _rigidbody.angularVelocity = Vector3.zero;
        }

        // Hide fragments
        if (fragmentPool != null)
        {
            for (int i = 0; i < fragmentPool.Length; i++)
            {
                if (fragmentPool[i] != null)
                {
                    fragmentPool[i].SetActive(false);
                    Rigidbody fragRb = fragmentPool[i].GetComponent<Rigidbody>();
                    if (fragRb != null)
                    {
                        fragRb.isKinematic = true;
                    }
                }
            }
        }

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} respawned");' : ''}

        SendCustomNetworkEvent(VRC.Udon.Common.Interfaces.NetworkEventTarget.All, nameof(OnRespawn));
    }

    public override void OnDeserialization()
    {
        // Sync break state
        if (isBroken)
        {
            if (_renderer != null) _renderer.enabled = false;
            if (_collider != null) _collider.enabled = false;
        }
        else
        {
            if (_renderer != null) _renderer.enabled = true;
            if (_collider != null) _collider.enabled = true;
        }
    }

    public void OnBreak()
    {
        // Network event when broken
    }

    public void OnRespawn()
    {
        // Network event when respawned
    }

    // Public API
    public bool IsBroken()
    {
        return isBroken;
    }

    public void ForceBreak()
    {
        if (!isBroken)
        {
            Break(transform.position, Vector3.down * breakVelocity);
        }
    }

    public void ForceRespawn()
    {
        Respawn();
    }
}
`;
}

export default generateBreakable;
