/**
 * @throwable Trait Generator
 *
 * Converts HoloScript @throwable trait to VRChat physics-enabled pickup.
 * Extends @grabbable with velocity tracking and physics behavior.
 */

import type { HSPlusNode } from '../types.js';
import type {
  TraitMapping,
  ExportContext,
  UdonSharpScript,
  UdonSyncedVariable,
} from '../types.js';

/**
 * HoloScript @throwable configuration
 */
interface ThrowableConfig {
  velocity_multiplier?: number;
  gravity?: boolean;
  max_velocity?: number;
  spin?: boolean;
  bounce?: boolean;
  bounce_factor?: number;
}

/**
 * Generate VRChat mapping for @throwable trait
 */
export function generateThrowable(
  node: HSPlusNode,
  config: ThrowableConfig,
  context: ExportContext
): TraitMapping {
  const objectName = node.id || 'ThrowableObject';
  const scriptName = `${objectName}_Throwable`;

  const syncedVariables: UdonSyncedVariable[] = [
    {
      name: 'isThrown',
      type: 'bool',
      syncMode: 'None',
      defaultValue: 'false',
    },
    {
      name: 'throwVelocity',
      type: 'Vector3',
      syncMode: 'None',
    },
  ];

  const udonScript: UdonSharpScript = {
    name: scriptName,
    source: generateThrowableUdonSharp(objectName, config, context),
    trait: 'throwable',
    requiredComponents: ['VRC_Pickup', 'Rigidbody', 'Collider'],
    syncedVariables,
    networkEvents: ['OnPickup', 'OnDrop', 'OnThrow'],
    dependencies: [],
  };

  return {
    trait: 'throwable',
    components: ['VRC_Pickup', 'VRC_ObjectSync', 'Rigidbody', 'BoxCollider'],
    udonScript,
    prefabModifications: {
      'VRC_Pickup': {
        allowTheft: true,
        pickupable: true,
        throwVelocityBoostScale: config.velocity_multiplier ?? 1.5,
        throwVelocityBoostMinSpeed: 1.0,
      },
      'Rigidbody': {
        useGravity: config.gravity ?? true,
        isKinematic: false,
        mass: 1,
        drag: 0.1,
        angularDrag: 0.5,
        collisionDetectionMode: 'Continuous',
      },
      'PhysicMaterial': config.bounce ? {
        bounciness: config.bounce_factor ?? 0.8,
        dynamicFriction: 0.4,
        staticFriction: 0.4,
        bounceCombine: 'Maximum',
      } : undefined,
    },
    requiredFeatures: ['VRC_Pickup', 'VRC_ObjectSync', 'UdonBehaviour'],
  };
}

/**
 * Generate UdonSharp C# code for throwable behavior
 */
function generateThrowableUdonSharp(
  objectName: string,
  config: ThrowableConfig,
  context: ExportContext
): string {
  const className = `${objectName.replace(/[^a-zA-Z0-9]/g, '')}_Throwable`;
  const velocityMultiplier = config.velocity_multiplier ?? 1.5;
  const maxVelocity = config.max_velocity ?? 30;
  const enableSpin = config.spin ?? true;
  const debug = context.config.debug;

  return `/*
 * Generated by @holoscript/vrchat-export
 * Original HoloScript: ${objectName} @throwable
 *
 * This object can be thrown with physics simulation.
 * Try the full HoloScript experience at https://hololand.dev
 */

using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;

[UdonBehaviourSyncMode(BehaviourSyncMode.Continuous)]
public class ${className} : UdonSharpBehaviour
{
    [Header("HoloScript @throwable Configuration")]
    [Tooltip("Velocity multiplier for throws")]
    public float velocityMultiplier = ${velocityMultiplier}f;

    [Tooltip("Maximum throw velocity")]
    public float maxVelocity = ${maxVelocity}f;

    [Tooltip("Add spin when thrown")]
    public bool enableSpin = ${enableSpin};

    [Tooltip("Use gravity")]
    public bool useGravity = ${config.gravity ?? true};

    // Velocity tracking
    private Vector3[] _velocityHistory = new Vector3[5];
    private int _velocityIndex = 0;
    private Vector3 _lastPosition;
    private float _lastTime;

    // State
    [UdonSynced] private bool _isThrown = false;
    private VRC_Pickup _pickup;
    private Rigidbody _rigidbody;
    private bool _isHeld = false;

    void Start()
    {
        _pickup = GetComponent<VRC_Pickup>();
        _rigidbody = GetComponent<Rigidbody>();
        _rigidbody.useGravity = useGravity;
        _lastPosition = transform.position;
        _lastTime = Time.time;
        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} @throwable initialized");' : ''}
    }

    void Update()
    {
        if (_isHeld)
        {
            TrackVelocity();
        }
    }

    private void TrackVelocity()
    {
        float deltaTime = Time.time - _lastTime;
        if (deltaTime > 0.001f)
        {
            Vector3 velocity = (transform.position - _lastPosition) / deltaTime;
            _velocityHistory[_velocityIndex] = velocity;
            _velocityIndex = (_velocityIndex + 1) % _velocityHistory.Length;
            _lastPosition = transform.position;
            _lastTime = Time.time;
        }
    }

    private Vector3 GetAverageVelocity()
    {
        Vector3 sum = Vector3.zero;
        for (int i = 0; i < _velocityHistory.Length; i++)
        {
            sum += _velocityHistory[i];
        }
        return sum / _velocityHistory.Length;
    }

    public override void OnPickup()
    {
        _isHeld = true;
        _isThrown = false;
        _lastPosition = transform.position;
        _lastTime = Time.time;

        // Reset velocity history
        for (int i = 0; i < _velocityHistory.Length; i++)
        {
            _velocityHistory[i] = Vector3.zero;
        }

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} picked up for throwing");' : ''}
    }

    public override void OnDrop()
    {
        _isHeld = false;

        // Calculate throw velocity
        Vector3 avgVelocity = GetAverageVelocity();
        Vector3 throwVelocity = avgVelocity * velocityMultiplier;

        // Clamp to max velocity
        if (throwVelocity.magnitude > maxVelocity)
        {
            throwVelocity = throwVelocity.normalized * maxVelocity;
        }

        // Apply velocity
        if (_rigidbody != null)
        {
            _rigidbody.velocity = throwVelocity;

            // Add spin if enabled
            if (enableSpin && throwVelocity.magnitude > 2f)
            {
                Vector3 spinAxis = Vector3.Cross(throwVelocity.normalized, Vector3.up);
                _rigidbody.angularVelocity = spinAxis * throwVelocity.magnitude * 0.5f;
            }
        }

        _isThrown = throwVelocity.magnitude > 1f;

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} thrown with velocity {throwVelocity.magnitude:F2}");' : ''}

        if (_isThrown)
        {
            SendCustomNetworkEvent(VRC.Udon.Common.Interfaces.NetworkEventTarget.All, nameof(OnThrown));
        }
    }

    public void OnThrown()
    {
        // Network event when object is thrown
        // Can be overridden for custom effects
    }

    private void OnCollisionEnter(Collision collision)
    {
        if (_isThrown)
        {
            float impactForce = collision.relativeVelocity.magnitude;
            ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} impact with force {impactForce:F2}");' : ''}

            // Reset thrown state on significant impact
            if (impactForce > 2f)
            {
                _isThrown = false;
            }
        }
    }
}
`;
}

export default generateThrowable;
