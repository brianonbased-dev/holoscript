/**
 * @grabbable Trait Generator
 *
 * Converts HoloScript @grabbable trait to VRChat VRC_Pickup + UdonSharp.
 * This is the most commonly used VR interaction in VRChat.
 */

import type { HSPlusNode } from '../types.js';
import type {
  TraitMapping,
  ExportContext,
  UdonSharpScript,
  UdonSyncedVariable,
} from '../types.js';

/**
 * HoloScript @grabbable configuration
 */
interface GrabbableConfig {
  snap_to_hand?: boolean;
  two_handed?: boolean;
  haptic_on_grab?: number;
  grab_points?: [number, number, number][];
  preserve_rotation?: boolean;
  distance_grab?: boolean;
  max_grab_distance?: number;
}

/**
 * Generate VRChat mapping for @grabbable trait
 */
export function generateGrabbable(
  node: HSPlusNode,
  config: GrabbableConfig,
  context: ExportContext
): TraitMapping {
  const objectName = node.id || 'GrabbableObject';
  const scriptName = `${objectName}_Grabbable`;

  const syncedVariables: UdonSyncedVariable[] = [
    {
      name: 'isHeld',
      type: 'bool',
      syncMode: 'None',
      defaultValue: 'false',
    },
  ];

  // Add position sync if needed for networked grabbables
  if (context.config.optimization !== 'aggressive') {
    syncedVariables.push({
      name: 'syncedPosition',
      type: 'Vector3',
      syncMode: 'Smooth',
    });
  }

  const udonScript: UdonSharpScript = {
    name: scriptName,
    source: generateGrabbableUdonSharp(objectName, config, context),
    trait: 'grabbable',
    requiredComponents: ['VRC_Pickup', 'Rigidbody', 'Collider'],
    syncedVariables,
    networkEvents: ['OnPickup', 'OnDrop'],
    dependencies: [],
  };

  return {
    trait: 'grabbable',
    components: ['VRC_Pickup', 'VRC_ObjectSync', 'Rigidbody', 'BoxCollider'],
    udonScript,
    prefabModifications: {
      'VRC_Pickup': {
        allowTheft: true,
        pickupable: true,
        orientation: config.snap_to_hand ? 'Grip' : 'Any',
        autoHold: config.two_handed ? 'No' : 'AutoDetect',
        useText: 'Grab',
        proximity: config.max_grab_distance ?? 0.3,
      },
      'Rigidbody': {
        useGravity: true,
        isKinematic: false,
        mass: 1,
        drag: 0.5,
        angularDrag: 0.5,
      },
      'VRC_ObjectSync': {
        allowCollisionOwnershipTransfer: true,
      },
    },
    requiredFeatures: ['VRC_Pickup', 'VRC_ObjectSync', 'UdonBehaviour'],
  };
}

/**
 * Generate UdonSharp C# code for grabbable behavior
 */
function generateGrabbableUdonSharp(
  objectName: string,
  config: GrabbableConfig,
  context: ExportContext
): string {
  const className = `${objectName.replace(/[^a-zA-Z0-9]/g, '')}_Grabbable`;
  const hapticIntensity = config.haptic_on_grab ?? 0.5;
  const debug = context.config.debug;

  return `/*
 * Generated by @holoscript/vrchat-export
 * Original HoloScript: ${objectName} @grabbable
 *
 * This object can be picked up and moved in VR.
 * Try the full HoloScript experience at https://hololand.dev
 */

using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;

[UdonBehaviourSyncMode(BehaviourSyncMode.Continuous)]
public class ${className} : UdonSharpBehaviour
{
    [Header("HoloScript @grabbable Configuration")]
    [Tooltip("Snap object to hand orientation")]
    public bool snapToHand = ${config.snap_to_hand ?? false};

    [Tooltip("Require two hands to grab")]
    public bool twoHanded = ${config.two_handed ?? false};

    [Tooltip("Haptic feedback intensity (0-1)")]
    [Range(0f, 1f)]
    public float hapticIntensity = ${hapticIntensity}f;

    [Tooltip("Preserve rotation when grabbed")]
    public bool preserveRotation = ${config.preserve_rotation ?? false};

    [Tooltip("Allow grabbing from distance")]
    public bool distanceGrab = ${config.distance_grab ?? false};

    [Tooltip("Maximum grab distance")]
    public float maxGrabDistance = ${config.max_grab_distance ?? 2.0}f;

    // Synced state
    [UdonSynced] private bool _isHeld = false;
    [UdonSynced] private int _holdingPlayerId = -1;

    // Local state
    private VRC_Pickup _pickup;
    private Rigidbody _rigidbody;
    private Vector3 _originalPosition;
    private Quaternion _originalRotation;

    void Start()
    {
        _pickup = GetComponent<VRC_Pickup>();
        _rigidbody = GetComponent<Rigidbody>();
        _originalPosition = transform.position;
        _originalRotation = transform.rotation;
        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} @grabbable initialized");' : ''}
    }

    public override void OnPickup()
    {
        _isHeld = true;
        _holdingPlayerId = Networking.LocalPlayer.playerId;

        // Haptic feedback
        if (hapticIntensity > 0f)
        {
            var hand = _pickup.currentHand;
            if (hand == VRC_Pickup.PickupHand.Left)
            {
                Networking.LocalPlayer.PlayHapticEventInHand(
                    VRC_Pickup.PickupHand.Left,
                    hapticIntensity,
                    hapticIntensity,
                    0.1f
                );
            }
            else if (hand == VRC_Pickup.PickupHand.Right)
            {
                Networking.LocalPlayer.PlayHapticEventInHand(
                    VRC_Pickup.PickupHand.Right,
                    hapticIntensity,
                    hapticIntensity,
                    0.1f
                );
            }
        }

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} picked up by {Networking.LocalPlayer.displayName}");' : ''}
    }

    public override void OnDrop()
    {
        _isHeld = false;
        _holdingPlayerId = -1;

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} dropped");' : ''}
    }

    public override void OnPickupUseDown()
    {
        // Trigger pressed while holding - can be extended
        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} use triggered");' : ''}
        SendCustomNetworkEvent(VRC.Udon.Common.Interfaces.NetworkEventTarget.All, nameof(OnUseTriggered));
    }

    public void OnUseTriggered()
    {
        // Override this in derived behaviors for custom interactions
    }

    // Utility: Reset to original position
    public void ResetPosition()
    {
        if (!_isHeld)
        {
            transform.position = _originalPosition;
            transform.rotation = _originalRotation;
            if (_rigidbody != null)
            {
                _rigidbody.velocity = Vector3.zero;
                _rigidbody.angularVelocity = Vector3.zero;
            }
        }
    }

    // Utility: Check if local player is holding
    public bool IsLocalPlayerHolding()
    {
        return _isHeld && _holdingPlayerId == Networking.LocalPlayer.playerId;
    }
}
`;
}

export default generateGrabbable;
