/**
 * @rotatable Trait Generator
 *
 * Converts HoloScript @rotatable trait to VRChat rotation interaction.
 * Allows users to rotate objects with hand gestures or grabbed rotation.
 */

import type { HSPlusNode } from '../types.js';
import type {
  TraitMapping,
  ExportContext,
  UdonSharpScript,
  UdonSyncedVariable,
} from '../types.js';

interface RotatableConfig {
  axis?: 'x' | 'y' | 'z' | 'all';
  snap_angles?: number[];
  speed?: number;
}

export function generateRotatable(
  node: HSPlusNode,
  config: RotatableConfig,
  context: ExportContext
): TraitMapping {
  const objectName = node.id || 'RotatableObject';
  const scriptName = `${objectName}_Rotatable`;

  const syncedVariables: UdonSyncedVariable[] = [
    {
      name: 'syncedRotation',
      type: 'Quaternion',
      syncMode: 'Smooth',
    },
  ];

  const udonScript: UdonSharpScript = {
    name: scriptName,
    source: generateRotatableUdonSharp(objectName, config, context),
    trait: 'rotatable',
    requiredComponents: ['VRC_Pickup'],
    syncedVariables,
    networkEvents: ['OnRotationChanged'],
    dependencies: [],
  };

  return {
    trait: 'rotatable',
    components: ['VRC_Pickup', 'VRC_ObjectSync', 'BoxCollider'],
    udonScript,
    prefabModifications: {
      'VRC_Pickup': {
        allowTheft: true,
        pickupable: true,
        orientation: 'Any',
      },
    },
    requiredFeatures: ['VRC_Pickup', 'VRC_ObjectSync', 'UdonBehaviour'],
  };
}

function generateRotatableUdonSharp(
  objectName: string,
  config: RotatableConfig,
  context: ExportContext
): string {
  const className = `${objectName.replace(/[^a-zA-Z0-9]/g, '')}_Rotatable`;
  const axis = config.axis ?? 'all';
  const snapAngles = config.snap_angles ?? [];
  const hasSnapping = snapAngles.length > 0;
  const speed = config.speed ?? 1;
  const debug = context.config.debug;

  // Generate snap angles array
  const snapAnglesStr = snapAngles.length > 0
    ? `new float[] { ${snapAngles.join('f, ')}f }`
    : 'new float[0]';

  return `/*
 * Generated by @holoscript/vrchat-export
 * Original HoloScript: ${objectName} @rotatable
 *
 * This object can be rotated by the user.
 * Try the full HoloScript experience at https://hololand.dev
 */

using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;

[UdonBehaviourSyncMode(BehaviourSyncMode.Continuous)]
public class ${className} : UdonSharpBehaviour
{
    [Header("HoloScript @rotatable Configuration")]
    [Tooltip("Rotation axis constraint")]
    public string rotationAxis = "${axis}";

    [Tooltip("Rotation speed multiplier")]
    public float rotationSpeed = ${speed}f;

    [Tooltip("Snap to specific angles")]
    public float[] snapAngles = ${snapAnglesStr};

    [Tooltip("Enable angle snapping")]
    public bool enableSnapping = ${hasSnapping};

    // Synced state
    [UdonSynced] private Quaternion _syncedRotation;

    // Tracking
    private VRC_Pickup _pickup;
    private bool _isHeld = false;
    private Quaternion _grabStartRotation;
    private Quaternion _handStartRotation;

    void Start()
    {
        _pickup = GetComponent<VRC_Pickup>();
        _syncedRotation = transform.rotation;
        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} @rotatable initialized");' : ''}
    }

    public override void OnPickup()
    {
        _isHeld = true;
        _grabStartRotation = transform.rotation;

        // Get initial hand rotation
        VRCPlayerApi player = Networking.LocalPlayer;
        if (player != null)
        {
            var hand = _pickup.currentHand;
            if (hand == VRC_Pickup.PickupHand.Left)
            {
                _handStartRotation = player.GetTrackingData(VRCPlayerApi.TrackingDataType.LeftHand).rotation;
            }
            else
            {
                _handStartRotation = player.GetTrackingData(VRCPlayerApi.TrackingDataType.RightHand).rotation;
            }
        }

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} rotation grab started");' : ''}
    }

    public override void OnDrop()
    {
        _isHeld = false;

        // Snap to nearest angle if enabled
        if (enableSnapping && snapAngles.Length > 0)
        {
            SnapToNearestAngle();
        }

        _syncedRotation = transform.rotation;

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} rotation dropped");' : ''}
        SendCustomNetworkEvent(VRC.Udon.Common.Interfaces.NetworkEventTarget.All, nameof(OnRotationChanged));
    }

    void Update()
    {
        if (_isHeld && Networking.IsOwner(gameObject))
        {
            // Get current hand rotation delta
            VRCPlayerApi player = Networking.LocalPlayer;
            if (player != null)
            {
                Quaternion currentHandRotation;
                var hand = _pickup.currentHand;
                if (hand == VRC_Pickup.PickupHand.Left)
                {
                    currentHandRotation = player.GetTrackingData(VRCPlayerApi.TrackingDataType.LeftHand).rotation;
                }
                else
                {
                    currentHandRotation = player.GetTrackingData(VRCPlayerApi.TrackingDataType.RightHand).rotation;
                }

                // Calculate rotation delta
                Quaternion handDelta = currentHandRotation * Quaternion.Inverse(_handStartRotation);
                Vector3 euler = handDelta.eulerAngles;

                // Apply axis constraint
                if (rotationAxis == "x")
                {
                    euler.y = 0;
                    euler.z = 0;
                }
                else if (rotationAxis == "y")
                {
                    euler.x = 0;
                    euler.z = 0;
                }
                else if (rotationAxis == "z")
                {
                    euler.x = 0;
                    euler.y = 0;
                }

                // Apply rotation
                Quaternion constrainedDelta = Quaternion.Euler(euler);
                transform.rotation = Quaternion.Slerp(
                    transform.rotation,
                    constrainedDelta * _grabStartRotation,
                    Time.deltaTime * rotationSpeed * 10f
                );

                _syncedRotation = transform.rotation;
            }
        }
    }

    private void SnapToNearestAngle()
    {
        Vector3 euler = transform.rotation.eulerAngles;
        float currentAngle = 0f;

        // Get angle on constrained axis
        if (rotationAxis == "x") currentAngle = euler.x;
        else if (rotationAxis == "y") currentAngle = euler.y;
        else if (rotationAxis == "z") currentAngle = euler.z;
        else currentAngle = euler.y; // Default to Y for 'all'

        // Find nearest snap angle
        float nearestAngle = snapAngles[0];
        float minDist = Mathf.Abs(Mathf.DeltaAngle(currentAngle, nearestAngle));

        for (int i = 1; i < snapAngles.Length; i++)
        {
            float dist = Mathf.Abs(Mathf.DeltaAngle(currentAngle, snapAngles[i]));
            if (dist < minDist)
            {
                minDist = dist;
                nearestAngle = snapAngles[i];
            }
        }

        // Apply snapped rotation
        if (rotationAxis == "x") euler.x = nearestAngle;
        else if (rotationAxis == "y") euler.y = nearestAngle;
        else if (rotationAxis == "z") euler.z = nearestAngle;
        else euler.y = nearestAngle;

        transform.rotation = Quaternion.Euler(euler);

        ${debug ? 'Debug.Log($"[HoloScript] {gameObject.name} snapped to {nearestAngle} degrees");' : ''}
    }

    public override void OnDeserialization()
    {
        if (!_isHeld)
        {
            transform.rotation = _syncedRotation;
        }
    }

    public void OnRotationChanged()
    {
        // Network event when rotation changes
    }

    // Public API
    public void SetRotation(Quaternion rotation)
    {
        if (!Networking.IsOwner(gameObject))
        {
            Networking.SetOwner(Networking.LocalPlayer, gameObject);
        }
        transform.rotation = rotation;
        _syncedRotation = rotation;
    }

    public void RotateBy(float degrees)
    {
        Vector3 axis = Vector3.up;
        if (rotationAxis == "x") axis = Vector3.right;
        else if (rotationAxis == "z") axis = Vector3.forward;

        transform.Rotate(axis, degrees);
        _syncedRotation = transform.rotation;
    }
}
`;
}

export default generateRotatable;
