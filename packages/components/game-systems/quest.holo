composition "Quest System" {
  template "QuestManager" {
    geometry: "cube"
    scale: [0.01, 0.01, 0.01]
    transparent: true
    opacity: 0

    state {
      quests: {}
      activeQuests: []
      completedQuests: []
      failedQuests: []
      trackedQuestId: ""
      maxActiveQuests: 10
    }

    action registerQuest(questDef) {
      quest = {
        id: questDef.id,
        name: questDef.name,
        description: questDef.description,
        objectives: questDef.objectives,
        rewards: questDef.rewards || {},
        prerequisiteQuests: questDef.prerequisites || [],
        level: questDef.level || 1,
        status: "available",
        progress: {}
      }

      for (obj in quest.objectives) {
        quest.progress[obj.id] = {
          current: 0,
          target: obj.target,
          completed: false
        }
      }

      this.state.quests[quest.id] = quest
    }

    action acceptQuest(questId) {
      quest = this.state.quests[questId]
      if (!quest) { return false }

      if (quest.status != "available") {
        ui.toast("Quest not available")
        return false
      }

      if (this.state.activeQuests.length >= this.state.maxActiveQuests) {
        ui.toast("Quest log full!")
        return false
      }

      for (prereq in quest.prerequisiteQuests) {
        if (!this.state.completedQuests.includes(prereq)) {
          ui.toast("Prerequisites not met")
          return false
        }
      }

      quest.status = "active"
      this.state.activeQuests.push(questId)

      if (this.state.trackedQuestId == "") {
        this.state.trackedQuestId = questId
      }

      events.emit("quest_accepted", quest)
      ui.toast("Quest accepted: " + quest.name)
      audio.play("quest_accept.mp3")
      return true
    }

    action updateObjective(questId, objectiveId, amount) {
      quest = this.state.quests[questId]
      if (!quest || quest.status != "active") { return }

      progress = quest.progress[objectiveId]
      if (!progress || progress.completed) { return }

      progress.current = min(progress.current + amount, progress.target)

      if (progress.current >= progress.target) {
        progress.completed = true
        events.emit("objective_completed", { questId: questId, objectiveId: objectiveId })
        audio.play("objective_complete.mp3")
        ui.toast("Objective complete!")
      }

      allComplete = true
      for (objId in quest.progress) {
        if (!quest.progress[objId].completed) {
          allComplete = false
          break
        }
      }

      if (allComplete) {
        this.completeQuest(questId)
      }
    }

    action completeQuest(questId) {
      quest = this.state.quests[questId]
      if (!quest) { return }

      quest.status = "completed"
      idx = this.state.activeQuests.indexOf(questId)
      if (idx >= 0) {
        this.state.activeQuests.splice(idx, 1)
      }
      this.state.completedQuests.push(questId)

      if (quest.rewards.experience) {
        player.addExperience(quest.rewards.experience)
      }
      if (quest.rewards.gold) {
        player.inventory.addGold(quest.rewards.gold)
      }
      if (quest.rewards.items) {
        for (item in quest.rewards.items) {
          player.inventory.addItem(item)
        }
      }

      if (this.state.trackedQuestId == questId) {
        this.state.trackedQuestId = this.state.activeQuests[0] || ""
      }

      events.emit("quest_completed", quest)
      ui.showReward(quest.rewards)
      audio.play("quest_complete.mp3")
    }

    action abandonQuest(questId) {
      quest = this.state.quests[questId]
      if (!quest || quest.status != "active") { return }

      quest.status = "available"

      for (objId in quest.progress) {
        quest.progress[objId].current = 0
        quest.progress[objId].completed = false
      }

      idx = this.state.activeQuests.indexOf(questId)
      if (idx >= 0) {
        this.state.activeQuests.splice(idx, 1)
      }

      events.emit("quest_abandoned", quest)
      ui.toast("Quest abandoned: " + quest.name)
    }

    action failQuest(questId) {
      quest = this.state.quests[questId]
      if (!quest) { return }

      quest.status = "failed"
      idx = this.state.activeQuests.indexOf(questId)
      if (idx >= 0) {
        this.state.activeQuests.splice(idx, 1)
      }
      this.state.failedQuests.push(questId)

      events.emit("quest_failed", quest)
      ui.toast("Quest failed: " + quest.name)
      audio.play("quest_fail.mp3")
    }

    action trackQuest(questId) {
      if (this.state.activeQuests.includes(questId)) {
        this.state.trackedQuestId = questId
      }
    }

    action getQuestProgress(questId) {
      quest = this.state.quests[questId]
      if (!quest) { return null }
      return {
        name: quest.name,
        status: quest.status,
        progress: quest.progress
      }
    }
  }

  object "QuestSystem" using "QuestManager" {
    position: [0, 0, 0]
  }
}
