/**
 * Code generators for various target platforms.
 */

/**
 * Generate target-specific code from AST
 */
export function generateTargetCode(ast: any, target: string, verbose: boolean = false): string {
  const orbs = ast.orbs || [];
  const functions = ast.functions || [];
  
  switch (target) {
    case 'threejs':
      return generateThreeJS(orbs, functions, verbose);
    case 'unity':
      return generateUnity(orbs, functions, verbose);
    case 'vrchat':
      return generateVRChat(orbs, functions, verbose);
    case 'babylon':
      return generateBabylon(orbs, functions, verbose);
    case 'aframe':
      return generateAFrame(orbs, functions, verbose);
    case 'webxr':
      return generateWebXR(orbs, functions, verbose);
    case 'urdf':
      return generateURDF(orbs, functions, verbose);
    case 'sdf':
      return generateSDF(orbs, functions, verbose);
    case 'dtdl':
      return generateDTDL(orbs, functions, verbose);
    default:
      return generateThreeJS(orbs, functions, verbose);
  }
}

export function generateThreeJS(orbs: any[], functions: any[], verbose: boolean): string {
  let code = `// Generated by HoloScript Compiler
// Target: Three.js
import * as THREE from 'three';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();

renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const props = orb.properties || {};
    const traits = orb.traits || [];
    
    // Position handling (array or object)
    const pos = props.position;
    let px = 0, py = 0, pz = 0;
    if (Array.isArray(pos)) { [px, py, pz] = pos; }
    else if (pos) { px = pos.x || 0; py = pos.y || 0; pz = pos.z || 0; }
    
    // Scale handling
    const scale = props.scale;
    let sx = 1, sy = 1, sz = 1;
    if (Array.isArray(scale)) { [sx, sy, sz] = scale; }
    else if (scale) { sx = scale.x || 1; sy = scale.y || 1; sz = scale.z || 1; }

    const color = props.color || '#ffffff';
    const geometry = props.geometry || 'sphere';
    
    code += `// ${name}\n`;
    if (geometry === 'cube' || geometry === 'box') {
      code += `const ${name}_geometry = new THREE.BoxGeometry(${sx}, ${sy}, ${sz});\n`;
    } else {
      code += `const ${name}_geometry = new THREE.SphereGeometry(${sx/2}, 32, 32);\n`;
    }
    
    // Material
    const isGlowing = traits.some((t: any) => t.name === 'glowing' || t.name === 'emissive');
    if (isGlowing) {
      code += `const ${name}_material = new THREE.MeshStandardMaterial({ color: '${color}', emissive: '${color}', emissiveIntensity: 1.0 });\n`;
    } else {
      code += `const ${name}_material = new THREE.MeshStandardMaterial({ color: '${color}' });\n`;
    }
    
    code += `const ${name} = new THREE.Mesh(${name}_geometry, ${name}_material);\n`;
    code += `${name}.position.set(${px}, ${py}, ${pz});\n`;
    
    // Physics Placeholder
    const hasPhysics = traits.some((t: any) => t.name === 'physics' || t.name === 'rigid' || t.name === 'collidable');
    if (hasPhysics) {
      code += `// Physics enabled for ${name} (@physics)\n`;
    }
    
    code += `scene.add(${name});\n\n`;
  }

  code += `camera.position.set(0, 1.6, 5);\n\n`;

  // Logic Handlers
  if (functions.length > 0) {
    code += `// Logic Handlers\n`;
    for (const func of functions) {
      code += `function ${func.name}(...args) {\n`;
      code += `  console.log('[HoloScript] Triggered logic: ${func.name}', args);\n`;
      code += `}\n\n`;
    }
  }

  code += `function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
`;

  return code;
}

export function generateUnity(orbs: any[], functions: any[], verbose: boolean): string {
  let code = `// Generated by HoloScript Compiler
// Target: Unity C#
using UnityEngine;

public class HoloScriptScene : MonoBehaviour
{
    void Start()
    {
`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const pos = orb.properties?.position || { x: 0, y: 0, z: 0 };
    const traits = orb.traits || [];
    
    code += `        // Create ${name}
        GameObject ${name} = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        ${name}.name = "${name}";
        ${name}.transform.position = new Vector3(${pos.x || 0}f, ${pos.y || 0}f, ${pos.z || 0}f);

`;

    const hasPhysics = traits.some((t: any) => t.name === 'physics' || t.name === 'throwable' || t.name === 'grabbable');
    if (hasPhysics) {
      code += `        // Add Physics
        Rigidbody ${name}_rb = ${name}.AddComponent<Rigidbody>();
`;
    }

    for (const trait of traits) {
      code += `        // Trait: @${trait.name}\n`;
      if (trait.name === 'grabbable') {
        code += `        // XR Grab Interactable setup\n`;
        code += `        var ${name}_grabInteractable = ${name}.AddComponent<UnityEngine.XR.Interaction.Toolkit.XRGrabInteractable>();\n`;
        code += `        ${name}_grabInteractable.movementType = UnityEngine.XR.Interaction.Toolkit.XRBaseInteractable.MovementType.VelocityTracking;\n`;
      }
      if (trait.name === 'throwable') {
        code += `        // Configure for throwing\n`;
        code += `        ${name}_rb.useGravity = true;\n`;
        code += `        ${name}_rb.drag = 0.1f;\n`;
      }
      if (trait.name === 'collidable') {
        code += `        // Collider is added by CreatePrimitive, ensure trigger is off\n`;
        code += `        ${name}.GetComponent<Collider>().isTrigger = false;\n`;
      }
    }
    
    code += `\n`;
  }

  code += `    }\n}\n`;

  return code;
}

export function generateVRChat(orbs: any[], functions: any[], verbose: boolean): string {
  let code = `// Generated by HoloScript Compiler
// Target: VRChat Udon#
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;

public class HoloScriptWorld : UdonSharpBehaviour
{
    void Start()
    {
`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const pos = orb.properties?.position || { x: 0, y: 0, z: 0 };
    const traits = orb.traits || [];

    code += `        // Create ${name}
        GameObject ${name} = VRC.SDKBase.VRCInstantiate.Instantiate(VRC.SDKBase.VRC_SceneDescriptor.GetDefaultSpawnPoint()); // Placeholder for actual object creation
        ${name}.name = "${name}";
        ${name}.transform.position = new Vector3(${pos.x || 0}f, ${pos.y || 0}f, ${pos.z || 0}f);
        Debug.Log("[HoloScript] Initialized ${name}");

`;

    const hasPhysics = traits.some((t: any) => t.name === 'physics' || t.name === 'throwable' || t.name === 'grabbable');
    if (hasPhysics) {
      code += `        // Add Physics (Rigidbody)
        Rigidbody ${name}_rb = ${name}.AddComponent<Rigidbody>();
`;
    }

    for (const trait of traits) {
      code += `        // Trait: @${trait.name}\n`;
      if (trait.name === 'grabbable') {
        code += `        // VRC Pickup setup for grabbable objects\n`;
        code += `        VRC.SDK3.Components.VRCPickup ${name}_pickup = ${name}.AddComponent<VRC.SDK3.Components.VRCPickup>();\n`;
        code += `        ${name}_pickup.pickupable = true;\n`;
        code += `        ${name}_pickup.AutoHold = VRC.SDK3.Components.VRCPickup.AutoHoldMode.Yes;\n`;
      }
      if (trait.name === 'throwable') {
        code += `        // Configure VRCPickup for throwable behavior\n`;
        code += `        ${name}_pickup.allowManipulationWhenEquipped = true;\n`;
        code += `        ${name}_pickup.ThrowVelocityBoostScale = 1.5f;\n`;
        code += `        ${name}_rb.useGravity = true;\n`;
      }
      if (trait.name === 'collidable') {
        code += `        // Add collider for physical interactions\n`;
        code += `        ${name}.AddComponent<SphereCollider>();\n`;
      }
    }
    
    code += `\n`;
  }

  code += `    }\n}\n`;

  return code;
}

export function generateBabylon(orbs: any[], functions: any[], verbose: boolean): string {
  let code = `// Generated by HoloScript Compiler
// Target: Babylon.js
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const createScene = function () {
    const scene = new BABYLON.Scene(engine);
    const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 3, new BABYLON.Vector3(0, 0, 0), scene);
    camera.attachControl(canvas, true);
    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const pos = orb.properties?.position || { x: 0, y: 0, z: 0 };
    
    code += `    const ${name} = BABYLON.MeshBuilder.CreateSphere("${name}", {diameter: 1}, scene);
    ${name}.position = new BABYLON.Vector3(${pos.x || 0}, ${pos.y || 0}, ${pos.z || 0});

`;
  }

  code += `    return scene;
};

const scene = createScene();
engine.runRenderLoop(function () {
    scene.render();
});
`;

  return code;
}

export function generateAFrame(orbs: any[], functions: any[], verbose: boolean): string {
  let code = `<!-- Generated by HoloScript Compiler -->
<!-- Target: A-Frame -->
<!DOCTYPE html>
<html>
<head>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
</head>
<body>
    <a-scene shadow="type: pcfsoft">
`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const pos = orb.properties?.position || { x: 0, y: 0, z: 0 };
    const color = orb.properties?.color || '#EF2D5E';
    
    code += `        <a-sphere id="${name}" position="${pos.x || 0} ${pos.y || 0} ${pos.z || 0}" radius="0.5" color="${color}"></a-sphere>
`;
  }

  code += `        <a-sky color="#ECECEC"></a-sky>
    </a-scene>
</body>
</html>
`;

  return code;
}

export function generateWebXR(orbs: any[], functions: any[], verbose: boolean): string {
  let code = `// Generated by HoloScript Compiler
// Target: WebXR (Three.js + WebXR)
import * as THREE from 'three';
import { VRButton } from 'three/addons/webxr/VRButton.js';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });

renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const pos = orb.properties?.position || { x: 0, y: 0, z: 0 };
    const color = orb.properties?.color || '#ffffff';
    
    code += `const ${name} = new THREE.Mesh(
    new THREE.SphereGeometry(0.5, 32, 32),
    new THREE.MeshStandardMaterial({ color: '${color}' })
);
${name}.position.set(${pos.x || 0}, ${pos.y || 0}, ${pos.z || 0});
scene.add(${name});

`;
  }

  code += `const light = new THREE.HemisphericLight(0xffffff, 0x444444, 1);
scene.add(light);

camera.position.set(0, 1.6, 5);

renderer.setAnimationLoop(function () {
    renderer.render(scene, camera);
});
`;

  return code;
}

export function generateURDF(orbs: any[], functions: any[], verbose: boolean): string {
  // Generate URDF XML for ROS 2 / Gazebo robotics
  let xml = `<?xml version="1.0"?>
<!-- Generated by HoloScript Compiler -->
<!-- Target: URDF (Robot Description Format) -->
<robot name="holoscript_model">
`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const pos = orb.properties?.position || { x: 0, y: 0, z: 0 };
    const geometry = orb.properties?.geometry || 'sphere';
    const scale = orb.properties?.scale || { x: 1, y: 1, z: 1 };
    
    xml += `  <link name="${name}_link">
    <visual>
      <origin xyz="${pos.x || 0} ${pos.y || 0} ${pos.z || 0}"/>
      <geometry>`;
    
    if (geometry === 'cube' || geometry === 'box') {
      xml += `
        <box size="${scale.x || 1} ${scale.y || 1} ${scale.z || 1}"/>`;
    } else if (geometry === 'cylinder') {
      xml += `
        <cylinder radius="${(scale.x || 1) / 2}" length="${scale.y || 1}"/>`;
    } else {
      xml += `
        <sphere radius="${(scale.x || 1) / 2}"/>`;
    }
    
    xml += `
      </geometry>
    </visual>
  </link>

`;
  }

  xml += `</robot>
`;

  if (verbose) {
    console.log(`Generated URDF with ${orbs.length} links`);
  }

  return xml;
}

export function generateSDF(orbs: any[], functions: any[], verbose: boolean): string {
  // Generate SDF XML for Gazebo simulation
  let xml = `<?xml version="1.0"?>
<!-- Generated by HoloScript Compiler -->
<!-- Target: SDF (Simulation Description Format) -->
<sdf version="1.9">
  <world name="holoscript_world">
    <physics type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1</real_time_factor>
    </physics>
    
    <light name="sun" type="directional">
      <pose>0 0 10 0 0 0</pose>
      <diffuse>1 1 1 1</diffuse>
    </light>
    
    <model name="ground_plane">
      <static>true</static>
      <link name="ground">
        <collision name="collision">
          <geometry><plane><normal>0 0 1</normal></plane></geometry>
        </collision>
        <visual name="visual">
          <geometry><plane><normal>0 0 1</normal><size>100 100</size></plane></geometry>
        </visual>
      </link>
    </model>
`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const pos = orb.properties?.position || { x: 0, y: 0, z: 0 };
    const geometry = orb.properties?.geometry || 'sphere';
    const scale = orb.properties?.scale || { x: 1, y: 1, z: 1 };
    const isStatic = orb.traits?.includes('@static') || false;
    
    xml += `
    <model name="${name}">
      <static>${isStatic}</static>
      <pose>${pos.x || 0} ${pos.y || 0} ${pos.z || 0} 0 0 0</pose>
      <link name="${name}_link">
        <collision name="collision">
          <geometry>`;
    
    if (geometry === 'cube' || geometry === 'box') {
      xml += `<box><size>${scale.x || 1} ${scale.y || 1} ${scale.z || 1}</size></box>`;
    } else if (geometry === 'cylinder') {
      xml += `<cylinder><radius>${(scale.x || 1) / 2}</radius><length>${scale.y || 1}</length></cylinder>`;
    } else {
      xml += `<sphere><radius>${(scale.x || 1) / 2}</radius></sphere>`;
    }
    
    xml += `</geometry>
        </collision>
        <visual name="visual">
          <geometry>`;
    
    if (geometry === 'cube' || geometry === 'box') {
      xml += `<box><size>${scale.x || 1} ${scale.y || 1} ${scale.z || 1}</size></box>`;
    } else if (geometry === 'cylinder') {
      xml += `<cylinder><radius>${(scale.x || 1) / 2}</radius><length>${scale.y || 1}</length></cylinder>`;
    } else {
      xml += `<sphere><radius>${(scale.x || 1) / 2}</radius></sphere>`;
    }
    
    xml += `</geometry>
        </visual>
      </link>
    </model>`;
  }

  xml += `
  </world>
</sdf>
`;

  if (verbose) {
    console.log(`Generated SDF with ${orbs.length} models`);
  }

  return xml;
}

export function generateDTDL(orbs: any[], functions: any[], verbose: boolean): string {
  // Generate Azure Digital Twin Definition Language v3 models
  const models: any[] = [];
  
  for (const orb of orbs) {
    const name = orb.name || 'object';
    const properties: any[] = [];
    const telemetry: any[] = [];
    
    // Extract properties from orb
    if (orb.properties) {
      for (const [key, value] of Object.entries(orb.properties)) {
        if (key === 'position' || key === 'rotation') {
          properties.push({
            '@type': 'Property',
            name: key,
            schema: {
              '@type': 'Object',
              fields: [
                { name: 'x', schema: 'double' },
                { name: 'y', schema: 'double' },
                { name: 'z', schema: 'double' }
              ]
            }
          });
        } else if (typeof value === 'number') {
          properties.push({
            '@type': 'Property',
            name: key,
            schema: 'double'
          });
        } else if (typeof value === 'boolean') {
          properties.push({
            '@type': 'Property',
            name: key,
            schema: 'boolean'
          });
        } else if (typeof value === 'string') {
          properties.push({
            '@type': 'Property',
            name: key,
            schema: 'string'
          });
        }
      }
    }
    
    // Add telemetry for @networked objects
    if (orb.traits?.includes('@networked')) {
      telemetry.push({
        '@type': 'Telemetry',
        name: 'lastSyncTime',
        schema: 'dateTime'
      });
    }
    
    const model = {
      '@id': `dtmi:holoscript:${name};1`,
      '@type': 'Interface',
      '@context': 'dtmi:dtdl:context;3',
      displayName: name,
      contents: [...properties, ...telemetry]
    };
    
    models.push(model);
  }

  if (verbose) {
    console.log(`Generated DTDL with ${models.length} interfaces`);
  }

  return JSON.stringify(models, null, 2);
}
