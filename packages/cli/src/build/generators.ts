/**
 * Code generators for various target platforms.
 */

/**
 * Generate target-specific code from AST
 */
export function generateTargetCode(ast: any, target: string, verbose: boolean = false): string {
  const orbs = ast.orbs || [];
  const functions = ast.functions || [];
  
  switch (target) {
    case 'threejs':
      return generateThreeJS(orbs, functions, verbose);
    case 'unity':
      return generateUnity(orbs, functions, verbose);
    case 'vrchat':
      return generateVRChat(orbs, functions, verbose);
    case 'babylon':
      return generateBabylon(orbs, functions, verbose);
    case 'aframe':
      return generateAFrame(orbs, functions, verbose);
    case 'webxr':
      return generateWebXR(orbs, functions, verbose);
    case 'urdf':
      return generateURDF(orbs, functions, verbose);
    case 'sdf':
      return generateSDF(orbs, functions, verbose);
    case 'dtdl':
      return generateDTDL(orbs, functions, verbose);
    default:
      return generateThreeJS(orbs, functions, verbose);
  }
}

export function generateThreeJS(orbs: any[], functions: any[], verbose: boolean): string {
  let code = `// Generated by HoloScript Compiler
// Target: Three.js
import * as THREE from 'three';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();

renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const props = orb.properties || {};
    const traits = orb.traits || [];
    
    // Position handling (array or object)
    const pos = props.position;
    let px = 0, py = 0, pz = 0;
    if (Array.isArray(pos)) { [px, py, pz] = pos; }
    else if (pos) { px = pos.x || 0; py = pos.y || 0; pz = pos.z || 0; }
    
    // Scale handling
    const scale = props.scale;
    let sx = 1, sy = 1, sz = 1;
    if (Array.isArray(scale)) { [sx, sy, sz] = scale; }
    else if (scale) { sx = scale.x || 1; sy = scale.y || 1; sz = scale.z || 1; }

    const color = props.color || '#ffffff';
    const geometry = props.geometry || 'sphere';
    
    code += `// ${name}\n`;
    if (geometry === 'cube' || geometry === 'box') {
      code += `const ${name}_geometry = new THREE.BoxGeometry(${sx}, ${sy}, ${sz});\n`;
    } else {
      code += `const ${name}_geometry = new THREE.SphereGeometry(${sx/2}, 32, 32);\n`;
    }
    
    // Material
    const isGlowing = traits.some((t: any) => t.name === 'glowing' || t.name === 'emissive');
    if (isGlowing) {
      code += `const ${name}_material = new THREE.MeshStandardMaterial({ color: '${color}', emissive: '${color}', emissiveIntensity: 1.0 });\n`;
    } else {
      code += `const ${name}_material = new THREE.MeshStandardMaterial({ color: '${color}' });\n`;
    }
    
    code += `const ${name} = new THREE.Mesh(${name}_geometry, ${name}_material);\n`;
    code += `${name}.position.set(${px}, ${py}, ${pz});\n`;
    
    // Physics Placeholder
    const hasPhysics = traits.some((t: any) => t.name === 'physics' || t.name === 'rigid' || t.name === 'collidable');
    if (hasPhysics) {
      code += `// Physics enabled for ${name} (@physics)\n`;
    }
    
    code += `scene.add(${name});\n\n`;
  }

  code += `camera.position.set(0, 1.6, 5);\n\n`;

  // Logic Handlers
  if (functions.length > 0) {
    code += `// Logic Handlers\n`;
    for (const func of functions) {
      code += `function ${func.name}(...args) {\n`;
      code += `  console.log('[HoloScript] Triggered logic: ${func.name}', args);\n`;
      code += `}\n\n`;
    }
  }

  code += `function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
`;

  return code;
}

export function generateUnity(orbs: any[], functions: any[], verbose: boolean): string {
  let code = `// Generated by HoloScript Compiler
// Target: Unity C#
using UnityEngine;

public class HoloScriptScene : MonoBehaviour
{
    void Start()
    {
`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const pos = orb.properties?.position || { x: 0, y: 0, z: 0 };
    const traits = orb.traits || [];
    
    code += `        // Create ${name}
        GameObject ${name} = GameObject.CreatePrimitive(PrimitiveType.Sphere);
        ${name}.name = "${name}";
        ${name}.transform.position = new Vector3(${pos.x || 0}f, ${pos.y || 0}f, ${pos.z || 0}f);

`;

    const hasPhysics = traits.some((t: any) => t.name === 'physics' || t.name === 'throwable' || t.name === 'grabbable');
    if (hasPhysics) {
      code += `        // Add Physics
        Rigidbody ${name}_rb = ${name}.AddComponent<Rigidbody>();
`;
    }

    for (const trait of traits) {
      code += `        // Trait: @${trait.name}\n`;
      if (trait.name === 'grabbable') {
        code += `        // XR Grab Interactable setup\n`;
        code += `        var ${name}_grabInteractable = ${name}.AddComponent<UnityEngine.XR.Interaction.Toolkit.XRGrabInteractable>();\n`;
        code += `        ${name}_grabInteractable.movementType = UnityEngine.XR.Interaction.Toolkit.XRBaseInteractable.MovementType.VelocityTracking;\n`;
      }
      if (trait.name === 'throwable') {
        code += `        // Configure for throwing\n`;
        code += `        ${name}_rb.useGravity = true;\n`;
        code += `        ${name}_rb.drag = 0.1f;\n`;
      }
      if (trait.name === 'collidable') {
        code += `        // Collider is added by CreatePrimitive, ensure trigger is off\n`;
        code += `        ${name}.GetComponent<Collider>().isTrigger = false;\n`;
      }
    }
    
    code += `\n`;
  }

  code += `    }\n}\n`;

  return code;
}

export function generateVRChat(orbs: any[], functions: any[], verbose: boolean): string {
  // Collect all trait names used to determine which Udon behaviors to generate
  const allTraitNames = new Set<string>();
  for (const orb of orbs) {
    for (const trait of (orb.traits || [])) {
      const traitName = typeof trait === 'string' ? trait : trait.name;
      if (traitName) allTraitNames.add(traitName);
    }
  }

  let code = `// Generated by HoloScript Compiler v3.0
// Target: VRChat UdonSharp
// Traits: ${[...allTraitNames].map(t => '@' + t).join(', ') || 'none'}
using UdonSharp;
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;

public class HoloScriptWorld : UdonSharpBehaviour
{
`;

  // Generate serialized fields for objects referenced from logic
  for (const orb of orbs) {
    const name = orb.name || 'object';
    code += `    [SerializeField] private GameObject ${name};\n`;
  }
  code += `\n`;

  // State variables from logic/state
  const stateVars = new Set<string>();
  for (const orb of orbs) {
    if (orb.state) {
      for (const [key, value] of Object.entries(orb.state)) {
        if (!stateVars.has(key)) {
          stateVars.add(key);
          const type = typeof value === 'number' ? 'float' : typeof value === 'boolean' ? 'bool' : 'string';
          code += `    [UdonSynced] private ${type} ${key} = ${JSON.stringify(value)};\n`;
        }
      }
    }
  }
  if (stateVars.size > 0) code += `\n`;

  code += `    void Start()
    {
`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const props = orb.properties || {};
    const traits: any[] = (orb.traits || []).map((t: any) =>
      typeof t === 'string' ? { name: t, config: {} } : t
    );

    // Position handling
    const pos = props.position;
    let px = 0, py = 0, pz = 0;
    if (Array.isArray(pos)) { [px, py, pz] = pos; }
    else if (pos) { px = pos.x || 0; py = pos.y || 0; pz = pos.z || 0; }

    // Scale handling
    const scale = props.scale;
    let sx = 1, sy = 1, sz = 1;
    if (Array.isArray(scale)) { [sx, sy, sz] = scale; }
    else if (scale) { sx = scale.x || 1; sy = scale.y || 1; sz = scale.z || 1; }

    // Rotation handling
    const rot = props.rotation;
    let rx = 0, ry = 0, rz = 0;
    if (Array.isArray(rot)) { [rx, ry, rz] = rot; }
    else if (rot) { rx = rot.x || 0; ry = rot.y || 0; rz = rot.z || 0; }

    const color = props.color || '#ffffff';
    const geometry = props.geometry || 'sphere';

    const hasTrait = (n: string) => traits.some((t: any) => t.name === n);
    const getConfig = (n: string) => traits.find((t: any) => t.name === n)?.config || {};

    code += `        // === ${name} ===\n`;

    // Create primitive based on geometry
    const primitiveType = geometry === 'cube' || geometry === 'box' ? 'Cube'
      : geometry === 'cylinder' ? 'Cylinder'
      : geometry === 'plane' ? 'Plane'
      : geometry === 'capsule' ? 'Capsule'
      : 'Sphere';

    code += `        if (${name} == null)\n`;
    code += `        {\n`;
    code += `            ${name} = GameObject.CreatePrimitive(PrimitiveType.${primitiveType});\n`;
    code += `            ${name}.name = "${name}";\n`;
    code += `        }\n`;
    code += `        ${name}.transform.position = new Vector3(${px}f, ${py}f, ${pz}f);\n`;
    code += `        ${name}.transform.localScale = new Vector3(${sx}f, ${sy}f, ${sz}f);\n`;
    if (rx !== 0 || ry !== 0 || rz !== 0) {
      code += `        ${name}.transform.rotation = Quaternion.Euler(${rx}f, ${ry}f, ${rz}f);\n`;
    }

    // Material / color
    code += `        var ${name}_renderer = ${name}.GetComponent<Renderer>();\n`;
    code += `        if (${name}_renderer != null)\n`;
    code += `        {\n`;
    code += `            ${name}_renderer.material.color = HexToColor("${color}");\n`;

    // Glowing trait - emissive material
    if (hasTrait('glowing')) {
      const cfg = getConfig('glowing');
      const intensity = cfg.intensity ?? 0.5;
      code += `            // @glowing\n`;
      code += `            ${name}_renderer.material.EnableKeyword("_EMISSION");\n`;
      code += `            ${name}_renderer.material.SetColor("_EmissionColor", HexToColor("${color}") * ${intensity}f);\n`;
    }

    // Transparent trait
    if (hasTrait('transparent')) {
      const cfg = getConfig('transparent');
      const opacity = cfg.opacity ?? 0.5;
      code += `            // @transparent\n`;
      code += `            ${name}_renderer.material.SetFloat("_Mode", 3); // Transparent mode\n`;
      code += `            Color ${name}_color = ${name}_renderer.material.color;\n`;
      code += `            ${name}_color.a = ${opacity}f;\n`;
      code += `            ${name}_renderer.material.color = ${name}_color;\n`;
    }

    code += `        }\n`;

    // Physics traits
    const hasPhysics = hasTrait('physics') || hasTrait('throwable') || hasTrait('grabbable') || hasTrait('gravity');
    if (hasPhysics) {
      const physCfg = getConfig('physics');
      const mass = physCfg.mass ?? 1;
      const drag = physCfg.drag ?? 0;
      const bounciness = physCfg.bounciness ?? 0;
      code += `        // Physics\n`;
      code += `        Rigidbody ${name}_rb = ${name}.GetComponent<Rigidbody>();\n`;
      code += `        if (${name}_rb == null) ${name}_rb = ${name}.AddComponent<Rigidbody>();\n`;
      code += `        ${name}_rb.mass = ${mass}f;\n`;
      code += `        ${name}_rb.drag = ${drag}f;\n`;
      if (bounciness > 0) {
        code += `        ${name}.GetComponent<Collider>().material = new PhysicMaterial { bounciness = ${bounciness}f, bounceCombine = PhysicMaterialCombine.Maximum };\n`;
      }
      if (!hasTrait('gravity')) {
        code += `        ${name}_rb.useGravity = false;\n`;
      }
    }

    // Grabbable trait - VRC Pickup
    if (hasTrait('grabbable')) {
      code += `        // @grabbable → VRC_Pickup\n`;
      code += `        var ${name}_pickup = ${name}.GetComponent<VRC.SDK3.Components.VRCPickup>();\n`;
      code += `        if (${name}_pickup == null) ${name}_pickup = ${name}.AddComponent<VRC.SDK3.Components.VRCPickup>();\n`;
      code += `        ${name}_pickup.pickupable = true;\n`;
      code += `        ${name}_pickup.AutoHold = VRC.SDK3.Components.VRCPickup.AutoHoldMode.Yes;\n`;
    }

    // Throwable trait
    if (hasTrait('throwable')) {
      const throwCfg = getConfig('throwable');
      const boostScale = throwCfg.velocityBoost ?? 1.5;
      code += `        // @throwable\n`;
      if (!hasTrait('grabbable')) {
        code += `        var ${name}_pickup = ${name}.AddComponent<VRC.SDK3.Components.VRCPickup>();\n`;
        code += `        ${name}_pickup.pickupable = true;\n`;
      }
      code += `        ${name}_pickup.allowManipulationWhenEquipped = true;\n`;
      code += `        ${name}_pickup.ThrowVelocityBoostScale = ${boostScale}f;\n`;
      code += `        ${name}_rb.useGravity = true;\n`;
    }

    // Collidable trait
    if (hasTrait('collidable')) {
      code += `        // @collidable\n`;
      code += `        if (${name}.GetComponent<Collider>() == null) ${name}.AddComponent<${primitiveType === 'Sphere' ? 'Sphere' : 'Box'}Collider>();\n`;
      code += `        ${name}.GetComponent<Collider>().isTrigger = false;\n`;
    }

    // Trigger trait - VRC trigger zone
    if (hasTrait('trigger')) {
      const trigCfg = getConfig('trigger');
      const radius = trigCfg.radius ?? 2;
      code += `        // @trigger\n`;
      code += `        var ${name}_triggerCollider = ${name}.AddComponent<SphereCollider>();\n`;
      code += `        ${name}_triggerCollider.isTrigger = true;\n`;
      code += `        ${name}_triggerCollider.radius = ${radius}f;\n`;
    }

    // Hoverable/Clickable - VRC Interact
    if (hasTrait('hoverable') || hasTrait('clickable')) {
      code += `        // @hoverable/@clickable → VRC Interact\n`;
      code += `        // Note: Implement OnInteract() in a separate UdonBehaviour for ${name}\n`;
    }

    // Spinning trait - requires Update loop
    if (hasTrait('spinning')) {
      const cfg = getConfig('spinning');
      const speed = cfg.speed ?? 1;
      const axis = cfg.axis || 'y';
      code += `        // @spinning (speed: ${speed}, axis: ${axis}) - handled in Update()\n`;
    }

    // Floating trait - requires Update loop
    if (hasTrait('floating')) {
      const cfg = getConfig('floating');
      code += `        // @floating (amplitude: ${cfg.amplitude ?? 0.2}, speed: ${cfg.speed ?? 1}) - handled in Update()\n`;
    }

    // Billboard trait
    if (hasTrait('billboard')) {
      code += `        // @billboard - handled in Update()\n`;
    }

    // Proximity trait
    if (hasTrait('proximity')) {
      const cfg = getConfig('proximity');
      const radius = cfg.radius ?? 3;
      code += `        // @proximity\n`;
      code += `        var ${name}_proxTrigger = ${name}.AddComponent<SphereCollider>();\n`;
      code += `        ${name}_proxTrigger.isTrigger = true;\n`;
      code += `        ${name}_proxTrigger.radius = ${radius}f;\n`;
    }

    // Networked trait
    if (hasTrait('networked')) {
      code += `        // @networked → VRC Object Sync\n`;
      code += `        if (${name}.GetComponent<VRC.SDK3.Components.VRCObjectSync>() == null)\n`;
      code += `            ${name}.AddComponent<VRC.SDK3.Components.VRCObjectSync>();\n`;
    }

    code += `\n`;
  }

  code += `        Debug.Log("[HoloScript] World initialized with ${orbs.length} objects");\n`;
  code += `    }\n\n`;

  // Generate Update() for animated traits
  const animatedOrbs = orbs.filter(orb => {
    const traits = (orb.traits || []).map((t: any) => typeof t === 'string' ? { name: t } : t);
    return traits.some((t: any) => ['spinning', 'floating', 'billboard', 'pulse'].includes(t.name));
  });

  if (animatedOrbs.length > 0) {
    code += `    void Update()\n`;
    code += `    {\n`;

    for (const orb of animatedOrbs) {
      const name = orb.name || 'object';
      const traits = (orb.traits || []).map((t: any) => typeof t === 'string' ? { name: t, config: {} } : t);
      const hasTrait = (n: string) => traits.some((t: any) => t.name === n);
      const getConfig = (n: string) => traits.find((t: any) => t.name === n)?.config || {};

      if (hasTrait('spinning')) {
        const cfg = getConfig('spinning');
        const speed = cfg.speed ?? 1;
        const axis = cfg.axis || 'y';
        const axisVec = axis === 'x' ? 'Vector3.right' : axis === 'z' ? 'Vector3.forward' : 'Vector3.up';
        code += `        // @spinning ${name}\n`;
        code += `        if (${name} != null) ${name}.transform.Rotate(${axisVec} * ${speed}f * Time.deltaTime * 57.2958f);\n`;
      }

      if (hasTrait('floating')) {
        const cfg = getConfig('floating');
        const amp = cfg.amplitude ?? 0.2;
        const speed = cfg.speed ?? 1;
        code += `        // @floating ${name}\n`;
        code += `        if (${name} != null)\n`;
        code += `        {\n`;
        code += `            Vector3 ${name}_pos = ${name}.transform.position;\n`;
        code += `            ${name}_pos.y += Mathf.Sin(Time.time * ${speed}f) * ${amp}f * Time.deltaTime;\n`;
        code += `            ${name}.transform.position = ${name}_pos;\n`;
        code += `        }\n`;
      }

      if (hasTrait('billboard')) {
        code += `        // @billboard ${name}\n`;
        code += `        if (${name} != null && Networking.LocalPlayer != null)\n`;
        code += `        {\n`;
        code += `            Vector3 lookDir = Networking.LocalPlayer.GetTrackingData(VRCPlayerApi.TrackingDataType.Head).position - ${name}.transform.position;\n`;
        code += `            lookDir.y = 0;\n`;
        code += `            if (lookDir.sqrMagnitude > 0.001f) ${name}.transform.rotation = Quaternion.LookRotation(lookDir);\n`;
        code += `        }\n`;
      }

      if (hasTrait('pulse')) {
        const cfg = getConfig('pulse');
        const min = cfg.minScale ?? 0.9;
        const max = cfg.maxScale ?? 1.1;
        const speed = cfg.speed ?? 2;
        code += `        // @pulse ${name}\n`;
        code += `        if (${name} != null)\n`;
        code += `        {\n`;
        code += `            float ${name}_scale = Mathf.Lerp(${min}f, ${max}f, (Mathf.Sin(Time.time * ${speed}f) + 1f) / 2f);\n`;
        code += `            ${name}.transform.localScale = Vector3.one * ${name}_scale;\n`;
        code += `        }\n`;
      }
    }

    code += `    }\n\n`;
  }

  // Generate VRChat-specific event handlers
  if (functions.length > 0) {
    for (const func of functions) {
      const name = func.name || func.event || 'handler';
      // Map common HoloScript events to VRChat events
      if (name === 'on_player_join' || name === 'onPlayerJoined') {
        code += `    public override void OnPlayerJoined(VRCPlayerApi player)\n`;
        code += `    {\n`;
        code += `        Debug.Log($"[HoloScript] Player joined: {player.displayName}");\n`;
        code += `    }\n\n`;
      } else if (name === 'on_player_leave' || name === 'onPlayerLeft') {
        code += `    public override void OnPlayerLeft(VRCPlayerApi player)\n`;
        code += `    {\n`;
        code += `        Debug.Log($"[HoloScript] Player left: {player.displayName}");\n`;
        code += `    }\n\n`;
      } else if (name === 'on_interact' || name === 'interact') {
        code += `    public override void Interact()\n`;
        code += `    {\n`;
        code += `        Debug.Log("[HoloScript] Interact triggered");\n`;
        code += `    }\n\n`;
      } else if (name === 'on_pickup' || name === 'onPickup') {
        code += `    public override void OnPickup()\n`;
        code += `    {\n`;
        code += `        Debug.Log("[HoloScript] Object picked up");\n`;
        code += `    }\n\n`;
      } else if (name === 'on_drop' || name === 'onDrop') {
        code += `    public override void OnDrop()\n`;
        code += `    {\n`;
        code += `        Debug.Log("[HoloScript] Object dropped");\n`;
        code += `    }\n\n`;
      } else {
        code += `    // Custom handler: ${name}\n`;
        code += `    public void _${name}()\n`;
        code += `    {\n`;
        code += `        Debug.Log("[HoloScript] Triggered: ${name}");\n`;
        code += `    }\n\n`;
      }
    }
  }

  // Utility function for color conversion
  code += `    private Color HexToColor(string hex)\n`;
  code += `    {\n`;
  code += `        hex = hex.TrimStart('#');\n`;
  code += `        if (hex.Length == 6)\n`;
  code += `        {\n`;
  code += `            float r = int.Parse(hex.Substring(0, 2), System.Globalization.NumberStyles.HexNumber) / 255f;\n`;
  code += `            float g = int.Parse(hex.Substring(2, 2), System.Globalization.NumberStyles.HexNumber) / 255f;\n`;
  code += `            float b = int.Parse(hex.Substring(4, 2), System.Globalization.NumberStyles.HexNumber) / 255f;\n`;
  code += `            return new Color(r, g, b);\n`;
  code += `        }\n`;
  code += `        return Color.white;\n`;
  code += `    }\n`;
  code += `}\n`;

  if (verbose) {
    console.log(`Generated VRChat UdonSharp with ${orbs.length} objects, ${allTraitNames.size} trait types`);
  }

  return code;
}

export function generateBabylon(orbs: any[], functions: any[], verbose: boolean): string {
  let code = `// Generated by HoloScript Compiler
// Target: Babylon.js
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const createScene = function () {
    const scene = new BABYLON.Scene(engine);
    const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 3, new BABYLON.Vector3(0, 0, 0), scene);
    camera.attachControl(canvas, true);
    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const pos = orb.properties?.position || { x: 0, y: 0, z: 0 };
    
    code += `    const ${name} = BABYLON.MeshBuilder.CreateSphere("${name}", {diameter: 1}, scene);
    ${name}.position = new BABYLON.Vector3(${pos.x || 0}, ${pos.y || 0}, ${pos.z || 0});

`;
  }

  code += `    return scene;
};

const scene = createScene();
engine.runRenderLoop(function () {
    scene.render();
});
`;

  return code;
}

export function generateAFrame(orbs: any[], functions: any[], verbose: boolean): string {
  let code = `<!-- Generated by HoloScript Compiler -->
<!-- Target: A-Frame -->
<!DOCTYPE html>
<html>
<head>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
</head>
<body>
    <a-scene shadow="type: pcfsoft">
`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const pos = orb.properties?.position || { x: 0, y: 0, z: 0 };
    const color = orb.properties?.color || '#EF2D5E';
    
    code += `        <a-sphere id="${name}" position="${pos.x || 0} ${pos.y || 0} ${pos.z || 0}" radius="0.5" color="${color}"></a-sphere>
`;
  }

  code += `        <a-sky color="#ECECEC"></a-sky>
    </a-scene>
</body>
</html>
`;

  return code;
}

export function generateWebXR(orbs: any[], functions: any[], verbose: boolean): string {
  let code = `// Generated by HoloScript Compiler
// Target: WebXR (Three.js + WebXR)
import * as THREE from 'three';
import { VRButton } from 'three/addons/webxr/VRButton.js';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });

renderer.setSize(window.innerWidth, window.innerHeight);
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const pos = orb.properties?.position || { x: 0, y: 0, z: 0 };
    const color = orb.properties?.color || '#ffffff';
    
    code += `const ${name} = new THREE.Mesh(
    new THREE.SphereGeometry(0.5, 32, 32),
    new THREE.MeshStandardMaterial({ color: '${color}' })
);
${name}.position.set(${pos.x || 0}, ${pos.y || 0}, ${pos.z || 0});
scene.add(${name});

`;
  }

  code += `const light = new THREE.HemisphericLight(0xffffff, 0x444444, 1);
scene.add(light);

camera.position.set(0, 1.6, 5);

renderer.setAnimationLoop(function () {
    renderer.render(scene, camera);
});
`;

  return code;
}

export function generateURDF(orbs: any[], functions: any[], verbose: boolean): string {
  // Generate URDF XML for ROS 2 / Gazebo robotics
  let xml = `<?xml version="1.0"?>
<!-- Generated by HoloScript Compiler -->
<!-- Target: URDF (Robot Description Format) -->
<robot name="holoscript_model">
`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const pos = orb.properties?.position || { x: 0, y: 0, z: 0 };
    const geometry = orb.properties?.geometry || 'sphere';
    const scale = orb.properties?.scale || { x: 1, y: 1, z: 1 };
    
    xml += `  <link name="${name}_link">
    <visual>
      <origin xyz="${pos.x || 0} ${pos.y || 0} ${pos.z || 0}"/>
      <geometry>`;
    
    if (geometry === 'cube' || geometry === 'box') {
      xml += `
        <box size="${scale.x || 1} ${scale.y || 1} ${scale.z || 1}"/>`;
    } else if (geometry === 'cylinder') {
      xml += `
        <cylinder radius="${(scale.x || 1) / 2}" length="${scale.y || 1}"/>`;
    } else {
      xml += `
        <sphere radius="${(scale.x || 1) / 2}"/>`;
    }
    
    xml += `
      </geometry>
    </visual>
  </link>

`;
  }

  xml += `</robot>
`;

  if (verbose) {
    console.log(`Generated URDF with ${orbs.length} links`);
  }

  return xml;
}

export function generateSDF(orbs: any[], functions: any[], verbose: boolean): string {
  // Generate SDF XML for Gazebo simulation
  let xml = `<?xml version="1.0"?>
<!-- Generated by HoloScript Compiler -->
<!-- Target: SDF (Simulation Description Format) -->
<sdf version="1.9">
  <world name="holoscript_world">
    <physics type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1</real_time_factor>
    </physics>
    
    <light name="sun" type="directional">
      <pose>0 0 10 0 0 0</pose>
      <diffuse>1 1 1 1</diffuse>
    </light>
    
    <model name="ground_plane">
      <static>true</static>
      <link name="ground">
        <collision name="collision">
          <geometry><plane><normal>0 0 1</normal></plane></geometry>
        </collision>
        <visual name="visual">
          <geometry><plane><normal>0 0 1</normal><size>100 100</size></plane></geometry>
        </visual>
      </link>
    </model>
`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const pos = orb.properties?.position || { x: 0, y: 0, z: 0 };
    const geometry = orb.properties?.geometry || 'sphere';
    const scale = orb.properties?.scale || { x: 1, y: 1, z: 1 };
    const isStatic = orb.traits?.includes('@static') || false;
    
    xml += `
    <model name="${name}">
      <static>${isStatic}</static>
      <pose>${pos.x || 0} ${pos.y || 0} ${pos.z || 0} 0 0 0</pose>
      <link name="${name}_link">
        <collision name="collision">
          <geometry>`;
    
    if (geometry === 'cube' || geometry === 'box') {
      xml += `<box><size>${scale.x || 1} ${scale.y || 1} ${scale.z || 1}</size></box>`;
    } else if (geometry === 'cylinder') {
      xml += `<cylinder><radius>${(scale.x || 1) / 2}</radius><length>${scale.y || 1}</length></cylinder>`;
    } else {
      xml += `<sphere><radius>${(scale.x || 1) / 2}</radius></sphere>`;
    }
    
    xml += `</geometry>
        </collision>
        <visual name="visual">
          <geometry>`;
    
    if (geometry === 'cube' || geometry === 'box') {
      xml += `<box><size>${scale.x || 1} ${scale.y || 1} ${scale.z || 1}</size></box>`;
    } else if (geometry === 'cylinder') {
      xml += `<cylinder><radius>${(scale.x || 1) / 2}</radius><length>${scale.y || 1}</length></cylinder>`;
    } else {
      xml += `<sphere><radius>${(scale.x || 1) / 2}</radius></sphere>`;
    }
    
    xml += `</geometry>
        </visual>
      </link>
    </model>`;
  }

  xml += `
  </world>
</sdf>
`;

  if (verbose) {
    console.log(`Generated SDF with ${orbs.length} models`);
  }

  return xml;
}

export function generateDTDL(orbs: any[], functions: any[], verbose: boolean): string {
  // Generate Azure Digital Twin Definition Language v3 models
  const models: any[] = [];
  
  for (const orb of orbs) {
    const name = orb.name || 'object';
    const properties: any[] = [];
    const telemetry: any[] = [];
    
    // Extract properties from orb
    if (orb.properties) {
      for (const [key, value] of Object.entries(orb.properties)) {
        if (key === 'position' || key === 'rotation') {
          properties.push({
            '@type': 'Property',
            name: key,
            schema: {
              '@type': 'Object',
              fields: [
                { name: 'x', schema: 'double' },
                { name: 'y', schema: 'double' },
                { name: 'z', schema: 'double' }
              ]
            }
          });
        } else if (typeof value === 'number') {
          properties.push({
            '@type': 'Property',
            name: key,
            schema: 'double'
          });
        } else if (typeof value === 'boolean') {
          properties.push({
            '@type': 'Property',
            name: key,
            schema: 'boolean'
          });
        } else if (typeof value === 'string') {
          properties.push({
            '@type': 'Property',
            name: key,
            schema: 'string'
          });
        }
      }
    }
    
    // Add telemetry for @networked objects
    if (orb.traits?.includes('@networked')) {
      telemetry.push({
        '@type': 'Telemetry',
        name: 'lastSyncTime',
        schema: 'dateTime'
      });
    }
    
    const model = {
      '@id': `dtmi:holoscript:${name};1`,
      '@type': 'Interface',
      '@context': 'dtmi:dtdl:context;3',
      displayName: name,
      contents: [...properties, ...telemetry]
    };
    
    models.push(model);
  }

  if (verbose) {
    console.log(`Generated DTDL with ${models.length} interfaces`);
  }

  return JSON.stringify(models, null, 2);
}
