import { VisualTestRunner, VisualTestConfig } from './VisualTestRunner';
import { HoloCompositionParser } from '@holoscript/core';
import * as fs from 'fs';
import * as path from 'path';

// Note: generateTargetCode will need to be exported from @holoscript/cli
// For now, we'll implement a minimal version here to avoid cross-package build dependencies
function generateTargetCode(ast: any, _target: string): string {
  const orbs = ast.orbs || [];

  let code = `// Generated by HoloScript Compiler
// Target: Three.js
import * as THREE from 'three';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();

renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

`;

  for (const orb of orbs) {
    const name = orb.name || 'object';
    const props = orb.properties || {};
    const traits = orb.traits || [];

    const pos = props.position;
    let px = 0,
      py = 0,
      pz = 0;
    if (Array.isArray(pos)) {
      [px, py, pz] = pos;
    } else if (pos) {
      px = pos.x || 0;
      py = pos.y || 0;
      pz = pos.z || 0;
    }

    const color = props.color || '#ffffff';
    const _geometry = props.geometry || 'sphere';

    code += `// ${name}\n`;
    code += `const ${name}_geometry = new THREE.SphereGeometry(0.5, 32, 32);\n`;

    const isGlowing = traits.some((t: any) => t.name === 'glowing' || t.name === 'emissive');
    if (isGlowing) {
      code += `const ${name}_material = new THREE.MeshStandardMaterial({ color: '${color}', emissive: '${color}', emissiveIntensity: 1.0 });\n`;
    } else {
      code += `const ${name}_material = new THREE.MeshStandardMaterial({ color: '${color}' });\n`;
    }

    code += `const ${name} = new THREE.Mesh(${name}_geometry, ${name}_material);\n`;
    code += `${name}.position.set(${px}, ${py}, ${pz});\n`;
    code += `scene.add(${name});\n\n`;
  }

  code += `camera.position.set(0, 1.6, 5);\n\n`;
  code += `function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
`;

  return code;
}

export interface SceneTestOptions extends Partial<VisualTestConfig> {
  target?: string;
  outputPath?: string;
  baselineDir: string;
  diffDir: string;
}

export class SceneTester {
  private runner: VisualTestRunner;
  private parser: HoloCompositionParser;

  constructor(private options: SceneTestOptions) {
    this.runner = new VisualTestRunner(options);
    this.parser = new HoloCompositionParser();
  }

  async setup(): Promise<void> {
    await this.runner.launch();
  }

  async teardown(): Promise<void> {
    await this.runner.close();
  }

  /**
   * Tests a .holo file for rendering consistency
   */
  async testScene(holoPath: string, sceneId: string): Promise<boolean> {
    const content = fs.readFileSync(holoPath, 'utf-8');
    const result = this.parser.parse(content);

    if (!result.success) {
      throw new Error(
        `Failed to parse ${holoPath}: ${result.errors.map((e) => e.message).join(', ')}`
      );
    }

    // Map AST to Generator format (copied from cli.ts logic for now)
    const ast = {
      orbs:
        result.ast?.objects?.map((obj: any) => ({
          name: obj.name,
          properties: Object.fromEntries(obj.properties.map((p: any) => [p.key, p.value])),
          traits: obj.traits || [],
          state: obj.state,
        })) || [],
      functions: [
        ...(result.ast?.logic?.actions?.map((a: any) => ({ name: a.name })) || []),
        ...(result.ast?.logic?.handlers?.map((h: any) => ({ name: h.event })) || []),
      ],
    };

    const target = this.options.target || 'threejs';
    const generatedCode = generateTargetCode(ast, target);

    // Create a complete HTML page with Three.js from CDN for testing purposes
    const html = `
      <!DOCTYPE html>
      <html>
      <head>
        <title>Visual Test - ${sceneId}</title>
        <style>body { margin: 0; overflow: hidden; background: #000; }</style>
        <script type="importmap">
          {
            "imports": {
              "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
          }
        </script>
      </head>
      <body>
        <script type="module">
          ${generatedCode}
          
          // Add a signal when rendering has started
          window.HOLO_RENDERED = true;
        </script>
      </body>
      </html>
    `;

    const screenshot = await this.runner.renderScene(html);

    const baselinePath = path.join(this.options.baselineDir, `${sceneId}.png`);
    const diffPath = path.join(this.options.diffDir, `${sceneId}.diff.png`);

    return this.runner.compare(screenshot, baselinePath, diffPath);
  }
}
