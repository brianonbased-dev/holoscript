/**
 * Unreal Engine Export Adapter
 *
 * Generates C++ actors and Blueprints from HoloScript scenes.
 */

import type { SceneGraph, SceneNode } from '../runtime/types.js';

// ============================================================================
// Types
// ============================================================================

export interface UnrealExportConfig {
  /** Target Unreal Engine version */
  engineVersion: '5.2' | '5.3' | '5.4';
  /** Project name */
  projectName: string;
  /** Output directory */
  outputDir: string;
  /** Include VR support */
  vrSupport?: boolean;
  /** Use Blueprints only (no C++) */
  blueprintsOnly?: boolean;
  /** Module name for C++ */
  moduleName?: string;
}

export interface UnrealExportResult {
  /** C++ header files */
  headers: GeneratedFile[];
  /** C++ source files */
  sources: GeneratedFile[];
  /** Blueprint asset definitions */
  blueprints: GeneratedFile[];
  /** Level/Map file */
  level: GeneratedFile;
  /** Build configuration */
  buildCs: GeneratedFile;
}

export interface GeneratedFile {
  path: string;
  content: string;
  type: 'cpp' | 'h' | 'blueprint' | 'level' | 'build';
}

// ============================================================================
// Unreal Export Adapter
// ============================================================================

export class UnrealExportAdapter {
  private config: UnrealExportConfig;

  constructor(config: UnrealExportConfig) {
    this.config = {
      vrSupport: false,
      blueprintsOnly: false,
      moduleName: config.projectName,
      ...config,
    };
  }

  /**
   * Export scene graph to Unreal assets
   */
  export(scene: SceneGraph): UnrealExportResult {
    const headers: GeneratedFile[] = [];
    const sources: GeneratedFile[] = [];
    const blueprints: GeneratedFile[] = [];

    // Generate actors for each object
    for (const node of scene.objects) {
      if (!this.config.blueprintsOnly) {
        const header = this.generateHeader(node);
        headers.push(header);

        const source = this.generateSource(node);
        sources.push(source);
      }

      const blueprint = this.generateBlueprint(node);
      blueprints.push(blueprint);
    }

    // Generate level
    const level = this.generateLevel(scene);

    // Generate build.cs
    const buildCs = this.generateBuildCs();

    return {
      headers,
      sources,
      blueprints,
      level,
      buildCs,
    };
  }

  // --------------------------------
  // Header Generation
  // --------------------------------

  private generateHeader(node: SceneNode): GeneratedFile {
    const className = `AHS_${this.toPascalCase(node.name)}`;
    const components = this.mapTraitsToComponents(node.traits);

    const content = `// Generated by HoloScript Partner SDK
// Do not edit manually

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
${this.config.vrSupport ? '#include "VRGripInterface.h"' : ''}
${components.includes('UPhysicsComponent') ? '#include "PhysicsEngine/PhysicsHandleComponent.h"' : ''}
#include "${className}.generated.h"

/**
 * Generated from HoloScript object: ${node.name}
 */
UCLASS(Blueprintable)
class ${this.config.moduleName!.toUpperCase()}_API ${className} : public AActor${this.config.vrSupport && node.traits.includes('@grabbable') ? ', public IVRGripInterface' : ''}
{
    GENERATED_BODY()

public:
    ${className}();

protected:
    virtual void BeginPlay() override;
    virtual void Tick(float DeltaTime) override;

public:
    // HoloScript Properties
${this.generatePropertyDeclarations(node.properties)}

${this.generateTraitDeclarations(node.traits)}

private:
    // Components
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
    UStaticMeshComponent* MeshComponent;
${this.generateComponentDeclarations(components)}
};
`;

    return {
      path: `${this.config.outputDir}/Source/${this.config.moduleName}/${className}.h`,
      content,
      type: 'h',
    };
  }

  // --------------------------------
  // Source Generation
  // --------------------------------

  private generateSource(node: SceneNode): GeneratedFile {
    const className = `AHS_${this.toPascalCase(node.name)}`;

    const content = `// Generated by HoloScript Partner SDK

#include "${className}.h"
#include "Components/StaticMeshComponent.h"
#include "Engine/StaticMesh.h"

${className}::${className}()
{
    PrimaryActorTick.bCanEverTick = true;

    // Create mesh component
    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("MeshComponent"));
    RootComponent = MeshComponent;

${this.generateComponentInitialization(node)}

    // Set transform
    SetActorLocation(FVector(${node.position[0] * 100}, ${node.position[1] * 100}, ${node.position[2] * 100}));
    SetActorRotation(FRotator(${node.rotation[0]}, ${node.rotation[1]}, ${node.rotation[2]}));
    ${typeof node.scale === 'number' ? `SetActorScale3D(FVector(${node.scale}));` : `SetActorScale3D(FVector(${node.scale[0]}, ${node.scale[1]}, ${node.scale[2]}));`}
}

void ${className}::BeginPlay()
{
    Super::BeginPlay();

${this.generatePropertyInitialization(node.properties)}
}

void ${className}::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);
}

${this.generateTraitImplementations(className, node.traits)}
`;

    return {
      path: `${this.config.outputDir}/Source/${this.config.moduleName}/${className}.cpp`,
      content,
      type: 'cpp',
    };
  }

  // --------------------------------
  // Blueprint Generation
  // --------------------------------

  private generateBlueprint(node: SceneNode): GeneratedFile {
    const className = `BP_${this.toPascalCase(node.name)}`;

    const blueprintData = {
      objectType: 'Blueprint',
      name: className,
      parentClass: this.config.blueprintsOnly
        ? 'Actor'
        : `AHS_${this.toPascalCase(node.name)}`,
      components: [
        {
          type: 'SceneComponent',
          name: 'DefaultSceneRoot',
        },
        {
          type: 'StaticMeshComponent',
          name: 'Mesh',
          staticMesh: this.mapGeometryToMesh(node.type),
        },
        ...this.mapTraitsToBlueprintComponents(node.traits),
      ],
      variables: Object.entries(node.properties).map(([key, value]) => ({
        name: key,
        type: this.getUnrealType(value),
        defaultValue: value,
      })),
      eventGraph: this.generateEventGraph(node.traits),
    };

    return {
      path: `${this.config.outputDir}/Content/Blueprints/${className}.uasset.json`,
      content: JSON.stringify(blueprintData, null, 2),
      type: 'blueprint',
    };
  }

  // --------------------------------
  // Level Generation
  // --------------------------------

  private generateLevel(scene: SceneGraph): GeneratedFile {
    const levelData = {
      name: scene.name,
      worldSettings: {
        skyLight: {
          intensity: scene.environment.ambientLight ?? 0.5,
          skybox: scene.environment.skybox,
        },
        gravity: scene.environment.gravity
          ? [scene.environment.gravity.x, scene.environment.gravity.y, scene.environment.gravity.z]
          : [0, 0, -980],
        fog: scene.environment.fog,
      },
      actors: scene.objects.map((node) => ({
        blueprint: `BP_${this.toPascalCase(node.name)}`,
        transform: {
          location: [node.position[0] * 100, node.position[1] * 100, node.position[2] * 100],
          rotation: node.rotation,
          scale: node.scale,
        },
      })),
    };

    return {
      path: `${this.config.outputDir}/Content/Maps/${scene.name}.umap.json`,
      content: JSON.stringify(levelData, null, 2),
      type: 'level',
    };
  }

  // --------------------------------
  // Build.cs Generation
  // --------------------------------

  private generateBuildCs(): GeneratedFile {
    const content = `// Generated by HoloScript Partner SDK

using UnrealBuildTool;

public class ${this.config.moduleName} : ModuleRules
{
    public ${this.config.moduleName}(ReadOnlyTargetRules Target) : base(Target)
    {
        PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

        PublicDependencyModuleNames.AddRange(new string[] {
            "Core",
            "CoreUObject",
            "Engine",
            "InputCore"${this.config.vrSupport ? `,
            "HeadMountedDisplay",
            "OpenXRHMD"` : ''}
        });

        PrivateDependencyModuleNames.AddRange(new string[] {
            "PhysicsCore"
        });
    }
}
`;

    return {
      path: `${this.config.outputDir}/Source/${this.config.moduleName}/${this.config.moduleName}.Build.cs`,
      content,
      type: 'build',
    };
  }

  // --------------------------------
  // Helpers
  // --------------------------------

  private generatePropertyDeclarations(properties: Record<string, unknown>): string {
    const lines: string[] = [];

    for (const [key, value] of Object.entries(properties)) {
      const propType = this.getUnrealType(value);
      lines.push(
        `    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "HoloScript")
    ${propType} ${key};`
      );
    }

    return lines.join('\n\n');
  }

  private generateTraitDeclarations(traits: string[]): string {
    const decls: string[] = [];

    if (traits.includes('@grabbable')) {
      decls.push(`    // Grabbable trait
    UFUNCTION(BlueprintNativeEvent, Category = "HoloScript|Interaction")
    void OnGrabbed(AActor* GrabbingActor);

    UFUNCTION(BlueprintNativeEvent, Category = "HoloScript|Interaction")
    void OnReleased(AActor* ReleasingActor);`);
    }

    if (traits.includes('@collidable')) {
      decls.push(`    // Collidable trait
    UFUNCTION()
    void OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor,
               UPrimitiveComponent* OtherComp, FVector NormalImpulse,
               const FHitResult& Hit);`);
    }

    return decls.join('\n\n');
  }

  private generateComponentDeclarations(components: string[]): string {
    return components
      .map((c) => `    UPROPERTY(VisibleAnywhere)\n    ${c}* ${c.replace('U', '')}Component;`)
      .join('\n\n');
  }

  private generateComponentInitialization(node: SceneNode): string {
    const lines: string[] = [];

    if (node.traits.includes('@physics') || node.traits.includes('@collidable')) {
      lines.push('    MeshComponent->SetSimulatePhysics(true);');
    }

    if (node.traits.includes('@collidable')) {
      lines.push(
        '    MeshComponent->OnComponentHit.AddDynamic(this, &' +
          `AHS_${this.toPascalCase(node.name)}::OnHit);`
      );
    }

    return lines.join('\n');
  }

  private generatePropertyInitialization(properties: Record<string, unknown>): string {
    const lines: string[] = [];

    for (const [key, value] of Object.entries(properties)) {
      const unrealValue = this.getUnrealValue(value);
      lines.push(`    ${key} = ${unrealValue};`);
    }

    return lines.join('\n');
  }

  private generateTraitImplementations(className: string, traits: string[]): string {
    const impls: string[] = [];

    if (traits.includes('@grabbable')) {
      impls.push(`void ${className}::OnGrabbed_Implementation(AActor* GrabbingActor)
{
    UE_LOG(LogTemp, Log, TEXT("%s grabbed by %s"), *GetName(), *GrabbingActor->GetName());
}

void ${className}::OnReleased_Implementation(AActor* ReleasingActor)
{
    UE_LOG(LogTemp, Log, TEXT("%s released by %s"), *GetName(), *ReleasingActor->GetName());
}`);
    }

    if (traits.includes('@collidable')) {
      impls.push(`void ${className}::OnHit(UPrimitiveComponent* HitComponent, AActor* OtherActor,
                         UPrimitiveComponent* OtherComp, FVector NormalImpulse,
                         const FHitResult& Hit)
{
    UE_LOG(LogTemp, Log, TEXT("%s hit %s"), *GetName(), *OtherActor->GetName());
}`);
    }

    return impls.join('\n\n');
  }

  private generateEventGraph(traits: string[]): unknown[] {
    const events: unknown[] = [];

    if (traits.includes('@grabbable')) {
      events.push({
        event: 'OnGrabbed',
        nodes: [{ type: 'PrintString', message: 'Object grabbed' }],
      });
    }

    return events;
  }

  private mapTraitsToComponents(traits: string[]): string[] {
    const components: string[] = [];

    if (traits.includes('@physics')) {
      components.push('UPhysicsComponent');
    }
    if (traits.includes('@grabbable') && this.config.vrSupport) {
      components.push('UGrabComponent');
    }

    return components;
  }

  private mapTraitsToBlueprintComponents(traits: string[]): unknown[] {
    const components: unknown[] = [];

    if (traits.includes('@physics') || traits.includes('@collidable')) {
      components.push({
        type: 'BoxCollision',
        name: 'Collision',
        simulatePhysics: traits.includes('@physics'),
      });
    }

    if (traits.includes('@spatial_audio')) {
      components.push({
        type: 'AudioComponent',
        name: 'Audio',
        spatialize: true,
      });
    }

    return components;
  }

  private mapGeometryToMesh(type: string): string {
    const meshMap: Record<string, string> = {
      cube: '/Engine/BasicShapes/Cube.Cube',
      sphere: '/Engine/BasicShapes/Sphere.Sphere',
      cylinder: '/Engine/BasicShapes/Cylinder.Cylinder',
      cone: '/Engine/BasicShapes/Cone.Cone',
      plane: '/Engine/BasicShapes/Plane.Plane',
    };
    return meshMap[type] || '/Engine/BasicShapes/Cube.Cube';
  }

  private getUnrealType(value: unknown): string {
    if (typeof value === 'number') {
      return Number.isInteger(value) ? 'int32' : 'float';
    }
    if (typeof value === 'string') return 'FString';
    if (typeof value === 'boolean') return 'bool';
    if (Array.isArray(value)) {
      if (value.length === 3) return 'FVector';
      if (value.length === 4) return 'FVector4';
      return 'TArray<float>';
    }
    return 'UObject*';
  }

  private getUnrealValue(value: unknown): string {
    if (typeof value === 'number') {
      return Number.isInteger(value) ? String(value) : `${value}f`;
    }
    if (typeof value === 'string') return `TEXT("${value}")`;
    if (typeof value === 'boolean') return String(value);
    if (Array.isArray(value)) {
      if (value.length === 3) return `FVector(${value.join(', ')})`;
      return `{ ${value.join(', ')} }`;
    }
    return 'nullptr';
  }

  private toPascalCase(str: string): string {
    return str
      .replace(/[-_](.)/g, (_, c) => c.toUpperCase())
      .replace(/^(.)/, (c) => c.toUpperCase());
  }
}

/**
 * Create Unreal export adapter
 */
export function createUnrealAdapter(config: UnrealExportConfig): UnrealExportAdapter {
  return new UnrealExportAdapter(config);
}
