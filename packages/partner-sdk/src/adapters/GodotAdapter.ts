/**
 * Godot Engine Export Adapter
 *
 * Generates GDScript and scenes from HoloScript.
 */

import type { SceneGraph, SceneNode } from '../runtime/types.js';

// ============================================================================
// Types
// ============================================================================

export interface GodotExportConfig {
  /** Target Godot version */
  godotVersion: '4.0' | '4.1' | '4.2' | '4.3';
  /** Project name */
  projectName: string;
  /** Output directory */
  outputDir: string;
  /** Use GDScript (true) or C# (false) */
  useGDScript?: boolean;
  /** XR support (OpenXR) */
  xrSupport?: boolean;
}

export interface GodotExportResult {
  /** GDScript or C# files */
  scripts: GeneratedFile[];
  /** Scene (.tscn) files */
  scenes: GeneratedFile[];
  /** Resource files */
  resources: GeneratedFile[];
  /** Project configuration */
  projectGodot: GeneratedFile;
}

export interface GeneratedFile {
  path: string;
  content: string;
  type: 'gdscript' | 'csharp' | 'tscn' | 'tres' | 'godot';
}

// ============================================================================
// Godot Export Adapter
// ============================================================================

export class GodotExportAdapter {
  private config: GodotExportConfig;

  constructor(config: GodotExportConfig) {
    this.config = {
      useGDScript: true,
      xrSupport: false,
      ...config,
    };
  }

  /**
   * Export scene graph to Godot project
   */
  export(scene: SceneGraph): GodotExportResult {
    const scripts: GeneratedFile[] = [];
    const scenes: GeneratedFile[] = [];
    const resources: GeneratedFile[] = [];

    // Generate scripts for each object
    for (const node of scene.objects) {
      const script = this.config.useGDScript
        ? this.generateGDScript(node)
        : this.generateCSharpScript(node);
      scripts.push(script);
    }

    // Generate main scene
    const mainScene = this.generateScene(scene);
    scenes.push(mainScene);

    // Generate project.godot
    const projectGodot = this.generateProjectFile();

    return {
      scripts,
      scenes,
      resources,
      projectGodot,
    };
  }

  // --------------------------------
  // GDScript Generation
  // --------------------------------

  private generateGDScript(node: SceneNode): GeneratedFile {
    const className = this.toPascalCase(node.name);
    const baseClass = this.getBaseClass(node);

    const content = `# Generated by HoloScript Partner SDK
# ${node.name}

extends ${baseClass}
class_name ${className}

${this.generateGDScriptExports(node.properties)}

${this.generateGDScriptSignals(node.traits)}

func _ready() -> void:
    # Initialize position and rotation
    position = Vector3(${node.position.join(', ')})
    rotation_degrees = Vector3(${node.rotation.join(', ')})
    ${typeof node.scale === 'number' ? `scale = Vector3.ONE * ${node.scale}` : `scale = Vector3(${node.scale.join(', ')})`}
    
    _setup_traits()
    _initialize_properties()

func _setup_traits() -> void:
${this.generateGDScriptTraitSetup(node.traits)}

func _initialize_properties() -> void:
${this.generateGDScriptPropertyInit(node.properties)}

${this.generateGDScriptTraitMethods(node.traits)}
`;

    return {
      path: `${this.config.outputDir}/scripts/${className}.gd`,
      content,
      type: 'gdscript',
    };
  }

  private generateGDScriptExports(properties: Record<string, unknown>): string {
    const lines: string[] = [];

    for (const [key, value] of Object.entries(properties)) {
      const gdType = this.getGDScriptType(value);
      const defaultValue = this.getGDScriptValue(value);
      lines.push(`@export var ${key}: ${gdType} = ${defaultValue}`);
    }

    return lines.join('\n');
  }

  private generateGDScriptSignals(traits: string[]): string {
    const signals: string[] = [];

    if (traits.includes('@grabbable')) {
      signals.push('signal grabbed(by: Node3D)');
      signals.push('signal released(by: Node3D)');
    }

    if (traits.includes('@collidable')) {
      signals.push('signal collided(with_body: Node3D)');
    }

    if (traits.includes('@pointable')) {
      signals.push('signal pointed()');
      signals.push('signal point_entered()');
      signals.push('signal point_exited()');
    }

    return signals.join('\n');
  }

  private generateGDScriptTraitSetup(traits: string[]): string {
    const lines: string[] = [];

    if (traits.includes('@collidable')) {
      lines.push('    # Setup collision signals');
      lines.push('    if has_node("CollisionShape3D"):');
      lines.push('        body_entered.connect(_on_body_entered)');
    }

    if (traits.includes('@physics')) {
      lines.push('    # Enable physics');
      lines.push('    if self is RigidBody3D:');
      lines.push('        freeze = false');
    }

    if (lines.length === 0) {
      lines.push('    pass');
    }

    return lines.join('\n');
  }

  private generateGDScriptPropertyInit(properties: Record<string, unknown>): string {
    if (Object.keys(properties).length === 0) {
      return '    pass';
    }

    const lines: string[] = [];
    for (const key of Object.keys(properties)) {
      lines.push(`    # ${key} is set via export`);
    }
    return lines.join('\n');
  }

  private generateGDScriptTraitMethods(traits: string[]): string {
    const methods: string[] = [];

    if (traits.includes('@grabbable')) {
      methods.push(`
# Grabbable trait methods
func grab(grabber: Node3D) -> void:
    grabbed.emit(grabber)
    print("%s grabbed by %s" % [name, grabber.name])

func release(releaser: Node3D) -> void:
    released.emit(releaser)
    print("%s released by %s" % [name, releaser.name])
`);
    }

    if (traits.includes('@collidable')) {
      methods.push(`
# Collidable trait methods
func _on_body_entered(body: Node3D) -> void:
    collided.emit(body)
    print("%s collided with %s" % [name, body.name])
`);
    }

    if (traits.includes('@pointable')) {
      methods.push(`
# Pointable trait methods
func _on_ray_enter() -> void:
    point_entered.emit()

func _on_ray_exit() -> void:
    point_exited.emit()

func _on_ray_click() -> void:
    pointed.emit()
`);
    }

    return methods.join('\n');
  }

  // --------------------------------
  // C# Script Generation
  // --------------------------------

  private generateCSharpScript(node: SceneNode): GeneratedFile {
    const className = this.toPascalCase(node.name);
    const baseClass = this.getBaseClass(node);

    const content = `// Generated by HoloScript Partner SDK

using Godot;
using System;

namespace ${this.config.projectName}
{
    /// <summary>
    /// Generated from HoloScript object: ${node.name}
    /// </summary>
    public partial class ${className} : ${baseClass}
    {
${this.generateCSharpProperties(node.properties)}

${this.generateCSharpSignals(node.traits)}

        public override void _Ready()
        {
            Position = new Vector3(${node.position.join('f, ')}f);
            RotationDegrees = new Vector3(${node.rotation.join('f, ')}f);
            Scale = ${typeof node.scale === 'number' ? `Vector3.One * ${node.scale}f` : `new Vector3(${node.scale.join('f, ')}f)`};
            
            SetupTraits();
        }

        private void SetupTraits()
        {
${this.generateCSharpTraitSetup(node.traits)}
        }

${this.generateCSharpTraitMethods(node.traits)}
    }
}
`;

    return {
      path: `${this.config.outputDir}/scripts/${className}.cs`,
      content,
      type: 'csharp',
    };
  }

  private generateCSharpProperties(properties: Record<string, unknown>): string {
    const lines: string[] = [];

    for (const [key, value] of Object.entries(properties)) {
      const csType = this.getCSharpType(value);
      const defaultValue = this.getCSharpValue(value);
      const propName = this.toPascalCase(key);
      lines.push(`        [Export]
        public ${csType} ${propName} { get; set; } = ${defaultValue};`);
    }

    return lines.join('\n\n');
  }

  private generateCSharpSignals(traits: string[]): string {
    const signals: string[] = [];

    if (traits.includes('@grabbable')) {
      signals.push('        [Signal] public delegate void GrabbedEventHandler(Node3D by);');
      signals.push('        [Signal] public delegate void ReleasedEventHandler(Node3D by);');
    }

    if (traits.includes('@collidable')) {
      signals.push('        [Signal] public delegate void CollidedEventHandler(Node3D withBody);');
    }

    return signals.join('\n');
  }

  private generateCSharpTraitSetup(traits: string[]): string {
    const lines: string[] = [];

    if (traits.includes('@collidable')) {
      lines.push('            // Connect collision signals');
      lines.push('            BodyEntered += OnBodyEntered;');
    }

    if (lines.length === 0) {
      lines.push('            // No traits to setup');
    }

    return lines.join('\n');
  }

  private generateCSharpTraitMethods(node: string[]): string {
    const methods: string[] = [];

    if (node.includes('@grabbable')) {
      methods.push(`        public void Grab(Node3D grabber)
        {
            EmitSignal(SignalName.Grabbed, grabber);
            GD.Print($"{Name} grabbed by {grabber.Name}");
        }

        public void Release(Node3D releaser)
        {
            EmitSignal(SignalName.Released, releaser);
            GD.Print($"{Name} released by {releaser.Name}");
        }`);
    }

    if (node.includes('@collidable')) {
      methods.push(`        private void OnBodyEntered(Node3D body)
        {
            EmitSignal(SignalName.Collided, body);
            GD.Print($"{Name} collided with {body.Name}");
        }`);
    }

    return methods.join('\n\n');
  }

  // --------------------------------
  // Scene Generation
  // --------------------------------

  private generateScene(scene: SceneGraph): GeneratedFile {
    const nodes = scene.objects.map((node, idx) => this.generateSceneNode(node, idx + 1));
    const resources = scene.objects.map((node, idx) => this.generateSceneResource(node, idx + 1));

    const content = `[gd_scene load_steps=${scene.objects.length + 2} format=3 uid="uid://generated_scene"]

[ext_resource type="Environment" uid="uid://default_env" path="res://default_env.tres" id="1"]
${resources.join('\n')}

[node name="${scene.name}" type="Node3D"]

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = ExtResource("1")

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 0.866, 0.5, 0, -0.5, 0.866, 0, 10, 0)
light_energy = ${scene.environment.ambientLight ?? 1.0}

${nodes.join('\n\n')}
`;

    return {
      path: `${this.config.outputDir}/scenes/${scene.name}.tscn`,
      content,
      type: 'tscn',
    };
  }

  private generateSceneNode(node: SceneNode, idx: number): string {
    const _className = this.toPascalCase(node.name);
    const nodeType = this.getGodotNodeType(node);
    const meshType = this.mapGeometryToMesh(node.type);

    return `[node name="${node.name}" type="${nodeType}" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, ${node.position.join(', ')})
script = ExtResource("${idx + 1}")
${meshType ? `mesh = SubResource("${meshType}_${idx}")` : ''}
${this.generateNodeProperties(node.properties)}`;
  }

  private generateSceneResource(node: SceneNode, idx: number): string {
    const meshType = this.mapGeometryToMesh(node.type);
    if (!meshType) return '';

    const scriptPath = this.config.useGDScript
      ? `"res://scripts/${this.toPascalCase(node.name)}.gd"`
      : `"res://scripts/${this.toPascalCase(node.name)}.cs"`;

    return `[ext_resource type="Script" path=${scriptPath} id="${idx + 1}"]

[sub_resource type="${meshType}" id="${meshType}_${idx}"]`;
  }

  private generateNodeProperties(properties: Record<string, unknown>): string {
    const lines: string[] = [];

    for (const [key, value] of Object.entries(properties)) {
      const gdValue = this.getGDScriptValue(value);
      lines.push(`${key} = ${gdValue}`);
    }

    return lines.join('\n');
  }

  // --------------------------------
  // Project File Generation
  // --------------------------------

  private generateProjectFile(): GeneratedFile {
    const content = `; Generated by HoloScript Partner SDK
; Engine configuration file.

[application]

config/name="${this.config.projectName}"
run/main_scene="res://scenes/Main.tscn"
config/features=PackedStringArray("${this.config.godotVersion}", "Forward Plus")

[rendering]

renderer/rendering_method="forward_plus"
${this.config.xrSupport ? 'xr/enabled=true\nxr/openxr/enabled=true' : ''}

[dotnet]

project/assembly_name="${this.config.projectName}"
${!this.config.useGDScript ? 'project/solution_directory="."' : ''}
`;

    return {
      path: `${this.config.outputDir}/project.godot`,
      content,
      type: 'godot',
    };
  }

  // --------------------------------
  // Helpers
  // --------------------------------

  private getBaseClass(node: SceneNode): string {
    if (node.traits.includes('@physics')) return 'RigidBody3D';
    if (node.traits.includes('@collidable')) return 'CharacterBody3D';
    return 'Node3D';
  }

  private getGodotNodeType(node: SceneNode): string {
    if (node.traits.includes('@physics')) return 'RigidBody3D';
    if (node.traits.includes('@collidable')) return 'CharacterBody3D';
    return 'MeshInstance3D';
  }

  private mapGeometryToMesh(type: string): string {
    const meshMap: Record<string, string> = {
      cube: 'BoxMesh',
      sphere: 'SphereMesh',
      cylinder: 'CylinderMesh',
      capsule: 'CapsuleMesh',
      plane: 'PlaneMesh',
      torus: 'TorusMesh',
    };
    return meshMap[type] || '';
  }

  private getGDScriptType(value: unknown): string {
    if (typeof value === 'number') {
      return Number.isInteger(value) ? 'int' : 'float';
    }
    if (typeof value === 'string') return 'String';
    if (typeof value === 'boolean') return 'bool';
    if (Array.isArray(value)) {
      if (value.length === 3) return 'Vector3';
      if (value.length === 4) return 'Vector4';
      return 'Array';
    }
    return 'Variant';
  }

  private getGDScriptValue(value: unknown): string {
    if (typeof value === 'number') return String(value);
    if (typeof value === 'string') return `"${value}"`;
    if (typeof value === 'boolean') return String(value);
    if (Array.isArray(value)) {
      if (value.length === 3) return `Vector3(${value.join(', ')})`;
      if (value.length === 4) return `Vector4(${value.join(', ')})`;
      return `[${value.join(', ')}]`;
    }
    return 'null';
  }

  private getCSharpType(value: unknown): string {
    if (typeof value === 'number') {
      return Number.isInteger(value) ? 'int' : 'float';
    }
    if (typeof value === 'string') return 'string';
    if (typeof value === 'boolean') return 'bool';
    if (Array.isArray(value)) {
      if (value.length === 3) return 'Vector3';
      return 'float[]';
    }
    return 'object';
  }

  private getCSharpValue(value: unknown): string {
    if (typeof value === 'number') {
      return Number.isInteger(value) ? String(value) : `${value}f`;
    }
    if (typeof value === 'string') return `"${value}"`;
    if (typeof value === 'boolean') return String(value);
    if (Array.isArray(value)) {
      if (value.length === 3) return `new Vector3(${value.join('f, ')}f)`;
      return `new float[] { ${value.join('f, ')}f }`;
    }
    return 'null';
  }

  private toPascalCase(str: string): string {
    return str
      .replace(/[-_](.)/g, (_, c) => c.toUpperCase())
      .replace(/^(.)/, (c) => c.toUpperCase());
  }
}

/**
 * Create Godot export adapter
 */
export function createGodotAdapter(config: GodotExportConfig): GodotExportAdapter {
  return new GodotExportAdapter(config);
}
