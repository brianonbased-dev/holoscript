/**
 * HoloScript → URDF (Unified Robot Description Format) Compiler
 *
 * Exports HoloScript compositions to URDF XML format for ROS 2 / Gazebo
 * simulation and robot manipulation.
 *
 * Maps:
 *   - Objects → Links with visual/collision geometry
 *   - @physics → Inertial properties
 *   - @collidable → Collision geometry
 *   - Constraints → Joint definitions
 *   - @grabbable → Interaction hints (as custom tags)
 *
 * @version 1.0.0
 */

import type {
  HoloComposition,
  HoloObjectDecl,
  HoloSpatialGroup,
  HoloValue,
} from '../parser/HoloCompositionTypes';

export interface URDFCompilerOptions {
  /** Robot name for URDF */
  robotName?: string;
  /** Include visual meshes */
  includeVisual?: boolean;
  /** Include collision geometry */
  includeCollision?: boolean;
  /** Include inertial properties */
  includeInertial?: boolean;
  /** Default mass for objects without @physics */
  defaultMass?: number;
  /** Mesh export path prefix */
  meshPathPrefix?: string;
  /** Include custom HoloScript extensions as XML comments */
  includeHoloExtensions?: boolean;
}

export interface URDFLink {
  name: string;
  visual?: URDFGeometry;
  collision?: URDFGeometry;
  inertial?: URDFInertial;
  origin?: URDFOrigin;
}

export interface URDFGeometry {
  type: 'box' | 'sphere' | 'cylinder' | 'mesh';
  size?: [number, number, number];
  radius?: number;
  length?: number;
  filename?: string;
  color?: string;
}

export interface URDFInertial {
  mass: number;
  inertia: {
    ixx: number;
    ixy: number;
    ixz: number;
    iyy: number;
    iyz: number;
    izz: number;
  };
  origin?: URDFOrigin;
}

export interface URDFOrigin {
  xyz: [number, number, number];
  rpy: [number, number, number]; // roll, pitch, yaw
}

export interface URDFJoint {
  name: string;
  type: 'fixed' | 'revolute' | 'prismatic' | 'continuous' | 'floating' | 'planar';
  parent: string;
  child: string;
  origin?: URDFOrigin;
  axis?: [number, number, number];
  limits?: {
    lower: number;
    upper: number;
    effort: number;
    velocity: number;
  };
}

export class URDFCompiler {
  private options: Required<URDFCompilerOptions>;
  private lines: string[] = [];
  private indentLevel: number = 0;
  private links: URDFLink[] = [];
  private joints: URDFJoint[] = [];

  constructor(options: URDFCompilerOptions = {}) {
    this.options = {
      robotName: options.robotName || 'HoloScriptRobot',
      includeVisual: options.includeVisual ?? true,
      includeCollision: options.includeCollision ?? true,
      includeInertial: options.includeInertial ?? true,
      defaultMass: options.defaultMass ?? 1.0,
      meshPathPrefix: options.meshPathPrefix || 'package://meshes/',
      includeHoloExtensions: options.includeHoloExtensions ?? true,
    };
  }

  compile(composition: HoloComposition): string {
    this.lines = [];
    this.links = [];
    this.joints = [];
    this.indentLevel = 0;

    // Extract links and joints from composition
    this.extractFromComposition(composition);

    // Generate URDF XML
    this.emit('<?xml version="1.0"?>');
    this.emit(`<!-- Auto-generated by HoloScript URDFCompiler -->`);
    this.emit(`<!-- Source: composition "${composition.name}" -->`);
    this.emit('');
    this.emit(`<robot name="${this.escapeXml(this.options.robotName)}">`);
    this.indentLevel++;

    // Materials
    this.emitMaterials();

    // Links
    for (const link of this.links) {
      this.emitLink(link);
    }

    // Joints
    for (const joint of this.joints) {
      this.emitJoint(joint);
    }

    // HoloScript extensions as comments
    if (this.options.includeHoloExtensions) {
      this.emitHoloExtensions(composition);
    }

    this.indentLevel--;
    this.emit('</robot>');

    return this.lines.join('\n');
  }

  private extractFromComposition(composition: HoloComposition): void {
    // Create base link
    this.links.push({
      name: 'base_link',
      visual: undefined,
      collision: undefined,
      inertial: {
        mass: 0.001,
        inertia: { ixx: 0.001, ixy: 0, ixz: 0, iyy: 0.001, iyz: 0, izz: 0.001 },
      },
    });

    // Process objects
    if (composition.objects) {
      for (const obj of composition.objects) {
        this.processObject(obj, 'base_link');
      }
    }

    // Process spatial groups
    if (composition.spatialGroups) {
      for (const group of composition.spatialGroups) {
        this.processSpatialGroup(group, 'base_link');
      }
    }
  }

  private processObject(obj: HoloObjectDecl, parentLink: string): void {
    const linkName = this.sanitizeName(obj.name);
    const traits = obj.traits || [];
    const hasPhysics = traits.includes('physics') || traits.includes('rigid');
    const hasCollider = traits.includes('collidable') || traits.includes('trigger');

    // Get geometry
    const geometry = this.extractGeometry(obj);
    const position = this.extractPosition(obj);
    const rotation = this.extractRotation(obj);
    const color = this.extractColor(obj);

    // Create link
    const link: URDFLink = {
      name: linkName,
      origin: {
        xyz: position,
        rpy: rotation,
      },
    };

    if (this.options.includeVisual && geometry) {
      link.visual = { ...geometry, color };
    }

    if (this.options.includeCollision && (hasCollider || hasPhysics) && geometry) {
      link.collision = geometry;
    }

    if (this.options.includeInertial) {
      const mass = this.extractMass(obj) || this.options.defaultMass;
      link.inertial = this.calculateInertia(geometry, mass);
    }

    this.links.push(link);

    // Create joint to parent
    this.joints.push({
      name: `${parentLink}_to_${linkName}_joint`,
      type: 'fixed',
      parent: parentLink,
      child: linkName,
      origin: {
        xyz: position,
        rpy: rotation,
      },
    });
  }

  private processSpatialGroup(group: HoloSpatialGroup, parentLink: string): void {
    const groupLinkName = this.sanitizeName(group.name);

    // Create group link
    this.links.push({
      name: groupLinkName,
      inertial: {
        mass: 0.001,
        inertia: { ixx: 0.001, ixy: 0, ixz: 0, iyy: 0.001, iyz: 0, izz: 0.001 },
      },
    });

    // Joint to parent
    this.joints.push({
      name: `${parentLink}_to_${groupLinkName}_joint`,
      type: 'fixed',
      parent: parentLink,
      child: groupLinkName,
    });

    // Process objects in group
    if (group.objects) {
      for (const obj of group.objects) {
        this.processObject(obj, groupLinkName);
      }
    }
  }

  private extractGeometry(obj: HoloObjectDecl): URDFGeometry | undefined {
    const geometryProp = obj.properties.find(p => p.key === 'geometry');
    if (!geometryProp) return undefined;

    const geometryValue = this.getStringValue(geometryProp.value);
    const scale = this.extractScale(obj);

    switch (geometryValue) {
      case 'cube':
      case 'box':
        return { type: 'box', size: [scale, scale, scale] };
      case 'sphere':
        return { type: 'sphere', radius: scale / 2 };
      case 'cylinder':
        return { type: 'cylinder', radius: scale / 2, length: scale };
      case 'cone':
        // URDF doesn't have cone, approximate as cylinder
        return { type: 'cylinder', radius: scale / 2, length: scale };
      case 'plane':
        return { type: 'box', size: [scale, 0.01, scale] };
      default:
        // Custom mesh
        if (geometryValue.endsWith('.glb') || geometryValue.endsWith('.dae') || geometryValue.endsWith('.stl')) {
          const filename = geometryValue.replace('.glb', '.stl').replace('.dae', '.stl');
          return { 
            type: 'mesh', 
            filename: `${this.options.meshPathPrefix}${filename}` 
          };
        }
        return { type: 'box', size: [scale, scale, scale] };
    }
  }

  private extractPosition(obj: HoloObjectDecl): [number, number, number] {
    const posProp = obj.properties.find(p => p.key === 'position');
    if (posProp && Array.isArray(posProp.value)) {
      return [
        Number(posProp.value[0]) || 0,
        Number(posProp.value[1]) || 0,
        Number(posProp.value[2]) || 0,
      ];
    }
    return [0, 0, 0];
  }

  private extractRotation(obj: HoloObjectDecl): [number, number, number] {
    const rotProp = obj.properties.find(p => p.key === 'rotation');
    if (rotProp && Array.isArray(rotProp.value)) {
      // Convert degrees to radians
      return [
        (Number(rotProp.value[0]) || 0) * Math.PI / 180,
        (Number(rotProp.value[1]) || 0) * Math.PI / 180,
        (Number(rotProp.value[2]) || 0) * Math.PI / 180,
      ];
    }
    return [0, 0, 0];
  }

  private extractScale(obj: HoloObjectDecl): number {
    const scaleProp = obj.properties.find(p => p.key === 'scale');
    if (scaleProp) {
      if (typeof scaleProp.value === 'number') {
        return scaleProp.value;
      }
      if (Array.isArray(scaleProp.value)) {
        return Number(scaleProp.value[0]) || 1;
      }
    }
    return 1;
  }

  private extractColor(obj: HoloObjectDecl): string | undefined {
    const colorProp = obj.properties.find(p => p.key === 'color');
    return colorProp ? this.getStringValue(colorProp.value) : undefined;
  }

  private extractMass(obj: HoloObjectDecl): number | undefined {
    const physicsProp = obj.properties.find(p => p.key === 'physics');
    if (physicsProp && typeof physicsProp.value === 'object' && !Array.isArray(physicsProp.value)) {
      const massEntry = (physicsProp.value as Record<string, unknown>).mass;
      if (typeof massEntry === 'number') return massEntry;
    }
    return undefined;
  }

  private calculateInertia(geometry: URDFGeometry | undefined, mass: number): URDFInertial {
    // Default inertia for a 1m cube with given mass
    let ixx = mass * (1 + 1) / 12; // (w² + h²) / 12
    let iyy = mass * (1 + 1) / 12;
    let izz = mass * (1 + 1) / 12;

    if (geometry) {
      switch (geometry.type) {
        case 'box': {
          const [w, h, d] = geometry.size || [1, 1, 1];
          ixx = mass * (h * h + d * d) / 12;
          iyy = mass * (w * w + d * d) / 12;
          izz = mass * (w * w + h * h) / 12;
          break;
        }
        case 'sphere': {
          const r = geometry.radius || 0.5;
          ixx = iyy = izz = (2 / 5) * mass * r * r;
          break;
        }
        case 'cylinder': {
          const r = geometry.radius || 0.5;
          const l = geometry.length || 1;
          ixx = iyy = mass * (3 * r * r + l * l) / 12;
          izz = mass * r * r / 2;
          break;
        }
      }
    }

    return {
      mass,
      inertia: { ixx, ixy: 0, ixz: 0, iyy, iyz: 0, izz },
    };
  }

  private emitMaterials(): void {
    this.emit('<!-- Materials -->');
    this.emit('<material name="default">');
    this.indentLevel++;
    this.emit('<color rgba="0.8 0.8 0.8 1.0"/>');
    this.indentLevel--;
    this.emit('</material>');
    this.emit('');
  }

  private emitLink(link: URDFLink): void {
    this.emit(`<link name="${link.name}">`);
    this.indentLevel++;

    // Visual
    if (link.visual) {
      this.emit('<visual>');
      this.indentLevel++;
      if (link.origin) {
        this.emitOrigin(link.origin);
      }
      this.emitGeometry(link.visual);
      this.emit('<material name="default"/>');
      this.indentLevel--;
      this.emit('</visual>');
    }

    // Collision
    if (link.collision) {
      this.emit('<collision>');
      this.indentLevel++;
      if (link.origin) {
        this.emitOrigin(link.origin);
      }
      this.emitGeometry(link.collision);
      this.indentLevel--;
      this.emit('</collision>');
    }

    // Inertial
    if (link.inertial) {
      this.emit('<inertial>');
      this.indentLevel++;
      this.emit(`<mass value="${link.inertial.mass}"/>`);
      const i = link.inertial.inertia;
      this.emit(`<inertia ixx="${i.ixx.toFixed(6)}" ixy="${i.ixy}" ixz="${i.ixz}" iyy="${i.iyy.toFixed(6)}" iyz="${i.iyz}" izz="${i.izz.toFixed(6)}"/>`);
      this.indentLevel--;
      this.emit('</inertial>');
    }

    this.indentLevel--;
    this.emit('</link>');
    this.emit('');
  }

  private emitJoint(joint: URDFJoint): void {
    this.emit(`<joint name="${joint.name}" type="${joint.type}">`);
    this.indentLevel++;
    
    this.emit(`<parent link="${joint.parent}"/>`);
    this.emit(`<child link="${joint.child}"/>`);
    
    if (joint.origin) {
      this.emitOrigin(joint.origin);
    }
    
    if (joint.axis) {
      this.emit(`<axis xyz="${joint.axis.join(' ')}"/>`);
    }
    
    if (joint.limits) {
      this.emit(`<limit lower="${joint.limits.lower}" upper="${joint.limits.upper}" effort="${joint.limits.effort}" velocity="${joint.limits.velocity}"/>`);
    }
    
    this.indentLevel--;
    this.emit('</joint>');
    this.emit('');
  }

  private emitGeometry(geom: URDFGeometry): void {
    this.emit('<geometry>');
    this.indentLevel++;
    
    switch (geom.type) {
      case 'box':
        this.emit(`<box size="${(geom.size || [1, 1, 1]).join(' ')}"/>`);
        break;
      case 'sphere':
        this.emit(`<sphere radius="${geom.radius || 0.5}"/>`);
        break;
      case 'cylinder':
        this.emit(`<cylinder radius="${geom.radius || 0.5}" length="${geom.length || 1}"/>`);
        break;
      case 'mesh':
        this.emit(`<mesh filename="${geom.filename}"/>`);
        break;
    }
    
    this.indentLevel--;
    this.emit('</geometry>');
  }

  private emitOrigin(origin: URDFOrigin): void {
    this.emit(`<origin xyz="${origin.xyz.join(' ')}" rpy="${origin.rpy.map(v => v.toFixed(6)).join(' ')}"/>`);
  }

  private emitHoloExtensions(composition: HoloComposition): void {
    this.emit('');
    this.emit('<!-- HoloScript Extensions -->');
    this.emit(`<!-- Original composition: "${composition.name}" -->`);
    if (composition.environment?.skybox) {
      this.emit(`<!-- Environment skybox: ${composition.environment.skybox} -->`);
    }
    if (composition.templates && composition.templates.length > 0) {
      this.emit(`<!-- Templates: ${composition.templates.map(t => t.name).join(', ')} -->`);
    }
  }

  private emit(line: string): void {
    const indent = '  '.repeat(this.indentLevel);
    this.lines.push(indent + line);
  }

  private sanitizeName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();
  }

  private escapeXml(str: string): string {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }

  private getStringValue(value: HoloValue): string {
    if (typeof value === 'string') return value;
    if (typeof value === 'number') return String(value);
    if (typeof value === 'boolean') return String(value);
    return '';
  }
}

export default URDFCompiler;
