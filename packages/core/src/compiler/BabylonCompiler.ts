/**
 * HoloScript -> Babylon.js Compiler
 *
 * Translates a HoloComposition AST into Babylon.js TypeScript code.
 *
 * Emits:
 *   - Scene initialization with Engine
 *   - MeshBuilder calls for geometry
 *   - PBRMaterial setup
 *   - Light components (HemisphericLight, DirectionalLight, PointLight, SpotLight)
 *   - Camera setup (ArcRotateCamera, FreeCamera, XR)
 *   - Physics with Havok/Cannon
 *   - XR session setup
 *   - GUI for UI elements
 *   - Animation system
 *
 * @version 1.0.0
 */

import type {
  HoloComposition,
  HoloObjectDecl,
  HoloSpatialGroup,
  HoloLight,
  HoloEnvironment,
  HoloCamera,
  HoloTimeline,
  HoloAudio,
  HoloZone,
  HoloUI,
  HoloTransition,
  HoloEffects,
} from '../parser/HoloCompositionTypes';

export interface BabylonCompilerOptions {
  className?: string;
  useHavok?: boolean;
  enableXR?: boolean;
  indent?: string;
}

const SHAPE_TO_MESH: Record<string, string> = {
  sphere: 'CreateSphere',
  orb: 'CreateSphere',
  cube: 'CreateBox',
  box: 'CreateBox',
  cylinder: 'CreateCylinder',
  cone: 'CreateCylinder',
  pyramid: 'CreateCylinder',
  plane: 'CreateGround',
  ground: 'CreateGround',
  torus: 'CreateTorus',
  ring: 'CreateTorus',
  capsule: 'CreateCapsule',
  disc: 'CreateDisc',
};

export class BabylonCompiler {
  private options: Required<BabylonCompilerOptions>;
  private lines: string[] = [];
  private indentLevel: number = 0;

  constructor(options: BabylonCompilerOptions = {}) {
    this.options = {
      className: options.className || 'GeneratedScene',
      useHavok: options.useHavok ?? true,
      enableXR: options.enableXR ?? false,
      indent: options.indent || '  ',
    };
  }

  compile(composition: HoloComposition): string {
    this.lines = [];
    this.indentLevel = 0;

    this.emit('// Auto-generated by HoloScript BabylonCompiler');
    this.emit(`// Source: composition "${composition.name}"`);
    this.emit('');
    this.emitImports(composition);
    this.emit('');
    this.emit(`export class ${this.options.className} {`);
    this.indent();
    this.emit('private engine: BABYLON.Engine;');
    this.emit('private scene: BABYLON.Scene;');
    this.emit('private canvas: HTMLCanvasElement;');
    this.emit('');
    this.emit('constructor(canvas: HTMLCanvasElement) {');
    this.indent();
    this.emit('this.canvas = canvas;');
    this.emit(
      'this.engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });'
    );
    this.emit('this.scene = new BABYLON.Scene(this.engine);');
    this.dedent();
    this.emit('}');
    this.emit('');
    this.emit('async build(): Promise<void> {');
    this.indent();
    this.emitSceneSetup(composition);
    if (composition.environment) this.emitEnvironment(composition.environment);
    if (composition.lights?.length) {
      for (const light of composition.lights) this.emitLight(light);
    } else {
      this.emit(
        'const defaultLight = new BABYLON.HemisphericLight("defaultLight", new BABYLON.Vector3(0, 1, 0), this.scene);'
      );
      this.emit('defaultLight.intensity = 0.7;');
      this.emit('');
    }
    if (composition.camera) this.emitCamera(composition.camera);
    else {
      this.emit(
        'const camera = new BABYLON.ArcRotateCamera("defaultCamera", -Math.PI / 2, Math.PI / 3, 10, BABYLON.Vector3.Zero(), this.scene);'
      );
      this.emit('camera.attachControl(this.canvas, true);');
      this.emit('');
    }
    if (composition.objects?.length) for (const obj of composition.objects) this.emitObject(obj);
    if (composition.spatialGroups?.length)
      for (const g of composition.spatialGroups) this.emitGroup(g);
    if (composition.timelines?.length)
      for (const tl of composition.timelines) this.emitTimeline(tl);
    if (composition.audio?.length) for (const a of composition.audio) this.emitAudio(a);
    if (composition.zones?.length) for (const z of composition.zones) this.emitZone(z);
    if (composition.ui) this.emitUI(composition.ui);
    if (composition.effects) this.emitEffects(composition.effects);
    if (composition.transitions?.length)
      for (const t of composition.transitions) this.emitTransition(t);
    if (this.options.enableXR) this.emitXRSetup();
    this.emitRenderLoop();
    this.dedent();
    this.emit('}');
    this.emit('');
    this.emit('dispose(): void { this.scene.dispose(); this.engine.dispose(); }');
    this.dedent();
    this.emit('}');
    return this.lines.join('\n');
  }

  // --- Imports ---

  private emitImports(composition: HoloComposition): void {
    this.emit('import * as BABYLON from "@babylonjs/core";');
    if (composition.ui) this.emit('import * as GUI from "@babylonjs/gui";');
    if (this.options.useHavok) this.emit('import HavokPhysics from "@babylonjs/havok";');
    if (this.options.enableXR) this.emit('import "@babylonjs/loaders";');
  }

  // --- Scene Setup ---

  private emitSceneSetup(_composition: HoloComposition): void {
    this.emit('this.scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.1, 1);');
    if (this.options.useHavok) {
      this.emit('const havokInstance = await HavokPhysics();');
      this.emit('const havokPlugin = new BABYLON.HavokPlugin(true, havokInstance);');
      this.emit('this.scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), havokPlugin);');
    }
    this.emit('');
  }

  // --- Environment ---

  private emitEnvironment(env: HoloEnvironment): void {
    for (const prop of env.properties) {
      if (prop.key === 'skybox' || prop.key === 'preset') {
        this.emit(
          `const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 1000 }, this.scene);`
        );
        this.emit(`const skyMat = new BABYLON.StandardMaterial("skyMat", this.scene);`);
        this.emit(`skyMat.backFaceCulling = false;`);
        this.emit(
          `skyMat.reflectionTexture = new BABYLON.CubeTexture("textures/${prop.value}", this.scene);`
        );
        this.emit(`skyMat.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;`);
        this.emit(`skyMat.disableLighting = true;`);
        this.emit(`skybox.material = skyMat; skybox.infiniteDistance = true;`);
      } else if (prop.key === 'fog' && typeof prop.value === 'object') {
        const fog = prop.value as Record<string, any>;
        this.emit(`this.scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;`);
        if (fog.color) this.emit(`this.scene.fogColor = ${this.toBabylonColor3(fog.color)};`);
        if (fog.near !== undefined) this.emit(`this.scene.fogStart = ${fog.near};`);
        if (fog.far !== undefined) this.emit(`this.scene.fogEnd = ${fog.far};`);
      } else if (prop.key === 'ambient_light') {
        this.emit(
          `this.scene.ambientColor = new BABYLON.Color3(${prop.value}, ${prop.value}, ${prop.value});`
        );
      } else if (prop.key === 'ground') {
        this.emit(
          `const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 100, height: 100 }, this.scene);`
        );
        if (typeof prop.value === 'object' && prop.value !== null) {
          const g = prop.value as Record<string, any>;
          if (g.color) {
            this.emit(`const groundMat = new BABYLON.PBRMaterial("groundMat", this.scene);`);
            this.emit(
              `groundMat.albedoColor = ${this.toBabylonColor3(g.color)}; groundMat.roughness = 0.8;`
            );
            this.emit(`ground.material = groundMat;`);
          }
        }
        this.emit(`ground.receiveShadows = true;`);
      }
    }
    this.emit('');
  }

  // --- Objects ---

  private emitObject(obj: HoloObjectDecl, parentVar?: string): void {
    const v = this.sanitizeName(obj.name);
    let geom = 'cube',
      modelSrc: string | undefined,
      textContent: string | undefined;
    let position: any[] | undefined, rotation: any[] | undefined, scale: any, size: any;
    const mat: Record<string, any> = {};

    for (const p of obj.properties) {
      switch (p.key) {
        case 'geometry':
        case 'mesh':
        case 'type':
          if (typeof p.value === 'string') geom = p.value;
          break;
        case 'position':
          if (Array.isArray(p.value)) position = p.value;
          break;
        case 'rotation':
          if (Array.isArray(p.value)) rotation = p.value;
          break;
        case 'scale':
          scale = p.value;
          break;
        case 'size':
          size = p.value;
          break;
        case 'color':
          mat.color = p.value;
          break;
        case 'roughness':
          mat.roughness = p.value;
          break;
        case 'metalness':
        case 'metallic':
          mat.metalness = p.value;
          break;
        case 'opacity':
          mat.opacity = p.value;
          break;
        case 'emissive':
          mat.emissive = p.value;
          break;
        case 'emissive_intensity':
        case 'emissiveIntensity':
          mat.emissiveIntensity = p.value;
          break;
        case 'material':
          if (typeof p.value === 'object' && p.value !== null)
            Object.assign(mat, p.value as Record<string, any>);
          break;
        case 'model':
        case 'src':
          if (typeof p.value === 'string') modelSrc = p.value;
          break;
        case 'text':
          if (typeof p.value === 'string') textContent = p.value;
          break;
      }
    }

    this.emit(`// Object: ${obj.name}`);
    if (modelSrc) {
      this.emit(
        `const ${v} = await BABYLON.SceneLoader.ImportMeshAsync("", "${modelSrc}", "", this.scene);`
      );
    } else if (geom === 'text' || textContent) {
      this.emit(
        `const ${v} = BABYLON.MeshBuilder.CreatePlane("${obj.name}", { width: 2, height: 1 }, this.scene);`
      );
      this.emit(
        `const ${v}Tex = new BABYLON.DynamicTexture("${v}Tex", { width: 512, height: 256 }, this.scene);`
      );
      this.emit(
        `${v}Tex.drawText("${textContent || ''}", null, null, "bold 48px Arial", "#ffffff", "#00000000", true);`
      );
      this.emit(`const ${v}Mat = new BABYLON.StandardMaterial("${v}Mat", this.scene);`);
      this.emit(
        `${v}Mat.diffuseTexture = ${v}Tex; ${v}Mat.emissiveColor = BABYLON.Color3.White();`
      );
      this.emit(`${v}.material = ${v}Mat;`);
    } else {
      this.emit(
        `const ${v} = BABYLON.MeshBuilder.${this.mapShapeToMesh(geom)}("${obj.name}", ${this.meshBuilderOptions(geom, size)}, this.scene);`
      );
      if (Object.keys(mat).length > 0) {
        this.emit(`const ${v}Mat = new BABYLON.PBRMaterial("${v}Mat", this.scene);`);
        if (mat.color) this.emit(`${v}Mat.albedoColor = ${this.toBabylonColor3(mat.color)};`);
        if (mat.roughness !== undefined) this.emit(`${v}Mat.roughness = ${mat.roughness};`);
        if (mat.metalness !== undefined) this.emit(`${v}Mat.metallic = ${mat.metalness};`);
        if (mat.opacity !== undefined && mat.opacity < 1)
          this.emit(`${v}Mat.alpha = ${mat.opacity};`);
        if (mat.emissive)
          this.emit(`${v}Mat.emissiveColor = ${this.toBabylonColor3(mat.emissive)};`);
        if (mat.emissiveIntensity !== undefined)
          this.emit(`${v}Mat.emissiveIntensity = ${mat.emissiveIntensity};`);
        this.emit(`${v}.material = ${v}Mat;`);
      }
    }

    if (position) this.emit(`${v}.position = ${this.toBabylonVector(position)};`);
    if (rotation) this.emit(`${v}.rotation = ${this.toBabylonVector(rotation)};`);
    if (scale) {
      this.emit(
        Array.isArray(scale)
          ? `${v}.scaling = ${this.toBabylonVector(scale)};`
          : `${v}.scaling = new BABYLON.Vector3(${scale}, ${scale}, ${scale});`
      );
    }
    if (parentVar) this.emit(`${v}.parent = ${parentVar};`);

    // Traits
    for (const trait of obj.traits || []) {
      if (trait.name === 'grabbable') {
        this.emit(`${v}.actionManager = new BABYLON.ActionManager(this.scene);`);
        this.emit(
          `${v}.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, () => { console.log("Picked: ${obj.name}"); }));`
        );
      } else if (trait.name === 'physics' || trait.name === 'collidable') {
        const mt = (trait.config?.type || 'dynamic') === 'static' ? 'STATIC' : 'DYNAMIC';
        this.emit(
          `const ${v}Body = new BABYLON.PhysicsBody(${v}, BABYLON.PhysicsMotionType.${mt}, false, this.scene);`
        );
        this.emit(`${v}Body.shape = new BABYLON.PhysicsShapeConvexHull(${v}, this.scene);`);
        this.emit(`${v}Body.setMassProperties({ mass: ${trait.config?.mass ?? 1} });`);
      } else if (trait.name === 'gaussian_splat') {
        this.emit(`const ${v}PCS = new BABYLON.PointsCloudSystem("${v}PCS", 2, this.scene);`);
        this.emit(`${v}PCS.addPoints(10000); await ${v}PCS.buildMeshAsync();`);
      } else if (trait.name === 'shadow') {
        this.emit(`${v}.receiveShadows = true;`);
      } else if (trait.name === 'hoverable') {
        this.emit(
          `${v}.actionManager = ${v}.actionManager || new BABYLON.ActionManager(this.scene);`
        );
        this.emit(
          `${v}.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPointerOverTrigger, () => { ${v}.renderOverlay = true; ${v}.overlayColor = BABYLON.Color3.White(); }));`
        );
        this.emit(
          `${v}.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPointerOutTrigger, () => { ${v}.renderOverlay = false; }));`
        );
      } else if (trait.name === 'accessible') {
        this.emit(
          `${v}.accessibilityTag = { description: "${obj.name}", role: "${trait.config?.role || 'generic'}" };`
        );
      } else {
        this.emit(`// @${trait.name}: ${JSON.stringify(trait.config || {})}`);
      }
    }

    if (obj.children?.length) for (const child of obj.children) this.emitObject(child, v);
    this.emit('');
  }

  // --- Groups ---

  private emitGroup(group: HoloSpatialGroup, parentVar?: string): void {
    const v = this.sanitizeName(group.name);
    this.emit(`const ${v} = new BABYLON.TransformNode("${group.name}", this.scene);`);
    for (const p of group.properties) {
      if (p.key === 'position' && Array.isArray(p.value))
        this.emit(`${v}.position = ${this.toBabylonVector(p.value)};`);
      else if (p.key === 'rotation' && Array.isArray(p.value))
        this.emit(`${v}.rotation = ${this.toBabylonVector(p.value)};`);
      else if (p.key === 'scale') {
        this.emit(
          Array.isArray(p.value)
            ? `${v}.scaling = ${this.toBabylonVector(p.value)};`
            : `${v}.scaling = new BABYLON.Vector3(${p.value}, ${p.value}, ${p.value});`
        );
      }
    }
    if (parentVar) this.emit(`${v}.parent = ${parentVar};`);
    for (const obj of group.objects) this.emitObject(obj, v);
    if (group.groups) for (const sub of group.groups) this.emitGroup(sub, v);
    this.emit('');
  }

  // --- Lights ---

  private emitLight(light: HoloLight): void {
    const v = this.sanitizeName(light.name);
    let pos: any[] | undefined, color: any, intensity: number | undefined;
    let dir: any[] | undefined,
      castShadow = false,
      angle: number | undefined,
      dist: number | undefined;

    for (const p of light.properties) {
      if (p.key === 'position' && Array.isArray(p.value)) pos = p.value;
      else if (p.key === 'color') color = p.value;
      else if (p.key === 'intensity') intensity = p.value as number;
      else if (p.key === 'direction' && Array.isArray(p.value)) dir = p.value;
      else if (p.key === 'cast_shadow' || p.key === 'castShadow') castShadow = !!p.value;
      else if (p.key === 'angle') angle = p.value as number;
      else if (p.key === 'distance') dist = p.value as number;
    }

    const posV = pos ? this.toBabylonVector(pos) : 'new BABYLON.Vector3(0, 1, 0)';
    const dirV = dir ? this.toBabylonVector(dir) : 'new BABYLON.Vector3(0, -1, 0)';

    switch (light.lightType) {
      case 'hemisphere':
      case 'ambient':
        this.emit(
          `const ${v} = new BABYLON.HemisphericLight("${light.name}", ${posV}, this.scene);`
        );
        break;
      case 'directional':
        this.emit(
          `const ${v} = new BABYLON.DirectionalLight("${light.name}", ${dirV}, this.scene);`
        );
        if (pos) this.emit(`${v}.position = ${posV};`);
        break;
      case 'point':
        this.emit(`const ${v} = new BABYLON.PointLight("${light.name}", ${posV}, this.scene);`);
        break;
      case 'spot':
        this.emit(
          `const ${v} = new BABYLON.SpotLight("${light.name}", ${posV}, ${dirV}, ${angle ?? Math.PI / 4}, 2, this.scene);`
        );
        break;
      case 'area':
        this.emit(`// Area light fallback`);
        this.emit(`const ${v} = new BABYLON.PointLight("${light.name}", ${posV}, this.scene);`);
        break;
      default:
        this.emit(
          `const ${v} = new BABYLON.HemisphericLight("${light.name}", ${posV}, this.scene);`
        );
        break;
    }

    if (color) this.emit(`${v}.diffuse = ${this.toBabylonColor3(color)};`);
    if (intensity !== undefined) this.emit(`${v}.intensity = ${intensity};`);
    if (dist !== undefined) this.emit(`${v}.range = ${dist};`);
    if (castShadow && ['directional', 'spot', 'point'].includes(light.lightType)) {
      this.emit(`const ${v}SG = new BABYLON.ShadowGenerator(2048, ${v});`);
      this.emit(`${v}SG.useBlurExponentialShadowMap = true;`);
    }
    this.emit('');
  }

  // --- Camera ---

  private emitCamera(cam: HoloCamera): void {
    let fov: number | undefined, pos: any[] | undefined, lookAt: any[] | undefined;
    let near: number | undefined, far: number | undefined;
    for (const p of cam.properties) {
      if (p.key === 'fov' || p.key === 'field_of_view') fov = p.value as number;
      else if (p.key === 'position' && Array.isArray(p.value)) pos = p.value;
      else if ((p.key === 'look_at' || p.key === 'lookAt') && Array.isArray(p.value))
        lookAt = p.value;
      else if (p.key === 'near') near = p.value as number;
      else if (p.key === 'far') far = p.value as number;
    }
    const target = lookAt ? this.toBabylonVector(lookAt) : 'BABYLON.Vector3.Zero()';

    if (cam.cameraType === 'orthographic') {
      this.emit(
        `const camera = new BABYLON.FreeCamera("camera", ${pos ? this.toBabylonVector(pos) : 'new BABYLON.Vector3(0, 5, -10)'}, this.scene);`
      );
      this.emit(`camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;`);
      this.emit(`camera.setTarget(${target});`);
    } else {
      this.emit(
        `const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 3, 10, ${target}, this.scene);`
      );
      if (pos) this.emit(`camera.setPosition(${this.toBabylonVector(pos)});`);
    }
    if (fov !== undefined) this.emit(`camera.fov = ${fov * (Math.PI / 180)};`);
    if (near !== undefined) this.emit(`camera.minZ = ${near};`);
    if (far !== undefined) this.emit(`camera.maxZ = ${far};`);
    this.emit('camera.attachControl(this.canvas, true);');
    this.emit('');
  }

  // --- Timeline ---

  private emitTimeline(timeline: HoloTimeline): void {
    const v = this.sanitizeName(timeline.name);
    this.emit(`const ${v}Group = new BABYLON.AnimationGroup("${timeline.name}", this.scene);`);
    const fps = 30;
    for (const entry of timeline.entries) {
      const a = entry.action;
      if (a.kind === 'animate') {
        const frame = Math.round(entry.time * fps);
        for (const [key, value] of Object.entries(a.properties)) {
          const n = `${v}_${this.sanitizeName(a.target)}_${key}`;
          const animType = Array.isArray(value) ? 'ANIMATIONTYPE_VECTOR3' : 'ANIMATIONTYPE_FLOAT';
          const valStr = Array.isArray(value) ? this.toBabylonVector(value) : String(value);
          this.emit(
            `const ${n} = new BABYLON.Animation("${n}", "${this.mapAnimProperty(key)}", ${fps}, BABYLON.Animation.${animType}, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);`
          );
          this.emit(
            `${n}.setKeys([{ frame: 0, value: ${valStr} }, { frame: ${frame}, value: ${valStr} }]);`
          );
        }
      } else if (a.kind === 'emit') {
        this.emit(`// @${entry.time}s: emit "${a.event}"`);
      } else if (a.kind === 'call') {
        this.emit(`// @${entry.time}s: call ${a.method}()`);
      }
    }
    if (timeline.autoplay) this.emit(`${v}Group.play(${timeline.loop ? 'true' : 'false'});`);
    this.emit('');
  }

  // --- Audio ---

  private emitAudio(audio: HoloAudio): void {
    const v = this.sanitizeName(audio.name);
    let src = '',
      volume = 1,
      loop = false,
      spatial = false;
    let position: any[] | undefined, dist: number | undefined;
    for (const p of audio.properties) {
      if (p.key === 'src' || p.key === 'source') src = String(p.value);
      else if (p.key === 'volume') volume = p.value as number;
      else if (p.key === 'loop') loop = !!p.value;
      else if (p.key === 'spatial') spatial = !!p.value;
      else if (p.key === 'position' && Array.isArray(p.value)) position = p.value;
      else if (p.key === 'distance') dist = p.value as number;
    }
    const opts: string[] = ['autoplay: true'];
    if (loop) opts.push('loop: true');
    if (volume !== 1) opts.push(`volume: ${volume}`);
    if (spatial) opts.push('spatialSound: true');
    if (dist !== undefined) opts.push(`maxDistance: ${dist}`);
    this.emit(
      `const ${v} = new BABYLON.Sound("${audio.name}", "${src}", this.scene, null, { ${opts.join(', ')} });`
    );
    if (spatial && position) this.emit(`${v}.setPosition(${this.toBabylonVector(position)});`);
    this.emit('');
  }

  // --- Zone ---

  private emitZone(zone: HoloZone): void {
    const v = this.sanitizeName(zone.name);
    let shape = 'box',
      position: any[] | undefined,
      size: any,
      radius: number | undefined;
    for (const p of zone.properties) {
      if (p.key === 'shape') shape = String(p.value);
      else if (p.key === 'position' && Array.isArray(p.value)) position = p.value;
      else if (p.key === 'size') size = p.value;
      else if (p.key === 'radius') radius = p.value as number;
    }
    if (shape === 'sphere') {
      this.emit(
        `const ${v} = BABYLON.MeshBuilder.CreateSphere("${zone.name}", { diameter: ${(radius || 5) * 2} }, this.scene);`
      );
    } else {
      const s = Array.isArray(size) ? size : [size || 5, size || 5, size || 5];
      this.emit(
        `const ${v} = BABYLON.MeshBuilder.CreateBox("${zone.name}", { width: ${s[0]}, height: ${s[1]}, depth: ${s[2]} }, this.scene);`
      );
    }
    if (position) this.emit(`${v}.position = ${this.toBabylonVector(position)};`);
    this.emit(`${v}.isVisible = false; ${v}.checkCollisions = true;`);
    if (zone.handlers?.length) {
      this.emit(`${v}.actionManager = new BABYLON.ActionManager(this.scene);`);
      for (const h of zone.handlers) {
        const trigger =
          h.event === 'on_enter'
            ? 'OnIntersectionEnterTrigger'
            : h.event === 'on_exit'
              ? 'OnIntersectionExitTrigger'
              : `NothingTrigger /* ${h.event} */`;
        this.emit(
          `${v}.actionManager.registerAction(new BABYLON.ExecuteCodeAction({ trigger: BABYLON.ActionManager.${trigger} }, () => { /* ${h.event} */ }));`
        );
      }
    }
    this.emit('');
  }

  // --- UI ---

  private emitUI(ui: HoloUI): void {
    this.emit('const advancedTexture = GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");');
    for (const el of ui.elements) {
      const v = this.sanitizeName(el.name);
      let elType = 'text',
        text = '',
        fontSize = 24,
        color = '#ffffff',
        bg: string | undefined;
      for (const p of el.properties) {
        if (p.key === 'type') elType = String(p.value);
        else if (p.key === 'text') text = String(p.value);
        else if (p.key === 'font_size' || p.key === 'fontSize') fontSize = p.value as number;
        else if (p.key === 'color') color = String(p.value);
        else if (p.key === 'background') bg = String(p.value);
      }
      if (elType === 'button') {
        this.emit(`const ${v} = GUI.Button.CreateSimpleButton("${el.name}", "${text}");`);
        this.emit(
          `${v}.width = "150px"; ${v}.height = "40px"; ${v}.color = "${color}"; ${v}.fontSize = ${fontSize};`
        );
        if (bg) this.emit(`${v}.background = "${bg}";`);
        this.emit(`advancedTexture.addControl(${v});`);
      } else if (elType === 'progress') {
        this.emit(`const ${v} = new GUI.StackPanel("${el.name}");`);
        this.emit(`${v}.width = "200px"; ${v}.height = "20px"; advancedTexture.addControl(${v});`);
      } else {
        this.emit(`const ${v} = new GUI.TextBlock("${el.name}", "${text}");`);
        this.emit(
          `${v}.color = "${color}"; ${v}.fontSize = ${fontSize}; advancedTexture.addControl(${v});`
        );
      }
    }
    this.emit('');
  }

  // --- Effects ---

  private emitEffects(effects: HoloEffects): void {
    this.emit(
      'const pipeline = new BABYLON.DefaultRenderingPipeline("defaultPipeline", true, this.scene);'
    );
    for (const fx of effects.effects) {
      const p = fx.properties;
      switch (fx.effectType) {
        case 'bloom':
          this.emit('pipeline.bloomEnabled = true;');
          if (p.intensity !== undefined) this.emit(`pipeline.bloomWeight = ${p.intensity};`);
          if (p.threshold !== undefined) this.emit(`pipeline.bloomThreshold = ${p.threshold};`);
          break;
        case 'dof':
          this.emit('pipeline.depthOfFieldEnabled = true;');
          if (p.focalLength !== undefined)
            this.emit(`pipeline.depthOfField.focalLength = ${p.focalLength};`);
          if (p.fStop !== undefined) this.emit(`pipeline.depthOfField.fStop = ${p.fStop};`);
          break;
        case 'ssao':
          this.emit(
            'const ssao = new BABYLON.SSAO2RenderingPipeline("ssao", this.scene, { ssaoRatio: 0.5, blurRatio: 0.5 });'
          );
          if (p.radius !== undefined) this.emit(`ssao.radius = ${p.radius};`);
          break;
        case 'vignette':
          this.emit('pipeline.imageProcessing.vignetteEnabled = true;');
          if (p.weight !== undefined)
            this.emit(`pipeline.imageProcessing.vignetteWeight = ${p.weight};`);
          break;
        case 'chromatic_aberration':
          this.emit('pipeline.chromaticAberrationEnabled = true;');
          if (p.amount !== undefined)
            this.emit(`pipeline.chromaticAberration.aberrationAmount = ${p.amount};`);
          break;
        case 'tone_mapping':
          this.emit('pipeline.imageProcessingEnabled = true;');
          this.emit('pipeline.imageProcessing.toneMappingEnabled = true;');
          break;
        default:
          this.emit(`// Effect "${fx.effectType}": ${JSON.stringify(p)}`);
      }
    }
    this.emit('');
  }

  // --- Transition ---

  private emitTransition(tr: HoloTransition): void {
    let target: string | undefined, effect: string | undefined, duration: number | undefined;
    for (const p of tr.properties) {
      if (p.key === 'target') target = String(p.value);
      else if (p.key === 'effect') effect = String(p.value);
      else if (p.key === 'duration') duration = p.value as number;
    }
    this.emit(
      `// Transition "${tr.name}": navigate to "${target || '?'}" with ${effect || 'fade'} over ${duration || 1}s`
    );
  }

  // --- XR ---

  private emitXRSetup(): void {
    this.emit('const xr = await this.scene.createDefaultXRExperienceAsync({');
    this.indent();
    this.emit('floorMeshes: this.scene.meshes.filter(m => m.name.includes("ground")),');
    this.dedent();
    this.emit('});');
    this.emit('');
  }

  // --- Render Loop ---

  private emitRenderLoop(): void {
    this.emit('this.engine.runRenderLoop(() => { this.scene.render(); });');
    this.emit('window.addEventListener("resize", () => { this.engine.resize(); });');
  }

  // --- Value Conversion Helpers ---

  private toBabylonColor3(value: any): string {
    if (typeof value === 'string' && value.startsWith('#')) {
      const h = value.slice(1);
      const r = parseInt(h.substring(0, 2), 16) / 255;
      const g = parseInt(h.substring(2, 4), 16) / 255;
      const b = parseInt(h.substring(4, 6), 16) / 255;
      return `new BABYLON.Color3(${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)})`;
    }
    if (typeof value === 'object' && value !== null && 'r' in value) {
      const r = value.r > 1 ? value.r / 255 : value.r;
      const g = value.g > 1 ? value.g / 255 : value.g;
      const b = value.b > 1 ? value.b / 255 : value.b;
      return `new BABYLON.Color3(${r.toFixed(3)}, ${g.toFixed(3)}, ${b.toFixed(3)})`;
    }
    return 'BABYLON.Color3.White()';
  }

  private toBabylonVector(arr: any[]): string {
    if (arr.length >= 3) return `new BABYLON.Vector3(${arr[0]}, ${arr[1]}, ${arr[2]})`;
    if (arr.length === 2) return `new BABYLON.Vector2(${arr[0]}, ${arr[1]})`;
    return `new BABYLON.Vector3(${arr[0]}, ${arr[0]}, ${arr[0]})`;
  }

  private mapShapeToMesh(type: string): string {
    return SHAPE_TO_MESH[type] || 'CreateBox';
  }

  private meshBuilderOptions(type: string, size: any): string {
    const s = typeof size === 'number' ? size : 1;
    switch (type) {
      case 'sphere':
      case 'orb':
        return `{ diameter: ${s}, segments: 32 }`;
      case 'cube':
      case 'box':
        return `{ size: ${s} }`;
      case 'cylinder':
        return `{ diameter: ${s}, height: ${s * 2}, tessellation: 32 }`;
      case 'cone':
      case 'pyramid':
        return `{ diameterTop: 0, diameterBottom: ${s}, height: ${s * 2}, tessellation: ${type === 'pyramid' ? 4 : 32} }`;
      case 'plane':
      case 'ground':
        return `{ width: ${s}, height: ${s} }`;
      case 'torus':
      case 'ring':
        return `{ diameter: ${s}, thickness: ${s * 0.3}, tessellation: 32 }`;
      case 'capsule':
        return `{ radius: ${s * 0.3}, height: ${s} }`;
      case 'disc':
        return `{ radius: ${s * 0.5}, tessellation: 32 }`;
      default:
        return `{ size: ${s} }`;
    }
  }

  private mapAnimProperty(key: string): string {
    const m: Record<string, string> = {
      position: 'position',
      rotation: 'rotation',
      scale: 'scaling',
      color: 'material.albedoColor',
      opacity: 'material.alpha',
      emissive: 'material.emissiveColor',
    };
    return m[key] || key;
  }

  // --- Emit Helpers ---

  private emit(line: string): void {
    this.lines.push(this.options.indent.repeat(this.indentLevel) + line);
  }
  private indent(): void {
    this.indentLevel++;
  }
  private dedent(): void {
    this.indentLevel = Math.max(0, this.indentLevel - 1);
  }
  private sanitizeName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_');
  }
}
