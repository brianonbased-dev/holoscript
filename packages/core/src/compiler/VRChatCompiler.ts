/**
 * HoloScript â†’ VRChat SDK3 Worlds + UdonSharp Compiler
 *
 * Translates a HoloComposition AST into VRChat-compatible Unity prefabs
 * with UdonSharp scripts for interactivity.
 *
 * Emits:
 *   - UdonSharp C# scripts for interactions
 *   - Unity scene structure compatible with VRChat SDK3
 *   - VRC_Pickup, VRC_Trigger, VRC_ObjectSync components
 *   - Avatar pedestals, mirrors, portals
 *   - Audio with VRC_SpatialAudioSource
 *
 * @version 1.0.0
 */

import type {
  HoloComposition,
  HoloObjectDecl,
  HoloEnvironment,
  HoloTimeline,
  HoloTransition,
  HoloValue,
} from '../parser/HoloCompositionTypes';

export interface VRChatCompilerOptions {
  namespace?: string;
  className?: string;
  worldName?: string;
  indent?: string;
  sdkVersion?: '3.0' | '3.1' | '3.2' | '3.3' | '3.4' | '3.5';
  useUdonSharp?: boolean;
}

export interface VRChatCompileResult {
  mainScript: string;
  udonScripts: Map<string, string>;
  prefabHierarchy: string;
  worldDescriptor: string;
}

export class VRChatCompiler {
  private options: Required<VRChatCompilerOptions>;
  private lines: string[] = [];
  private indentLevel: number = 0;
  private udonScripts: Map<string, string> = new Map();
  private interactableObjects: string[] = [];

  constructor(options: VRChatCompilerOptions = {}) {
    this.options = {
      namespace: options.namespace || 'HoloWorld',
      className: options.className || 'GeneratedWorld',
      worldName: options.worldName || 'HoloScript World',
      indent: options.indent || '    ',
      sdkVersion: options.sdkVersion || '3.5',
      useUdonSharp: options.useUdonSharp ?? true,
    };
  }

  compile(composition: HoloComposition): VRChatCompileResult {
    this.lines = [];
    this.udonScripts.clear();
    this.interactableObjects = [];
    this.indentLevel = 0;

    // Generate main world setup script
    const mainScript = this.generateMainScript(composition);

    // Generate individual Udon scripts for interactive objects
    this.generateUdonScripts(composition);

    // Generate prefab hierarchy
    const prefabHierarchy = this.generatePrefabHierarchy(composition);

    // Generate world descriptor
    const worldDescriptor = this.generateWorldDescriptor(composition);

    return {
      mainScript,
      udonScripts: this.udonScripts,
      prefabHierarchy,
      worldDescriptor,
    };
  }

  private generateMainScript(composition: HoloComposition): string {
    this.lines = [];
    this.indentLevel = 0;

    this.emit('// Auto-generated by HoloScript VRChatCompiler');
    this.emit(`// Source: composition "${composition.name}"`);
    this.emit(`// VRChat SDK: ${this.options.sdkVersion}`);
    this.emit('// Do not edit manually â€” regenerate from .holo source');
    this.emit('');
    this.emit('using UdonSharp;');
    this.emit('using UnityEngine;');
    this.emit('using VRC.SDKBase;');
    this.emit('using VRC.Udon;');
    this.emit('using VRC.SDK3.Components;');
    if (composition.audio?.length) {
      this.emit('using VRC.SDK3.Components.Audio;');
    }
    this.emit('');

    this.emit(`namespace ${this.options.namespace}`);
    this.emit('{');
    this.indentLevel++;

    this.emit('[UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]');
    this.emit(`public class ${this.options.className} : UdonSharpBehaviour`);
    this.emit('{');
    this.indentLevel++;

    // Synced state fields
    if (composition.state) {
      this.emit('// === Synced State ===');
      for (const prop of composition.state.properties) {
        const csType = this.toCSharpType(prop.value);
        const csVal = this.toCSharpValue(prop.value);
        this.emit(`[UdonSynced] public ${csType} ${prop.key} = ${csVal};`);
      }
      this.emit('');
    }

    // Object references
    this.emit('// === Object References ===');
    this.emit('[Header("Scene Objects")]');
    const objects = composition.objects || [];
    for (const obj of objects) {
      const varName = this.sanitizeName(obj.name);
      this.emit(`public GameObject ${varName};`);
    }
    this.emit('');

    // Start method
    this.emit('void Start()');
    this.emit('{');
    this.indentLevel++;
    this.emit('Debug.Log("[HoloWorld] World initialized");');

    // Environment setup
    if (composition.environment) {
      this.compileEnvironment(composition.environment);
    }

    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Network sync
    this.emit('public override void OnDeserialization()');
    this.emit('{');
    this.indentLevel++;
    this.emit('// Handle synced state updates');
    this.emit('UpdateVisuals();');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    this.emit('private void UpdateVisuals()');
    this.emit('{');
    this.indentLevel++;
    this.emit('// Update visuals based on synced state');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Player events
    this.emit('public override void OnPlayerJoined(VRCPlayerApi player)');
    this.emit('{');
    this.indentLevel++;
    this.emit('if (player.isLocal)');
    this.emit('{');
    this.indentLevel++;
    this.emit('Debug.Log($"[HoloWorld] Welcome, {player.displayName}!");');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Zones / trigger areas
    if (composition.zones) {
      for (const zone of composition.zones) {
        this.compileZoneTriggers(zone);
      }
    }

    // Timeline coroutines
    if (composition.timelines) {
      for (const tl of composition.timelines) {
        this.compileTimeline(tl);
      }
    }

    // Transitions
    if (composition.transitions) {
      for (const tr of composition.transitions) {
        this.compileTransition(tr);
      }
    }

    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');

    return this.lines.join('\n');
  }

  private generateUdonScripts(composition: HoloComposition): void {
    const objects = composition.objects || [];

    for (const obj of objects) {
      if (!obj.traits) continue;

      const hasGrabbable = obj.traits.some((t) => t.name === 'grabbable');
      const hasPointable = obj.traits.some((t) => t.name === 'pointable' || t.name === 'clickable');
      const hasNetworked = obj.traits.some((t) => t.name === 'networked' || t.name === 'synced');
      const hasPortal = obj.traits.some((t) => t.name === 'portal');
      const hasMirror = obj.traits.some((t) => t.name === 'mirror');

      if (hasGrabbable || hasPointable || hasNetworked || hasPortal || hasMirror) {
        const script = this.generateObjectUdonScript(obj, {
          hasGrabbable,
          hasPointable,
          hasNetworked,
          hasPortal,
          hasMirror,
        });
        this.udonScripts.set(`${this.sanitizeName(obj.name)}Behaviour.cs`, script);
        this.interactableObjects.push(obj.name);
      }
    }
  }

  private generateObjectUdonScript(
    obj: HoloObjectDecl,
    traits: {
      hasGrabbable: boolean;
      hasPointable: boolean;
      hasNetworked: boolean;
      hasPortal: boolean;
      hasMirror: boolean;
    }
  ): string {
    const lines: string[] = [];
    const varName = this.sanitizeName(obj.name);
    const className = `${varName}Behaviour`;

    lines.push('// Auto-generated UdonSharp script');
    lines.push(`// Object: ${obj.name}`);
    lines.push('');
    lines.push('using UdonSharp;');
    lines.push('using UnityEngine;');
    lines.push('using VRC.SDKBase;');
    lines.push('using VRC.Udon;');
    lines.push('');

    const syncMode = traits.hasNetworked ? 'BehaviourSyncMode.Manual' : 'BehaviourSyncMode.None';
    lines.push(`[UdonBehaviourSyncMode(${syncMode})]`);
    lines.push(`public class ${className} : UdonSharpBehaviour`);
    lines.push('{');

    // State fields
    if (obj.state?.properties) {
      lines.push('    // === State ===');
      for (const prop of obj.state.properties) {
        const csType = this.toCSharpType(prop.value);
        const csVal = this.toCSharpValue(prop.value);
        const syncAttr = traits.hasNetworked ? '[UdonSynced] ' : '';
        lines.push(`    ${syncAttr}public ${csType} ${prop.key} = ${csVal};`);
      }
      lines.push('');
    }

    // Pickup events (VRC_Pickup compatibility)
    if (traits.hasGrabbable) {
      lines.push('    // VRC_Pickup compatible');
      lines.push('    public VRC_Pickup pickup;');
      lines.push('');
      lines.push('    public override void OnPickup()');
      lines.push('    {');
      lines.push('        Debug.Log($"[{gameObject.name}] Picked up");');
      if (traits.hasNetworked) {
        lines.push('        Networking.SetOwner(Networking.LocalPlayer, gameObject);');
        lines.push('        RequestSerialization();');
      }
      lines.push('    }');
      lines.push('');
      lines.push('    public override void OnDrop()');
      lines.push('    {');
      lines.push('        Debug.Log($"[{gameObject.name}] Dropped");');
      if (traits.hasNetworked) {
        lines.push('        RequestSerialization();');
      }
      lines.push('    }');
      lines.push('');
    }

    // Interact events
    if (traits.hasPointable) {
      lines.push('    public override void Interact()');
      lines.push('    {');
      lines.push('        Debug.Log($"[{gameObject.name}] Interacted");');

      // Interaction logic will be generated based on traits
      lines.push('        OnInteractHandler();');

      lines.push('    }');
      lines.push('');

      lines.push('    private void OnInteractHandler()');
      lines.push('    {');
      lines.push('        // Custom interaction logic based on traits');
      lines.push('    }');
      lines.push('');
    }

    // Portal
    if (traits.hasPortal) {
      const portalTrait = obj.traits?.find((t) => t.name === 'portal');
      const destination = portalTrait?.config?.destination || 'wrld_unknown';
      lines.push('    [Header("Portal Settings")]');
      lines.push(`    public string destinationWorld = "${destination}";`);
      lines.push('');
      lines.push('    public override void Interact()');
      lines.push('    {');
      lines.push('        // VRChat portal â€” player will be teleported');
      lines.push('        Debug.Log($"Portal to {destinationWorld}");');
      lines.push('    }');
      lines.push('');
    }

    // Sync
    if (traits.hasNetworked) {
      lines.push('    public override void OnDeserialization()');
      lines.push('    {');
      lines.push('        // Handle network sync');
      lines.push('        UpdateFromNetwork();');
      lines.push('    }');
      lines.push('');
      lines.push('    private void UpdateFromNetwork()');
      lines.push('    {');
      lines.push('        // Apply synced state to visuals');
      lines.push('    }');
      lines.push('');
    }

    lines.push('}');
    return lines.join('\n');
  }

  private generatePrefabHierarchy(composition: HoloComposition): string {
    const lines: string[] = [];
    lines.push(`# VRChat World Prefab Hierarchy: ${composition.name}`);
    lines.push('# Generated by HoloScript VRChatCompiler');
    lines.push('');
    lines.push('World Root');
    lines.push('â”œâ”€â”€ Environment');

    if (composition.lights) {
      lines.push('â”œâ”€â”€ Lighting');
      for (const light of composition.lights) {
        lines.push(`â”‚   â””â”€â”€ ${light.name} (${light.lightType})`);
      }
    }

    if (composition.objects) {
      lines.push('â”œâ”€â”€ Objects');
      for (const obj of composition.objects) {
        const traits = obj.traits?.map((t) => `@${t.name}`).join(' ') || '';
        lines.push(`â”‚   â””â”€â”€ ${obj.name} ${traits}`);
      }
    }

    if (composition.spatialGroups) {
      for (const group of composition.spatialGroups) {
        lines.push(`â”œâ”€â”€ ${group.name} (SpatialGroup)`);
        for (const child of group.objects || []) {
          lines.push(`â”‚   â””â”€â”€ ${child.name}`);
        }
      }
    }

    if (composition.audio) {
      lines.push('â”œâ”€â”€ Audio');
      for (const audio of composition.audio) {
        lines.push(`â”‚   â””â”€â”€ ${audio.name} (VRCSpatialAudioSource)`);
      }
    }

    if (composition.zones) {
      lines.push('â”œâ”€â”€ Zones');
      for (const zone of composition.zones) {
        lines.push(`â”‚   â””â”€â”€ ${zone.name} (Trigger)`);
      }
    }

    lines.push('â”œâ”€â”€ VRCWorld (VRC_World)');
    lines.push('â”œâ”€â”€ Spawn Points');
    lines.push('â”‚   â””â”€â”€ SpawnPoint_0');
    lines.push('â””â”€â”€ Player Mods');

    return lines.join('\n');
  }

  private generateWorldDescriptor(composition: HoloComposition): string {
    const lines: string[] = [];
    lines.push('// VRC_World Descriptor Settings');
    lines.push(`// World: ${this.options.worldName}`);
    lines.push('');
    lines.push('VRC_SceneDescriptor:');
    lines.push(`  worldName: "${this.options.worldName}"`);
    lines.push(`  worldId: "wrld_${this.generateWorldId()}"`);
    lines.push('  capacity: 32');
    lines.push('  recommendedCapacity: 16');
    lines.push('  respawnHeightY: -100');
    lines.push('  objectBehaviourAtRespawnHeight: Destroy');
    lines.push('  forbidUserPortals: false');
    lines.push('  unityVersion: "2022.3.22f1"');
    lines.push(`  sdkVersion: "${this.options.sdkVersion}"`);
    lines.push('');
    lines.push('SpawnPoints:');
    lines.push('  - position: [0, 0, 0]');
    lines.push('    rotation: [0, 0, 0]');
    lines.push('');

    // Reference cameras if present
    if (composition.camera) {
      lines.push('ReferenceCamera:');
      lines.push('  near: 0.01');
      lines.push('  far: 1000');
    }

    return lines.join('\n');
  }

  private compileEnvironment(env: HoloEnvironment): void {
    this.emit('// === Environment Setup ===');
    for (const prop of env.properties) {
      if (prop.key === 'skybox' || prop.key === 'preset') {
        this.emit(`// Skybox: "${prop.value}" â€” set via VRChat scene settings`);
      } else if (prop.key === 'ambient_light') {
        this.emit(`RenderSettings.ambientIntensity = ${prop.value}f;`);
      } else if (prop.key === 'fog' && typeof prop.value === 'object') {
        const fog = prop.value as Record<string, any>;
        this.emit('RenderSettings.fog = true;');
        if (fog.color) this.emit(`RenderSettings.fogColor = ${this.toColor(fog.color)};`);
      }
    }
  }

  private compileZoneTriggers(zone: any): void {
    const varName = this.sanitizeName(zone.name);
    this.emit(`// Zone: ${zone.name}`);
    this.emit(`public void On${varName}Enter(VRCPlayerApi player)`);
    this.emit('{');
    this.indentLevel++;
    this.emit(`Debug.Log($"Player {player.displayName} entered ${zone.name}");`);
    this.indentLevel--;
    this.emit('}');
    this.emit('');
    this.emit(`public void On${varName}Exit(VRCPlayerApi player)`);
    this.emit('{');
    this.indentLevel++;
    this.emit(`Debug.Log($"Player {player.displayName} exited ${zone.name}");`);
    this.indentLevel--;
    this.emit('}');
    this.emit('');
  }

  private compileTimeline(timeline: HoloTimeline): void {
    const name = this.sanitizeName(timeline.name);
    this.emit(`// Timeline: ${timeline.name}`);
    this.emit(`public void Play${name}()`);
    this.emit('{');
    this.indentLevel++;
    this.emit(`SendCustomEventDelayedSeconds("${name}Step0", 0f);`);
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    for (let i = 0; i < timeline.entries.length; i++) {
      const entry = timeline.entries[i];
      const nextDelay =
        i < timeline.entries.length - 1 ? timeline.entries[i + 1].time - entry.time : 0;

      this.emit(`public void ${name}Step${i}()`);
      this.emit('{');
      this.indentLevel++;

      if (entry.action.kind === 'animate') {
        this.emit(`// Animate ${entry.action.target}`);
      } else if (entry.action.kind === 'emit') {
        this.emit(`SendCustomEvent("${entry.action.event}");`);
      } else if (entry.action.kind === 'call') {
        this.emit(`${entry.action.method}();`);
      }

      if (nextDelay > 0) {
        this.emit(`SendCustomEventDelayedSeconds("${name}Step${i + 1}", ${nextDelay}f);`);
      } else if (timeline.loop && i === timeline.entries.length - 1) {
        this.emit(`SendCustomEventDelayedSeconds("${name}Step0", 0.1f);`);
      }

      this.indentLevel--;
      this.emit('}');
      this.emit('');
    }
  }

  private compileTransition(transition: HoloTransition): void {
    const name = this.sanitizeName(transition.name);
    this.emit(`// Transition: ${transition.name}`);
    this.emit(`public void ${name}Transition()`);
    this.emit('{');
    this.indentLevel++;
    const dest = transition.properties.find((p) => p.key === 'destination' || p.key === 'to');
    if (dest) {
      this.emit(`// Transition to: ${dest.value}`);
    }
    this.indentLevel--;
    this.emit('}');
    this.emit('');
  }

  private generateWorldId(): string {
    const chars = 'abcdef0123456789';
    let id = '';
    for (let i = 0; i < 8; i++) {
      id += chars[Math.floor(Math.random() * chars.length)];
    }
    return id + '-0000-0000-0000-000000000000';
  }

  // === Utility Methods ===

  private emit(line: string): void {
    const indent = this.options.indent.repeat(this.indentLevel);
    this.lines.push(indent + line);
  }

  private sanitizeName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^[0-9]/, '_$&');
  }

  private toCSharpType(value: HoloValue): string {
    if (value === null) return 'object';
    if (typeof value === 'boolean') return 'bool';
    if (typeof value === 'number') return Number.isInteger(value) ? 'int' : 'float';
    if (typeof value === 'string') return 'string';
    if (Array.isArray(value)) {
      if (value.length === 3 && value.every((v) => typeof v === 'number')) return 'Vector3';
      if (value.length === 4 && value.every((v) => typeof v === 'number')) return 'Quaternion';
      return 'object[]';
    }
    return 'object';
  }

  private toCSharpValue(value: HoloValue): string {
    if (value === null) return 'null';
    if (typeof value === 'boolean') return value ? 'true' : 'false';
    if (typeof value === 'number') return Number.isInteger(value) ? `${value}` : `${value}f`;
    if (typeof value === 'string') return `"${value}"`;
    if (Array.isArray(value)) {
      if (value.length === 3 && value.every((v) => typeof v === 'number')) {
        return `new Vector3(${value[0]}f, ${value[1]}f, ${value[2]}f)`;
      }
      if (value.length === 4 && value.every((v) => typeof v === 'number')) {
        return `new Quaternion(${value[0]}f, ${value[1]}f, ${value[2]}f, ${value[3]}f)`;
      }
    }
    return 'null';
  }

  private toColor(value: HoloValue): string {
    if (typeof value === 'string') {
      if (value.startsWith('#')) {
        const hex = value.slice(1);
        if (hex.length === 6) {
          const r = parseInt(hex.slice(0, 2), 16) / 255;
          const g = parseInt(hex.slice(2, 4), 16) / 255;
          const b = parseInt(hex.slice(4, 6), 16) / 255;
          return `new Color(${r}f, ${g}f, ${b}f)`;
        }
      }
      const colors: Record<string, string> = {
        red: 'Color.red',
        green: 'Color.green',
        blue: 'Color.blue',
        white: 'Color.white',
        black: 'Color.black',
        yellow: 'Color.yellow',
        cyan: 'Color.cyan',
        magenta: 'Color.magenta',
      };
      return colors[value.toLowerCase()] || 'Color.white';
    }
    if (Array.isArray(value) && value.length >= 3) {
      const [r, g, b, a = 1] = value as number[];
      return `new Color(${r}f, ${g}f, ${b}f, ${a}f)`;
    }
    return 'Color.white';
  }

  // Collect all trait names for import optimization
  collectAllTraits(composition: HoloComposition): string[] {
    const traits: string[] = [];
    const addTraits = (obj: HoloObjectDecl) => {
      if (obj.traits) {
        for (const t of obj.traits) {
          if (!traits.includes(t.name)) traits.push(t.name);
        }
      }
    };

    for (const obj of composition.objects || []) addTraits(obj);
    for (const group of composition.spatialGroups || []) {
      for (const child of group.objects || []) {
        addTraits(child);
      }
    }

    return traits;
  }
}

export function compileToVRChat(
  composition: HoloComposition,
  options?: VRChatCompilerOptions
): VRChatCompileResult {
  const compiler = new VRChatCompiler(options);
  return compiler.compile(composition);
}
