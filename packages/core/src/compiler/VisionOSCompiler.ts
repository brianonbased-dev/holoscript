/**
 * HoloScript → visionOS Swift / RealityKit Compiler
 *
 * Translates a HoloComposition AST into a Swift file targeting
 * Apple's RealityKit framework for visionOS.
 *
 * Emits:
 *   - A Swift struct conforming to ImmersiveSpace / RealityView
 *   - Entity creation using ModelEntity, AnchorEntity
 *   - PBR materials via PhysicallyBasedMaterial / SimpleMaterial
 *   - Spatial audio via AudioFileGroupResource
 *   - Physics via PhysicsBodyComponent, CollisionComponent
 *   - Environment via ImageBasedLight
 *
 * @version 1.0.0
 */

import type {
  HoloComposition,
  HoloObjectDecl,
  HoloSpatialGroup,
  HoloLight,
  HoloEnvironment,
  HoloTimeline,
  HoloAudio,
  HoloZone,
  HoloTransition,
  HoloEffects,
  HoloValue,
} from '../parser/HoloCompositionTypes';
import { generateTraitCode, getRequiredImports, getMinVisionOSVersion } from './VisionOSTraitMap';

export interface VisionOSCompilerOptions {
  structName?: string;
  indent?: string;
  useRealityComposerPro?: boolean;
}

export class VisionOSCompiler {
  private options: Required<VisionOSCompilerOptions>;
  private lines: string[] = [];
  private indentLevel: number = 0;

  constructor(options: VisionOSCompilerOptions = {}) {
    this.options = {
      structName: options.structName || 'GeneratedScene',
      indent: options.indent || '    ',
      useRealityComposerPro: options.useRealityComposerPro ?? false,
    };
  }

  compile(composition: HoloComposition): string {
    this.lines = [];
    this.indentLevel = 0;

    this.emit('// Auto-generated by HoloScript VisionOSCompiler');
    this.emit(`// Source: composition "${composition.name}"`);
    this.emit('// Do not edit manually — regenerate from .holo source');
    this.emit('');
    this.emit('import SwiftUI');
    this.emit('import RealityKit');
    this.emit('import RealityKitContent');

    // Dynamic imports based on traits used
    const allTraits = this.collectAllTraits(composition);
    const requiredImports = getRequiredImports(allTraits);
    for (const imp of requiredImports) {
      this.emit(`import ${imp}`);
    }
    if (composition.audio?.length && !requiredImports.includes('AVFoundation')) {
      this.emit('import AVFoundation');
    }

    // Check minimum visionOS version
    const minVersion = getMinVisionOSVersion(allTraits);
    if (minVersion !== '1.0') {
      this.emit(`// Requires visionOS ${minVersion}+`);
    }
    this.emit('');

    // State class
    if (composition.state) {
      this.emit('@Observable');
      this.emit(`class ${this.options.structName}State {`);
      this.indentLevel++;
      for (const prop of composition.state.properties) {
        const swiftType = this.toSwiftType(prop.value);
        const swiftVal = this.toSwiftValue(prop.value);
        this.emit(`var ${prop.key}: ${swiftType} = ${swiftVal}`);
      }
      this.indentLevel--;
      this.emit('}');
      this.emit('');
    }

    // Main view struct
    this.emit(`struct ${this.options.structName}: View {`);
    this.indentLevel++;

    if (composition.state) {
      this.emit(`@State private var state = ${this.options.structName}State()`);
      this.emit('');
    }

    this.emit('var body: some View {');
    this.indentLevel++;
    this.emit('RealityView { content in');
    this.indentLevel++;

    // Build scene
    this.emit('let root = Entity()');
    this.emit(`root.name = "${composition.name}"`);

    // Environment
    if (composition.environment) {
      this.compileEnvironment(composition.environment);
    }

    // Lights
    if (composition.lights) {
      for (const light of composition.lights) {
        this.compileLight(light);
      }
    }

    // Objects
    if (composition.objects) {
      for (const obj of composition.objects) {
        this.compileObject(obj, 'root');
      }
    }

    // Spatial groups
    if (composition.spatialGroups) {
      for (const group of composition.spatialGroups) {
        this.compileSpatialGroup(group, 'root');
      }
    }

    // Audio
    if (composition.audio) {
      for (const audio of composition.audio) {
        this.compileAudio(audio);
      }
    }

    // Zones
    if (composition.zones) {
      for (const zone of composition.zones) {
        this.compileZone(zone);
      }
    }

    this.emit('');
    this.emit('content.add(root)');

    this.indentLevel--;
    this.emit('}');

    // Gesture attachments
    const grabbables =
      composition.objects?.filter((o) => o.traits?.some((t) => t.name === 'grabbable')) || [];
    if (grabbables.length > 0) {
      this.emit('.gesture(DragGesture().targetedToAnyEntity().onChanged { value in');
      this.indentLevel++;
      this.emit(
        'value.entity.position = value.convert(value.location3D, from: .local, to: .scene)'
      );
      this.indentLevel--;
      this.emit('})');
    }

    this.indentLevel--;
    this.emit('}');

    // Timeline methods
    if (composition.timelines) {
      for (const tl of composition.timelines) {
        this.compileTimeline(tl);
      }
    }

    // Transition methods
    if (composition.transitions) {
      for (const tr of composition.transitions) {
        this.compileTransition(tr);
      }
    }

    this.indentLevel--;
    this.emit('}');

    // Effects comments
    if (composition.effects) {
      this.emit('');
      this.compileEffects(composition.effects);
    }

    return this.lines.join('\n');
  }

  private compileEnvironment(env: HoloEnvironment): void {
    this.emit('');
    this.emit('// === Environment ===');
    for (const prop of env.properties) {
      if (prop.key === 'preset' || prop.key === 'skybox') {
        this.emit(`// Environment preset: "${prop.value}" — configure via ImageBasedLight`);
        this.emit('if let iblResource = try? await EnvironmentResource(named: "IBL") {');
        this.indentLevel++;
        this.emit('let iblComponent = ImageBasedLightComponent(source: .single(iblResource))');
        this.emit('root.components.set(iblComponent)');
        this.emit('root.components.set(ImageBasedLightReceiverComponent(imageBasedLight: root))');
        this.indentLevel--;
        this.emit('}');
      } else if (prop.key === 'fog' && typeof prop.value === 'object') {
        this.emit(
          `// Fog: ${JSON.stringify(prop.value)} — not natively supported, use post-processing`
        );
      } else if (prop.key === 'ambient_light') {
        this.emit(`// Ambient light: ${prop.value} — handled via IBL intensity`);
      }
    }
  }

  private compileLight(light: HoloLight): void {
    const varName = this.sanitizeName(light.name);
    this.emit('');
    this.emit(`// Light: ${light.name}`);

    // RealityKit uses PointLightComponent / DirectionalLightComponent / SpotLightComponent
    const typeMap: Record<string, string> = {
      directional: 'DirectionalLightComponent',
      point: 'PointLightComponent',
      spot: 'SpotLightComponent',
    };
    const rkType = typeMap[light.lightType];

    if (rkType) {
      this.emit(`let ${varName} = Entity()`);
      this.emit(`${varName}.name = "${light.name}"`);

      const colorProp = light.properties.find((p) => p.key === 'color');
      const intensityProp = light.properties.find((p) => p.key === 'intensity');
      const posProp = light.properties.find((p) => p.key === 'position');

      if (light.lightType === 'point') {
        this.emit(`var ${varName}Light = PointLightComponent()`);
        if (colorProp)
          this.emit(`${varName}Light.color = .init(${this.toUIColor(colorProp.value)})`);
        if (intensityProp)
          this.emit(`${varName}Light.intensity = ${(intensityProp.value as number) * 1000}`);
      } else if (light.lightType === 'directional') {
        this.emit(`var ${varName}Light = DirectionalLightComponent()`);
        if (colorProp)
          this.emit(`${varName}Light.color = .init(${this.toUIColor(colorProp.value)})`);
        if (intensityProp)
          this.emit(`${varName}Light.intensity = ${(intensityProp.value as number) * 1000}`);
      } else if (light.lightType === 'spot') {
        this.emit(`var ${varName}Light = SpotLightComponent()`);
        if (colorProp)
          this.emit(`${varName}Light.color = .init(${this.toUIColor(colorProp.value)})`);
        if (intensityProp)
          this.emit(`${varName}Light.intensity = ${(intensityProp.value as number) * 1000}`);
      }

      this.emit(`${varName}.components.set(${varName}Light)`);

      if (posProp && Array.isArray(posProp.value)) {
        this.emit(`${varName}.position = ${this.toSIMD3(posProp.value)}`);
      }

      this.emit(`root.addChild(${varName})`);
    } else {
      this.emit(`// Light type "${light.lightType}" not directly supported in RealityKit`);
    }
  }

  private compileObject(obj: HoloObjectDecl, parentVar: string): void {
    // Check if this is a UI component
    if (this.isUIComponent(obj)) {
      this.compileUIComponent(obj, parentVar);
      return;
    }

    const varName = this.sanitizeName(obj.name);
    const meshType = this.findObjProp(obj, 'mesh') || this.findObjProp(obj, 'type') || 'cube';
    const isText = meshType === 'text';
    const isModel = !!this.findObjProp(obj, 'model') || !!this.findObjProp(obj, 'src');
    const isLight = ['directional', 'point', 'spot', 'hemisphere', 'ambient', 'area'].includes(
      meshType as string
    );
    const isSparkles = meshType === 'sparkles';

    this.emit('');
    this.emit(`// Object: ${obj.name}`);

    if (isLight) {
      this.emit(`// Light object "${obj.name}" — handled via light components`);
      return;
    }

    if (isText) {
      this.emit(`let ${varName} = Entity()`);
      this.emit(`${varName}.name = "${obj.name}"`);
      const text = this.findObjProp(obj, 'text');
      const fontSize = this.findObjProp(obj, 'font_size') || 0.1;
      if (text) {
        this.emit(`let ${varName}Mesh = MeshResource.generateText("${text}",`);
        this.emit(`    extrusionDepth: 0.001,`);
        this.emit(`    font: .systemFont(ofSize: CGFloat(${(fontSize as number) * 10})),`);
        this.emit(`    containerFrame: .zero,`);
        this.emit(`    alignment: .center,`);
        this.emit(`    lineBreakMode: .byWordWrapping)`);
        this.emit(
          `${varName}.components.set(ModelComponent(mesh: ${varName}Mesh, materials: [SimpleMaterial(color: ${this.toUIColor(this.findObjProp(obj, 'color') || '#ffffff')}, isMetallic: false)]))`
        );
      }
    } else if (isModel) {
      const src = this.findObjProp(obj, 'model') || this.findObjProp(obj, 'src');
      this.emit(`let ${varName} = try! await Entity(named: "${src}", in: realityKitContentBundle)`);
      this.emit(`${varName}.name = "${obj.name}"`);
    } else if (isSparkles) {
      this.emit(`// Sparkles: use ParticleEmitterComponent in visionOS 2.0+`);
      this.emit(`let ${varName} = Entity()`);
      this.emit(`${varName}.name = "${obj.name}"`);
    } else {
      // Mesh entity
      const meshMap: Record<string, string> = {
        sphere: '.generateSphere(radius: 0.5)',
        box: '.generateBox(size: 1.0)',
        cube: '.generateBox(size: 1.0)',
        plane: '.generatePlane(width: 1.0, depth: 1.0)',
        cylinder: '.generateBox(size: 1.0)', // No cylinder in RealityKit, use box
        cone: '.generateBox(size: 1.0)',
        torus: '.generateBox(size: 1.0)',
      };

      const meshGen = meshMap[meshType as string] || '.generateBox(size: 1.0)';
      const size = this.findObjProp(obj, 'size');
      const radius = this.findObjProp(obj, 'radius');

      let meshCall = meshGen;
      if (meshType === 'sphere' && radius) {
        meshCall = `.generateSphere(radius: ${radius})`;
      } else if ((meshType === 'box' || meshType === 'cube') && size) {
        if (Array.isArray(size)) {
          meshCall = `.generateBox(width: ${size[0]}, height: ${size[1]}, depth: ${size[2]})`;
        } else {
          meshCall = `.generateBox(size: ${size})`;
        }
      } else if (meshType === 'plane' && size) {
        meshCall = `.generatePlane(width: ${size}, depth: ${size})`;
      }

      this.emit(`let ${varName}Mesh = MeshResource${meshCall}`);

      // Material
      const material = this.findObjProp(obj, 'material');
      if (material && typeof material === 'object') {
        const mat = material as Record<string, any>;
        this.emit(`var ${varName}Material = PhysicallyBasedMaterial()`);
        if (mat.color)
          this.emit(`${varName}Material.baseColor = .init(tint: ${this.toUIColor(mat.color)})`);
        if (mat.roughness !== undefined)
          this.emit(`${varName}Material.roughness = .init(floatLiteral: ${mat.roughness})`);
        if (mat.metalness !== undefined)
          this.emit(`${varName}Material.metallic = .init(floatLiteral: ${mat.metalness})`);
        if (mat.emissive)
          this.emit(
            `${varName}Material.emissiveColor = .init(color: ${this.toUIColor(mat.emissive)})`
          );
        if (mat.emissiveIntensity)
          this.emit(`${varName}Material.emissiveIntensity = ${mat.emissiveIntensity}`);
        this.emit(
          `let ${varName} = ModelEntity(mesh: ${varName}Mesh, materials: [${varName}Material])`
        );
      } else {
        this.emit(
          `let ${varName} = ModelEntity(mesh: ${varName}Mesh, materials: [SimpleMaterial()])`
        );
      }

      this.emit(`${varName}.name = "${obj.name}"`);

      // Compile traits using VisionOSTraitMap
      if (obj.traits) {
        for (const trait of obj.traits) {
          const config = trait.config || {};
          const traitCode = generateTraitCode(trait.name, varName, config);
          for (const line of traitCode) {
            if (line) this.emit(line);
          }
        }
      }
    }

    // Position, rotation, scale
    const pos = this.findObjProp(obj, 'position');
    if (pos) this.emit(`${varName}.position = ${this.toSIMD3(pos as any)}`);
    const rot = this.findObjProp(obj, 'rotation');
    if (rot && Array.isArray(rot)) {
      // Convert degrees to radians for RealityKit
      const radX = ((rot[0] as number) * Math.PI) / 180;
      const radY = ((rot[1] as number) * Math.PI) / 180;
      const radZ = ((rot[2] as number) * Math.PI) / 180;
      this.emit(
        `${varName}.orientation = simd_quatf(angle: ${radX.toFixed(4)}, axis: SIMD3<Float>(1, 0, 0)) * simd_quatf(angle: ${radY.toFixed(4)}, axis: SIMD3<Float>(0, 1, 0)) * simd_quatf(angle: ${radZ.toFixed(4)}, axis: SIMD3<Float>(0, 0, 1))`
      );
    }
    const scale = this.findObjProp(obj, 'scale');
    if (scale) this.emit(`${varName}.scale = ${this.toSIMD3(scale as any)}`);

    this.emit(`${parentVar}.addChild(${varName})`);

    // Children
    if (obj.children) {
      for (const child of obj.children) {
        this.compileObject(child, varName);
      }
    }
  }

  private compileSpatialGroup(group: HoloSpatialGroup, parentVar: string): void {
    const varName = this.sanitizeName(group.name);
    this.emit('');
    this.emit(`// Spatial Group: ${group.name}`);
    this.emit(`let ${varName} = Entity()`);
    this.emit(`${varName}.name = "${group.name}"`);

    for (const prop of group.properties) {
      if (prop.key === 'position' && Array.isArray(prop.value)) {
        this.emit(`${varName}.position = ${this.toSIMD3(prop.value)}`);
      }
    }

    this.emit(`${parentVar}.addChild(${varName})`);

    for (const obj of group.objects) {
      this.compileObject(obj, varName);
    }

    if (group.groups) {
      for (const sub of group.groups) {
        this.compileSpatialGroup(sub, varName);
      }
    }
  }

  private compileAudio(audio: HoloAudio): void {
    const varName = this.sanitizeName(audio.name);
    this.emit('');
    this.emit(`// Audio: ${audio.name}`);
    this.emit(`let ${varName} = Entity()`);
    this.emit(`${varName}.name = "${audio.name}"`);

    const src = audio.properties.find((p) => p.key === 'src' || p.key === 'source')?.value;
    const spatial = audio.properties.find((p) => p.key === 'spatial')?.value;

    if (src) {
      this.emit(`if let audioResource = try? await AudioFileResource(named: "${src}") {`);
      this.indentLevel++;
      if (spatial) {
        this.emit(`let audioController = ${varName}.prepareAudio(audioResource)`);
        this.emit(`${varName}.components.set(SpatialAudioComponent())`);
      } else {
        this.emit(`let audioController = ${varName}.prepareAudio(audioResource)`);
        this.emit(`${varName}.components.set(AmbientAudioComponent())`);
      }
      this.emit('audioController.play()');
      this.indentLevel--;
      this.emit('}');
    }

    const pos = audio.properties.find((p) => p.key === 'position')?.value;
    if (pos) this.emit(`${varName}.position = ${this.toSIMD3(pos as any)}`);

    this.emit(`root.addChild(${varName})`);
  }

  private compileZone(zone: HoloZone): void {
    const varName = this.sanitizeName(zone.name);
    this.emit('');
    this.emit(`// Zone: ${zone.name}`);
    this.emit(`let ${varName} = Entity()`);
    this.emit(`${varName}.name = "${zone.name}"`);

    const shape = zone.properties.find((p) => p.key === 'shape')?.value;
    if (shape === 'box') {
      const size = zone.properties.find((p) => p.key === 'size')?.value;
      if (size && Array.isArray(size)) {
        this.emit(
          `${varName}.components.set(CollisionComponent(shapes: [.generateBox(size: ${this.toSIMD3(size)})]))`
        );
      }
    } else if (shape === 'sphere') {
      const radius = zone.properties.find((p) => p.key === 'radius')?.value;
      if (radius) {
        this.emit(
          `${varName}.components.set(CollisionComponent(shapes: [.generateSphere(radius: ${radius})]))`
        );
      }
    }

    const pos = zone.properties.find((p) => p.key === 'position')?.value;
    if (pos) this.emit(`${varName}.position = ${this.toSIMD3(pos as any)}`);

    this.emit(`// Zone handlers: ${zone.handlers?.map((h) => h.event).join(', ') || 'none'}`);
    this.emit(`root.addChild(${varName})`);
  }

  private compileTimeline(tl: HoloTimeline): void {
    const varName = this.sanitizeName(tl.name);
    this.emit('');
    this.emit(`func play${varName}() async {`);
    this.indentLevel++;

    let lastTime = 0;
    for (const entry of tl.entries) {
      const delay = entry.time - lastTime;
      if (delay > 0) {
        this.emit(`try? await Task.sleep(nanoseconds: ${Math.round(delay * 1_000_000_000)})`);
      }

      if (entry.action.kind === 'animate') {
        this.emit(
          `// Animate "${entry.action.target}": ${JSON.stringify(entry.action.properties)}`
        );
      } else if (entry.action.kind === 'emit') {
        this.emit(`// Emit: "${entry.action.event}"`);
      } else if (entry.action.kind === 'call') {
        this.emit(`// Call: ${entry.action.method}`);
      }

      lastTime = entry.time;
    }

    if (tl.loop) {
      this.emit(`await play${varName}() // loop`);
    }

    this.indentLevel--;
    this.emit('}');
  }

  private compileTransition(tr: HoloTransition): void {
    const varName = this.sanitizeName(tr.name);
    this.emit('');
    this.emit(`func ${varName}() {`);
    this.indentLevel++;

    const target = tr.properties.find((p) => p.key === 'target')?.value;
    this.emit(`// Transition to: "${target}"`);
    this.emit(`// Effect: ${tr.properties.find((p) => p.key === 'effect')?.value || 'default'}`);

    this.indentLevel--;
    this.emit('}');
  }

  private compileEffects(effects: HoloEffects): void {
    this.emit('// === Post-Processing Notes ===');
    this.emit('// visionOS uses system-level rendering; post-processing is limited.');
    for (const effect of effects.effects) {
      this.emit(`// Effect: ${effect.effectType} — ${JSON.stringify(effect.properties)}`);
    }
  }

  /**
   * Compile UI component to SwiftUI attachment
   */
  private compileUIComponent(obj: HoloObjectDecl, parentVar: string): void {
    const varName = this.sanitizeName(obj.name);
    const uiType = (this.findObjProp(obj, 'type') as string) || 'panel';

    this.emit('');
    this.emit(`// UI Component: ${obj.name}`);

    switch (uiType) {
      case 'ui_panel':
        this.compileUIPanel(obj, varName, parentVar);
        break;
      case 'ui_button':
        this.compileUIButton(obj, varName, parentVar);
        break;
      case 'ui_text':
        this.compileUIText(obj, varName, parentVar);
        break;
      case 'ui_slider':
        this.compileUISlider(obj, varName, parentVar);
        break;
      case 'ui_input':
        this.compileUIInput(obj, varName, parentVar);
        break;
      case 'ui_image':
        this.compileUIImage(obj, varName, parentVar);
        break;
      default:
        this.emit(`// Unknown UI component type: ${uiType}`);
    }
  }

  private compileUIPanel(obj: HoloObjectDecl, varName: string, parentVar: string): void {
    const width = this.findObjProp(obj, 'width') || 400;
    const height = this.findObjProp(obj, 'height') || 300;
    const pos = this.findObjProp(obj, 'position') as number[] | undefined;

    this.emit(`// SwiftUI Panel attachment for "${obj.name}"`);
    this.emit(`let ${varName} = Entity()`);
    this.emit(`${varName}.name = "${obj.name}"`);

    if (pos) {
      this.emit(`${varName}.position = ${this.toSIMD3(pos)}`);
    }

    this.emit(`// Attach SwiftUI view via ViewAttachmentComponent`);
    this.emit(`// ${varName}.components.set(ViewAttachmentComponent {`);
    this.emit(`//     VStack {`);

    // Compile children
    if (obj.children) {
      for (const child of obj.children) {
        this.emit(`//         // Child: ${child.name}`);
      }
    }

    this.emit(`//     }`);
    this.emit(`//     .frame(width: ${width}, height: ${height})`);
    this.emit(`// })`);
    this.emit(`${parentVar}.addChild(${varName})`);
  }

  private compileUIButton(obj: HoloObjectDecl, varName: string, parentVar: string): void {
    const text = this.findObjProp(obj, 'text') || 'Button';
    const pos = this.findObjProp(obj, 'position') as number[] | undefined;

    this.emit(`let ${varName} = Entity()`);
    this.emit(`${varName}.name = "${obj.name}"`);

    if (pos) {
      this.emit(`${varName}.position = ${this.toSIMD3(pos)}`);
    }

    this.emit(`// SwiftUI Button: "${text}"`);
    this.emit(`// Implement via ViewAttachmentComponent with Button { Text("${text}") }`);
    this.emit(`${varName}.components.set(InputTargetComponent())`);
    this.emit(
      `${varName}.components.set(CollisionComponent(shapes: [.generateBox(size: SIMD3<Float>(0.2, 0.08, 0.01))]))`
    );
    this.emit(`${parentVar}.addChild(${varName})`);
  }

  private compileUIText(obj: HoloObjectDecl, varName: string, parentVar: string): void {
    const content = this.findObjProp(obj, 'content') || this.findObjProp(obj, 'text') || '';
    const fontSize = this.findObjProp(obj, 'fontSize') || 16;
    const color = this.findObjProp(obj, 'color') || '#ffffff';

    this.emit(`let ${varName}Mesh = MeshResource.generateText("${content}",`);
    this.emit(`    extrusionDepth: 0.001,`);
    this.emit(`    font: .systemFont(ofSize: ${fontSize}),`);
    this.emit(`    containerFrame: .zero,`);
    this.emit(`    alignment: .center,`);
    this.emit(`    lineBreakMode: .byWordWrapping)`);
    this.emit(
      `let ${varName} = ModelEntity(mesh: ${varName}Mesh, materials: [SimpleMaterial(color: ${this.toUIColor(color)}, isMetallic: false)])`
    );
    this.emit(`${varName}.name = "${obj.name}"`);
    this.emit(`${parentVar}.addChild(${varName})`);
  }

  private compileUISlider(obj: HoloObjectDecl, varName: string, parentVar: string): void {
    const min = this.findObjProp(obj, 'min') ?? 0;
    const max = this.findObjProp(obj, 'max') ?? 100;
    const value = this.findObjProp(obj, 'value') ?? 50;
    const pos = this.findObjProp(obj, 'position') as number[] | undefined;

    this.emit(`let ${varName} = Entity()`);
    this.emit(`${varName}.name = "${obj.name}"`);

    if (pos) {
      this.emit(`${varName}.position = ${this.toSIMD3(pos)}`);
    }

    this.emit(`// SwiftUI Slider: min=${min}, max=${max}, value=${value}`);
    this.emit(
      `// Implement via ViewAttachmentComponent with Slider(value: $value, in: ${min}...${max})`
    );
    this.emit(`${varName}.components.set(InputTargetComponent())`);
    this.emit(`${parentVar}.addChild(${varName})`);
  }

  private compileUIInput(obj: HoloObjectDecl, varName: string, parentVar: string): void {
    const placeholder = this.findObjProp(obj, 'placeholder') || '';
    const pos = this.findObjProp(obj, 'position') as number[] | undefined;

    this.emit(`let ${varName} = Entity()`);
    this.emit(`${varName}.name = "${obj.name}"`);

    if (pos) {
      this.emit(`${varName}.position = ${this.toSIMD3(pos)}`);
    }

    this.emit(`// SwiftUI TextField with placeholder: "${placeholder}"`);
    this.emit(
      `// Implement via ViewAttachmentComponent with TextField("${placeholder}", text: $text)`
    );
    this.emit(`${varName}.components.set(InputTargetComponent())`);
    this.emit(`${parentVar}.addChild(${varName})`);
  }

  private compileUIImage(obj: HoloObjectDecl, varName: string, parentVar: string): void {
    const src = this.findObjProp(obj, 'src') || '';
    const width = this.findObjProp(obj, 'width') || 100;
    const height = this.findObjProp(obj, 'height') || 100;
    const pos = this.findObjProp(obj, 'position') as number[] | undefined;

    this.emit(`let ${varName} = Entity()`);
    this.emit(`${varName}.name = "${obj.name}"`);

    if (pos) {
      this.emit(`${varName}.position = ${this.toSIMD3(pos)}`);
    }

    this.emit(`// Image: ${src} (${width}x${height})`);
    this.emit(
      `let ${varName}Mesh = MeshResource.generatePlane(width: ${(width as number) / 1000}, depth: ${(height as number) / 1000})`
    );
    this.emit(`if let texture = try? await TextureResource(named: "${src}") {`);
    this.indentLevel++;
    this.emit(`var ${varName}Material = UnlitMaterial()`);
    this.emit(`${varName}Material.color = .init(texture: .init(texture))`);
    this.emit(
      `${varName}.components.set(ModelComponent(mesh: ${varName}Mesh, materials: [${varName}Material]))`
    );
    this.indentLevel--;
    this.emit(`}`);
    this.emit(`${parentVar}.addChild(${varName})`);
  }

  /**
   * Check if object is a UI component
   */
  private isUIComponent(obj: HoloObjectDecl): boolean {
    const type = this.findObjProp(obj, 'type') as string | undefined;
    const uiTypes = ['ui_panel', 'ui_button', 'ui_text', 'ui_slider', 'ui_input', 'ui_image'];
    return uiTypes.includes(type || '');
  }

  /**
   * Get all traits used in composition for imports
   */
  private collectAllTraits(composition: HoloComposition): string[] {
    const traits: string[] = [];

    const collectFromObject = (obj: HoloObjectDecl) => {
      if (obj.traits) {
        for (const trait of obj.traits) {
          if (!traits.includes(trait.name)) {
            traits.push(trait.name);
          }
        }
      }
      if (obj.children) {
        obj.children.forEach(collectFromObject);
      }
    };

    composition.objects?.forEach(collectFromObject);
    composition.spatialGroups?.forEach((group) => {
      group.objects.forEach(collectFromObject);
    });

    return traits;
  }

  // ─── Helpers ───────────────────────────────────────────────────────────

  private emit(line: string): void {
    this.lines.push(this.options.indent.repeat(this.indentLevel) + line);
  }

  private sanitizeName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_');
  }

  private toSIMD3(arr: any): string {
    if (Array.isArray(arr) && arr.length >= 3) {
      return `SIMD3<Float>(${arr[0]}, ${arr[1]}, ${arr[2]})`;
    }
    return `SIMD3<Float>(${arr}, ${arr}, ${arr})`;
  }

  private toUIColor(value: any): string {
    if (typeof value === 'string' && value.startsWith('#')) {
      const hex = value.slice(1);
      const r = parseInt(hex.substring(0, 2), 16) / 255;
      const g = parseInt(hex.substring(2, 4), 16) / 255;
      const b = parseInt(hex.substring(4, 6), 16) / 255;
      return `.init(red: ${r.toFixed(3)}, green: ${g.toFixed(3)}, blue: ${b.toFixed(3)}, alpha: 1.0)`;
    }
    return '.white';
  }

  private toSwiftType(value: HoloValue): string {
    if (typeof value === 'number') return Number.isInteger(value) ? 'Int' : 'Float';
    if (typeof value === 'boolean') return 'Bool';
    if (typeof value === 'string') return 'String';
    if (Array.isArray(value)) return '[Any]';
    return 'Any';
  }

  private toSwiftValue(value: HoloValue): string {
    if (typeof value === 'number') return Number.isInteger(value) ? `${value}` : `${value}`;
    if (typeof value === 'boolean') return value ? 'true' : 'false';
    if (typeof value === 'string') return `"${value}"`;
    if (value === null) return 'nil';
    return 'nil';
  }

  private findObjProp(obj: HoloObjectDecl, key: string): HoloValue | undefined {
    return obj.properties?.find((p) => p.key === key)?.value;
  }
}
