/**
 * HoloScript → visionOS Swift / RealityKit Compiler
 *
 * Translates a HoloComposition AST into a Swift file targeting
 * Apple's RealityKit framework for visionOS.
 *
 * Emits:
 *   - A Swift struct conforming to ImmersiveSpace / RealityView
 *   - Entity creation using ModelEntity, AnchorEntity
 *   - PBR materials via PhysicallyBasedMaterial / SimpleMaterial
 *   - Spatial audio via AudioFileGroupResource
 *   - Physics via PhysicsBodyComponent, CollisionComponent
 *   - Environment via ImageBasedLight
 *
 * @version 1.0.0
 */

import type {
  HoloComposition,
  HoloObjectDecl,
  HoloSpatialGroup,
  HoloLight,
  HoloEnvironment,
  HoloTimeline,
  HoloAudio,
  HoloZone,
  HoloTransition,
  HoloEffects,
  HoloValue,
} from '../parser/HoloCompositionTypes';

export interface VisionOSCompilerOptions {
  structName?: string;
  indent?: string;
  useRealityComposerPro?: boolean;
}

export class VisionOSCompiler {
  private options: Required<VisionOSCompilerOptions>;
  private lines: string[] = [];
  private indentLevel: number = 0;

  constructor(options: VisionOSCompilerOptions = {}) {
    this.options = {
      structName: options.structName || 'GeneratedScene',
      indent: options.indent || '    ',
      useRealityComposerPro: options.useRealityComposerPro ?? false,
    };
  }

  compile(composition: HoloComposition): string {
    this.lines = [];
    this.indentLevel = 0;

    this.emit('// Auto-generated by HoloScript VisionOSCompiler');
    this.emit(`// Source: composition "${composition.name}"`);
    this.emit('// Do not edit manually — regenerate from .holo source');
    this.emit('');
    this.emit('import SwiftUI');
    this.emit('import RealityKit');
    this.emit('import RealityKitContent');
    if (composition.audio?.length) this.emit('import AVFoundation');
    this.emit('');

    // State class
    if (composition.state) {
      this.emit('@Observable');
      this.emit(`class ${this.options.structName}State {`);
      this.indentLevel++;
      for (const prop of composition.state.properties) {
        const swiftType = this.toSwiftType(prop.value);
        const swiftVal = this.toSwiftValue(prop.value);
        this.emit(`var ${prop.key}: ${swiftType} = ${swiftVal}`);
      }
      this.indentLevel--;
      this.emit('}');
      this.emit('');
    }

    // Main view struct
    this.emit(`struct ${this.options.structName}: View {`);
    this.indentLevel++;

    if (composition.state) {
      this.emit(`@State private var state = ${this.options.structName}State()`);
      this.emit('');
    }

    this.emit('var body: some View {');
    this.indentLevel++;
    this.emit('RealityView { content in');
    this.indentLevel++;

    // Build scene
    this.emit('let root = Entity()');
    this.emit(`root.name = "${composition.name}"`);

    // Environment
    if (composition.environment) {
      this.compileEnvironment(composition.environment);
    }

    // Lights
    if (composition.lights) {
      for (const light of composition.lights) {
        this.compileLight(light);
      }
    }

    // Objects
    if (composition.objects) {
      for (const obj of composition.objects) {
        this.compileObject(obj, 'root');
      }
    }

    // Spatial groups
    if (composition.spatialGroups) {
      for (const group of composition.spatialGroups) {
        this.compileSpatialGroup(group, 'root');
      }
    }

    // Audio
    if (composition.audio) {
      for (const audio of composition.audio) {
        this.compileAudio(audio);
      }
    }

    // Zones
    if (composition.zones) {
      for (const zone of composition.zones) {
        this.compileZone(zone);
      }
    }

    this.emit('');
    this.emit('content.add(root)');

    this.indentLevel--;
    this.emit('}');

    // Gesture attachments
    const grabbables = composition.objects?.filter(o =>
      o.traits?.some(t => t.name === 'grabbable')
    ) || [];
    if (grabbables.length > 0) {
      this.emit('.gesture(DragGesture().targetedToAnyEntity().onChanged { value in');
      this.indentLevel++;
      this.emit('value.entity.position = value.convert(value.location3D, from: .local, to: .scene)');
      this.indentLevel--;
      this.emit('})');
    }

    this.indentLevel--;
    this.emit('}');

    // Timeline methods
    if (composition.timelines) {
      for (const tl of composition.timelines) {
        this.compileTimeline(tl);
      }
    }

    // Transition methods
    if (composition.transitions) {
      for (const tr of composition.transitions) {
        this.compileTransition(tr);
      }
    }

    this.indentLevel--;
    this.emit('}');

    // Effects comments
    if (composition.effects) {
      this.emit('');
      this.compileEffects(composition.effects);
    }

    return this.lines.join('\n');
  }

  private compileEnvironment(env: HoloEnvironment): void {
    this.emit('');
    this.emit('// === Environment ===');
    for (const prop of env.properties) {
      if (prop.key === 'preset' || prop.key === 'skybox') {
        this.emit(`// Environment preset: "${prop.value}" — configure via ImageBasedLight`);
        this.emit('if let iblResource = try? await EnvironmentResource(named: "IBL") {');
        this.indentLevel++;
        this.emit('let iblComponent = ImageBasedLightComponent(source: .single(iblResource))');
        this.emit('root.components.set(iblComponent)');
        this.emit('root.components.set(ImageBasedLightReceiverComponent(imageBasedLight: root))');
        this.indentLevel--;
        this.emit('}');
      } else if (prop.key === 'fog' && typeof prop.value === 'object') {
        this.emit(`// Fog: ${JSON.stringify(prop.value)} — not natively supported, use post-processing`);
      } else if (prop.key === 'ambient_light') {
        this.emit(`// Ambient light: ${prop.value} — handled via IBL intensity`);
      }
    }
  }

  private compileLight(light: HoloLight): void {
    const varName = this.sanitizeName(light.name);
    this.emit('');
    this.emit(`// Light: ${light.name}`);

    // RealityKit uses PointLightComponent / DirectionalLightComponent / SpotLightComponent
    const typeMap: Record<string, string> = {
      directional: 'DirectionalLightComponent',
      point: 'PointLightComponent',
      spot: 'SpotLightComponent',
    };
    const rkType = typeMap[light.lightType];

    if (rkType) {
      this.emit(`let ${varName} = Entity()`);
      this.emit(`${varName}.name = "${light.name}"`);

      const colorProp = light.properties.find(p => p.key === 'color');
      const intensityProp = light.properties.find(p => p.key === 'intensity');
      const posProp = light.properties.find(p => p.key === 'position');

      if (light.lightType === 'point') {
        this.emit(`var ${varName}Light = PointLightComponent()`);
        if (colorProp) this.emit(`${varName}Light.color = .init(${this.toUIColor(colorProp.value)})`);
        if (intensityProp) this.emit(`${varName}Light.intensity = ${(intensityProp.value as number) * 1000}`);
      } else if (light.lightType === 'directional') {
        this.emit(`var ${varName}Light = DirectionalLightComponent()`);
        if (colorProp) this.emit(`${varName}Light.color = .init(${this.toUIColor(colorProp.value)})`);
        if (intensityProp) this.emit(`${varName}Light.intensity = ${(intensityProp.value as number) * 1000}`);
      } else if (light.lightType === 'spot') {
        this.emit(`var ${varName}Light = SpotLightComponent()`);
        if (colorProp) this.emit(`${varName}Light.color = .init(${this.toUIColor(colorProp.value)})`);
        if (intensityProp) this.emit(`${varName}Light.intensity = ${(intensityProp.value as number) * 1000}`);
      }

      this.emit(`${varName}.components.set(${varName}Light)`);

      if (posProp && Array.isArray(posProp.value)) {
        this.emit(`${varName}.position = ${this.toSIMD3(posProp.value)}`);
      }

      this.emit(`root.addChild(${varName})`);
    } else {
      this.emit(`// Light type "${light.lightType}" not directly supported in RealityKit`);
    }
  }

  private compileObject(obj: HoloObjectDecl, parentVar: string): void {
    const varName = this.sanitizeName(obj.name);
    const meshType = this.findObjProp(obj, 'mesh') || this.findObjProp(obj, 'type') || 'cube';
    const isText = meshType === 'text';
    const isModel = !!this.findObjProp(obj, 'model') || !!this.findObjProp(obj, 'src');
    const isLight = ['directional', 'point', 'spot', 'hemisphere', 'ambient', 'area'].includes(meshType as string);
    const isSparkles = meshType === 'sparkles';

    this.emit('');
    this.emit(`// Object: ${obj.name}`);

    if (isLight) {
      this.emit(`// Light object "${obj.name}" — handled via light components`);
      return;
    }

    if (isText) {
      this.emit(`let ${varName} = Entity()`);
      this.emit(`${varName}.name = "${obj.name}"`);
      const text = this.findObjProp(obj, 'text');
      const fontSize = this.findObjProp(obj, 'font_size') || 0.1;
      if (text) {
        this.emit(`let ${varName}Mesh = MeshResource.generateText("${text}",`);
        this.emit(`    extrusionDepth: 0.001,`);
        this.emit(`    font: .systemFont(ofSize: CGFloat(${(fontSize as number) * 10})),`);
        this.emit(`    containerFrame: .zero,`);
        this.emit(`    alignment: .center,`);
        this.emit(`    lineBreakMode: .byWordWrapping)`);
        this.emit(`${varName}.components.set(ModelComponent(mesh: ${varName}Mesh, materials: [SimpleMaterial(color: ${this.toUIColor(this.findObjProp(obj, 'color') || '#ffffff')}, isMetallic: false)]))`);
      }
    } else if (isModel) {
      const src = this.findObjProp(obj, 'model') || this.findObjProp(obj, 'src');
      this.emit(`let ${varName} = try! await Entity(named: "${src}", in: realityKitContentBundle)`);
      this.emit(`${varName}.name = "${obj.name}"`);
    } else if (isSparkles) {
      this.emit(`// Sparkles: use ParticleEmitterComponent in visionOS 2.0+`);
      this.emit(`let ${varName} = Entity()`);
      this.emit(`${varName}.name = "${obj.name}"`);
    } else {
      // Mesh entity
      const meshMap: Record<string, string> = {
        sphere: '.generateSphere(radius: 0.5)',
        box: '.generateBox(size: 1.0)',
        cube: '.generateBox(size: 1.0)',
        plane: '.generatePlane(width: 1.0, depth: 1.0)',
        cylinder: '.generateBox(size: 1.0)', // No cylinder in RealityKit, use box
        cone: '.generateBox(size: 1.0)',
        torus: '.generateBox(size: 1.0)',
      };

      const meshGen = meshMap[meshType as string] || '.generateBox(size: 1.0)';
      const size = this.findObjProp(obj, 'size');
      const radius = this.findObjProp(obj, 'radius');

      let meshCall = meshGen;
      if (meshType === 'sphere' && radius) {
        meshCall = `.generateSphere(radius: ${radius})`;
      } else if ((meshType === 'box' || meshType === 'cube') && size) {
        if (Array.isArray(size)) {
          meshCall = `.generateBox(width: ${size[0]}, height: ${size[1]}, depth: ${size[2]})`;
        } else {
          meshCall = `.generateBox(size: ${size})`;
        }
      } else if (meshType === 'plane' && size) {
        meshCall = `.generatePlane(width: ${size}, depth: ${size})`;
      }

      this.emit(`let ${varName}Mesh = MeshResource${meshCall}`);

      // Material
      const material = this.findObjProp(obj, 'material');
      if (material && typeof material === 'object') {
        const mat = material as Record<string, any>;
        this.emit(`var ${varName}Material = PhysicallyBasedMaterial()`);
        if (mat.color) this.emit(`${varName}Material.baseColor = .init(tint: ${this.toUIColor(mat.color)})`);
        if (mat.roughness !== undefined) this.emit(`${varName}Material.roughness = .init(floatLiteral: ${mat.roughness})`);
        if (mat.metalness !== undefined) this.emit(`${varName}Material.metallic = .init(floatLiteral: ${mat.metalness})`);
        if (mat.emissive) this.emit(`${varName}Material.emissiveColor = .init(color: ${this.toUIColor(mat.emissive)})`);
        if (mat.emissiveIntensity) this.emit(`${varName}Material.emissiveIntensity = ${mat.emissiveIntensity}`);
        this.emit(`let ${varName} = ModelEntity(mesh: ${varName}Mesh, materials: [${varName}Material])`);
      } else {
        this.emit(`let ${varName} = ModelEntity(mesh: ${varName}Mesh, materials: [SimpleMaterial()])`);
      }

      this.emit(`${varName}.name = "${obj.name}"`);

      // Physics
      if (obj.traits) {
        for (const trait of obj.traits) {
          if (trait.name === 'collidable') {
            this.emit(`${varName}.components.set(CollisionComponent(shapes: [.generateConvex(from: ${varName}Mesh)]))`);
          } else if (trait.name === 'physics' || trait.name === 'grabbable') {
            this.emit(`${varName}.components.set(CollisionComponent(shapes: [.generateConvex(from: ${varName}Mesh)]))`);
            const mass = trait.config?.mass || 1.0;
            this.emit(`${varName}.components.set(PhysicsBodyComponent(massProperties: .init(mass: ${mass}), mode: .dynamic))`);
          }
          if (trait.name === 'grabbable') {
            this.emit(`${varName}.components.set(InputTargetComponent())`);
          }
          // Environment Understanding
          if (trait.name === 'anchor') {
            this.emit(`// @anchor — AnchorEntity with AnchoringComponent`);
            this.emit(`${varName}.components.set(AnchoringComponent(.init(target: .${trait.config?.anchor_type || 'plane'})))`);
          } else if (trait.name === 'plane_detection') {
            this.emit(`// @plane_detection — ARKit PlaneDetectionProvider`);
          } else if (trait.name === 'mesh_detection') {
            this.emit(`// @mesh_detection — ARKit SceneReconstructionProvider`);
          } else if (trait.name === 'hand_tracking') {
            this.emit(`// @hand_tracking — HandTrackingProvider`);
          } else if (trait.name === 'eye_tracking') {
            this.emit(`// @eye_tracking — gaze input via ARKit`);
          } else if (trait.name === 'occlusion') {
            this.emit(`// @occlusion — RealityKit automatic occlusion`);
          } else if (trait.name === 'light_estimation') {
            this.emit(`// @light_estimation — ARKit environmental lighting`);
          }
          // Spatial Audio
          else if (trait.name === 'ambisonics' || trait.name === 'hrtf' || trait.name === 'reverb_zone') {
            this.emit(`// @${trait.name} — RealityKit SpatialAudioComponent`);
            this.emit(`${varName}.components.set(SpatialAudioComponent())`);
          } else if (trait.name === 'audio_occlusion' || trait.name === 'audio_portal' || trait.name === 'audio_material' || trait.name === 'head_tracked_audio') {
            this.emit(`// @${trait.name} — RealityKit spatial audio: ${JSON.stringify(trait.config || {})}`);
          }
          // Volumetric Content
          else if (trait.name === 'gaussian_splat' || trait.name === 'nerf' || trait.name === 'volumetric_video' || trait.name === 'point_cloud') {
            this.emit(`// @${trait.name} — custom Metal renderer: ${JSON.stringify(trait.config || {})}`);
          } else if (trait.name === 'photogrammetry') {
            this.emit(`// @photogrammetry — Object Capture API`);
          }
          // Accessibility
          else if (trait.name === 'accessible') {
            this.emit(`${varName}.components.set(AccessibilityComponent())`);
            if (trait.config?.label) this.emit(`// accessibilityLabel: "${trait.config.label}"`);
          } else if (trait.name === 'alt_text' || trait.name === 'screen_reader' || trait.name === 'high_contrast' || trait.name === 'motion_reduced' || trait.name === 'magnifiable') {
            this.emit(`// @${trait.name} — SwiftUI accessibility: ${JSON.stringify(trait.config || {})}`);
          }
          // Geospatial
          else if (trait.name === 'geospatial' || trait.name === 'geospatial_anchor' || trait.name === 'terrain_anchor' || trait.name === 'rooftop_anchor') {
            this.emit(`// @${trait.name} — ARKit world tracking with location anchors`);
          }
          // Physics Expansion
          else if (trait.name === 'cloth' || trait.name === 'fluid' || trait.name === 'soft_body' || trait.name === 'destruction') {
            this.emit(`// @${trait.name} — custom Metal compute physics: ${JSON.stringify(trait.config || {})}`);
          } else if (trait.name === 'wind') {
            this.emit(`// @wind — PhysicsSimulationComponent with wind forces`);
          }
          // Catch-all
          else if (trait.name !== 'collidable' && trait.name !== 'physics' && trait.name !== 'grabbable') {
            this.emit(`// @${trait.name}: ${JSON.stringify(trait.config || {})}`);
          }
        }
      }
    }

    // Position, scale
    const pos = this.findObjProp(obj, 'position');
    if (pos) this.emit(`${varName}.position = ${this.toSIMD3(pos as any)}`);
    const scale = this.findObjProp(obj, 'scale');
    if (scale) this.emit(`${varName}.scale = ${this.toSIMD3(scale as any)}`);

    this.emit(`${parentVar}.addChild(${varName})`);

    // Children
    if (obj.children) {
      for (const child of obj.children) {
        this.compileObject(child, varName);
      }
    }
  }

  private compileSpatialGroup(group: HoloSpatialGroup, parentVar: string): void {
    const varName = this.sanitizeName(group.name);
    this.emit('');
    this.emit(`// Spatial Group: ${group.name}`);
    this.emit(`let ${varName} = Entity()`);
    this.emit(`${varName}.name = "${group.name}"`);

    for (const prop of group.properties) {
      if (prop.key === 'position' && Array.isArray(prop.value)) {
        this.emit(`${varName}.position = ${this.toSIMD3(prop.value)}`);
      }
    }

    this.emit(`${parentVar}.addChild(${varName})`);

    for (const obj of group.objects) {
      this.compileObject(obj, varName);
    }

    if (group.groups) {
      for (const sub of group.groups) {
        this.compileSpatialGroup(sub, varName);
      }
    }
  }

  private compileAudio(audio: HoloAudio): void {
    const varName = this.sanitizeName(audio.name);
    this.emit('');
    this.emit(`// Audio: ${audio.name}`);
    this.emit(`let ${varName} = Entity()`);
    this.emit(`${varName}.name = "${audio.name}"`);

    const src = audio.properties.find(p => p.key === 'src' || p.key === 'source')?.value;
    const spatial = audio.properties.find(p => p.key === 'spatial')?.value;

    if (src) {
      this.emit(`if let audioResource = try? await AudioFileResource(named: "${src}") {`);
      this.indentLevel++;
      if (spatial) {
        this.emit(`let audioController = ${varName}.prepareAudio(audioResource)`);
        this.emit(`${varName}.components.set(SpatialAudioComponent())`);
      } else {
        this.emit(`let audioController = ${varName}.prepareAudio(audioResource)`);
        this.emit(`${varName}.components.set(AmbientAudioComponent())`);
      }
      this.emit('audioController.play()');
      this.indentLevel--;
      this.emit('}');
    }

    const pos = audio.properties.find(p => p.key === 'position')?.value;
    if (pos) this.emit(`${varName}.position = ${this.toSIMD3(pos as any)}`);

    this.emit(`root.addChild(${varName})`);
  }

  private compileZone(zone: HoloZone): void {
    const varName = this.sanitizeName(zone.name);
    this.emit('');
    this.emit(`// Zone: ${zone.name}`);
    this.emit(`let ${varName} = Entity()`);
    this.emit(`${varName}.name = "${zone.name}"`);

    const shape = zone.properties.find(p => p.key === 'shape')?.value;
    if (shape === 'box') {
      const size = zone.properties.find(p => p.key === 'size')?.value;
      if (size && Array.isArray(size)) {
        this.emit(`${varName}.components.set(CollisionComponent(shapes: [.generateBox(size: ${this.toSIMD3(size)})]))`);
      }
    } else if (shape === 'sphere') {
      const radius = zone.properties.find(p => p.key === 'radius')?.value;
      if (radius) {
        this.emit(`${varName}.components.set(CollisionComponent(shapes: [.generateSphere(radius: ${radius})]))`);
      }
    }

    const pos = zone.properties.find(p => p.key === 'position')?.value;
    if (pos) this.emit(`${varName}.position = ${this.toSIMD3(pos as any)}`);

    this.emit(`// Zone handlers: ${zone.handlers?.map(h => h.event).join(', ') || 'none'}`);
    this.emit(`root.addChild(${varName})`);
  }

  private compileTimeline(tl: HoloTimeline): void {
    const varName = this.sanitizeName(tl.name);
    this.emit('');
    this.emit(`func play${varName}() async {`);
    this.indentLevel++;

    let lastTime = 0;
    for (const entry of tl.entries) {
      const delay = entry.time - lastTime;
      if (delay > 0) {
        this.emit(`try? await Task.sleep(nanoseconds: ${Math.round(delay * 1_000_000_000)})`);
      }

      if (entry.action.kind === 'animate') {
        this.emit(`// Animate "${entry.action.target}": ${JSON.stringify(entry.action.properties)}`);
      } else if (entry.action.kind === 'emit') {
        this.emit(`// Emit: "${entry.action.event}"`);
      } else if (entry.action.kind === 'call') {
        this.emit(`// Call: ${entry.action.method}`);
      }

      lastTime = entry.time;
    }

    if (tl.loop) {
      this.emit(`await play${varName}() // loop`);
    }

    this.indentLevel--;
    this.emit('}');
  }

  private compileTransition(tr: HoloTransition): void {
    const varName = this.sanitizeName(tr.name);
    this.emit('');
    this.emit(`func ${varName}() {`);
    this.indentLevel++;

    const target = tr.properties.find(p => p.key === 'target')?.value;
    this.emit(`// Transition to: "${target}"`);
    this.emit(`// Effect: ${tr.properties.find(p => p.key === 'effect')?.value || 'default'}`);

    this.indentLevel--;
    this.emit('}');
  }

  private compileEffects(effects: HoloEffects): void {
    this.emit('// === Post-Processing Notes ===');
    this.emit('// visionOS uses system-level rendering; post-processing is limited.');
    for (const effect of effects.effects) {
      this.emit(`// Effect: ${effect.effectType} — ${JSON.stringify(effect.properties)}`);
    }
  }

  // ─── Helpers ───────────────────────────────────────────────────────────

  private emit(line: string): void {
    this.lines.push(this.options.indent.repeat(this.indentLevel) + line);
  }

  private sanitizeName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_');
  }

  private toSIMD3(arr: any): string {
    if (Array.isArray(arr) && arr.length >= 3) {
      return `SIMD3<Float>(${arr[0]}, ${arr[1]}, ${arr[2]})`;
    }
    return `SIMD3<Float>(${arr}, ${arr}, ${arr})`;
  }

  private toUIColor(value: any): string {
    if (typeof value === 'string' && value.startsWith('#')) {
      const hex = value.slice(1);
      const r = parseInt(hex.substring(0, 2), 16) / 255;
      const g = parseInt(hex.substring(2, 4), 16) / 255;
      const b = parseInt(hex.substring(4, 6), 16) / 255;
      return `.init(red: ${r.toFixed(3)}, green: ${g.toFixed(3)}, blue: ${b.toFixed(3)}, alpha: 1.0)`;
    }
    return '.white';
  }

  private toSwiftType(value: HoloValue): string {
    if (typeof value === 'number') return Number.isInteger(value) ? 'Int' : 'Float';
    if (typeof value === 'boolean') return 'Bool';
    if (typeof value === 'string') return 'String';
    if (Array.isArray(value)) return '[Any]';
    return 'Any';
  }

  private toSwiftValue(value: HoloValue): string {
    if (typeof value === 'number') return Number.isInteger(value) ? `${value}` : `${value}`;
    if (typeof value === 'boolean') return value ? 'true' : 'false';
    if (typeof value === 'string') return `"${value}"`;
    if (value === null) return 'nil';
    return 'nil';
  }

  private findObjProp(obj: HoloObjectDecl, key: string): HoloValue | undefined {
    return obj.properties?.find(p => p.key === key)?.value;
  }
}
