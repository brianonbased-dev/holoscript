/**
 * HoloScript → Unity C# Compiler
 *
 * Translates a HoloComposition AST into a Unity C# MonoBehaviour script
 * that recreates the scene programmatically at runtime.
 *
 * Emits:
 *   - A single C# class inheriting MonoBehaviour
 *   - Awake() method for scene construction
 *   - GameObjects with MeshRenderer, MeshFilter, Collider, Rigidbody
 *   - Light components, Camera setup, Audio sources
 *   - Timeline/animation via DOTween-compatible calls (comments)
 *
 * @version 1.0.0
 */

import type {
  HoloComposition,
  HoloObjectDecl,
  HoloSpatialGroup,
  HoloLight,
  HoloEnvironment,
  HoloCamera,
  HoloTimeline,
  HoloAudio,
  HoloZone,
  HoloUI,
  HoloTransition,
  HoloValue,
  HoloEffects,
} from '../parser/HoloCompositionTypes';

export interface UnityCompilerOptions {
  namespace?: string;
  className?: string;
  useURP?: boolean;
  indent?: string;
}

export class UnityCompiler {
  private options: Required<UnityCompilerOptions>;
  private lines: string[] = [];
  private indentLevel: number = 0;

  constructor(options: UnityCompilerOptions = {}) {
    this.options = {
      namespace: options.namespace || 'HoloScene',
      className: options.className || 'GeneratedScene',
      useURP: options.useURP ?? true,
      indent: options.indent || '    ',
    };
  }

  compile(composition: HoloComposition): string {
    this.lines = [];
    this.indentLevel = 0;

    this.emit('// Auto-generated by HoloScript UnityCompiler');
    this.emit(`// Source: composition "${composition.name}"`);
    this.emit('// Do not edit manually — regenerate from .holo source');
    this.emit('');
    this.emit('using UnityEngine;');
    this.emit('using UnityEngine.UI;');
    if (composition.timelines?.length) this.emit('using System.Collections;');
    this.emit('');

    this.emit(`namespace ${this.options.namespace}`);
    this.emit('{');
    this.indentLevel++;

    this.emit(`public class ${this.options.className} : MonoBehaviour`);
    this.emit('{');
    this.indentLevel++;

    // State fields
    if (composition.state) {
      this.emit('// === State ===');
      for (const prop of composition.state.properties) {
        const csType = this.toCSharpType(prop.value);
        const csVal = this.toCSharpValue(prop.value);
        this.emit(`private ${csType} ${prop.key} = ${csVal};`);
      }
      this.emit('');
    }

    // Awake method
    this.emit('private void Awake()');
    this.emit('{');
    this.indentLevel++;

    // Environment
    if (composition.environment) {
      this.compileEnvironment(composition.environment);
    }

    // Lights
    if (composition.lights) {
      for (const light of composition.lights) {
        this.compileLight(light);
      }
    }

    // Camera
    if (composition.camera) {
      this.compileCamera(composition.camera);
    }

    // Objects
    if (composition.objects) {
      for (const obj of composition.objects) {
        this.compileObject(obj, 'transform');
      }
    }

    // Spatial groups
    if (composition.spatialGroups) {
      for (const group of composition.spatialGroups) {
        this.compileSpatialGroup(group, 'transform');
      }
    }

    // Audio
    if (composition.audio) {
      for (const audio of composition.audio) {
        this.compileAudio(audio);
      }
    }

    // Zones
    if (composition.zones) {
      for (const zone of composition.zones) {
        this.compileZone(zone);
      }
    }

    // Timelines (as coroutines)
    if (composition.timelines) {
      for (const tl of composition.timelines) {
        if (tl.autoplay) {
          this.emit(`StartCoroutine(${this.sanitizeName(tl.name)}Routine());`);
        }
      }
    }

    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Timeline coroutines
    if (composition.timelines) {
      for (const tl of composition.timelines) {
        this.compileTimeline(tl);
      }
    }

    // Effects (as comments — URP post-processing is config-based)
    if (composition.effects) {
      this.compileEffects(composition.effects);
    }

    // Transitions (as methods)
    if (composition.transitions) {
      for (const tr of composition.transitions) {
        this.compileTransition(tr);
      }
    }

    // UI
    if (composition.ui) {
      this.compileUI(composition.ui);
    }

    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');

    return this.lines.join('\n');
  }

  private compileEnvironment(env: HoloEnvironment): void {
    this.emit('// === Environment ===');
    for (const prop of env.properties) {
      if (prop.key === 'preset' || prop.key === 'skybox') {
        this.emit(`RenderSettings.skybox = Resources.Load<Material>("Skybox/${prop.value}");`);
      } else if (prop.key === 'fog' && typeof prop.value === 'object') {
        const fog = prop.value as Record<string, any>;
        this.emit('RenderSettings.fog = true;');
        if (fog.color) this.emit(`RenderSettings.fogColor = ${this.toColor(fog.color)};`);
        if (fog.near !== undefined) this.emit(`RenderSettings.fogStartDistance = ${fog.near}f;`);
        if (fog.far !== undefined) this.emit(`RenderSettings.fogEndDistance = ${fog.far}f;`);
      } else if (prop.key === 'ambient_light') {
        this.emit(`RenderSettings.ambientIntensity = ${prop.value}f;`);
      }
    }
    this.emit('');
  }

  private compileLight(light: HoloLight): void {
    const varName = this.sanitizeName(light.name);
    this.emit(`// Light: ${light.name}`);
    this.emit(`var ${varName}GO = new GameObject("${light.name}");`);
    this.emit(`${varName}GO.transform.SetParent(transform);`);
    this.emit(`var ${varName} = ${varName}GO.AddComponent<Light>();`);

    const typeMap: Record<string, string> = {
      directional: 'LightType.Directional',
      point: 'LightType.Point',
      spot: 'LightType.Spot',
      area: 'LightType.Area',
    };
    this.emit(`${varName}.type = ${typeMap[light.lightType] || 'LightType.Directional'};`);

    for (const prop of light.properties) {
      if (prop.key === 'color') {
        this.emit(`${varName}.color = ${this.toColor(prop.value)};`);
      } else if (prop.key === 'intensity') {
        this.emit(`${varName}.intensity = ${prop.value}f;`);
      } else if (prop.key === 'position' && Array.isArray(prop.value)) {
        this.emit(`${varName}GO.transform.position = ${this.toVector3(prop.value)};`);
      } else if (prop.key === 'cast_shadow' || prop.key === 'castShadow') {
        this.emit(`${varName}.shadows = ${prop.value ? 'LightShadows.Soft' : 'LightShadows.None'};`);
      } else if (prop.key === 'angle') {
        this.emit(`${varName}.spotAngle = ${(prop.value as number) * (180 / Math.PI)}f;`);
      } else if (prop.key === 'distance') {
        this.emit(`${varName}.range = ${prop.value}f;`);
      }
    }
    this.emit('');
  }

  private compileCamera(camera: HoloCamera): void {
    this.emit('// === Camera ===');
    this.emit('var cam = Camera.main;');
    this.emit(`cam.fieldOfView = ${this.findProp(camera.properties, 'fov') || 60}f;`);
    const pos = this.findProp(camera.properties, 'position');
    if (pos) this.emit(`cam.transform.position = ${this.toVector3(pos as any)};`);
    const lookAt = this.findProp(camera.properties, 'look_at') || this.findProp(camera.properties, 'lookAt');
    if (lookAt) this.emit(`cam.transform.LookAt(${this.toVector3(lookAt as any)});`);
    const near = this.findProp(camera.properties, 'near');
    if (near) this.emit(`cam.nearClipPlane = ${near}f;`);
    const far = this.findProp(camera.properties, 'far');
    if (far) this.emit(`cam.farClipPlane = ${far}f;`);
    this.emit('');
  }

  private compileObject(obj: HoloObjectDecl, parentVar: string): void {
    const varName = this.sanitizeName(obj.name);
    const meshType = this.findObjProp(obj, 'mesh') || this.findObjProp(obj, 'type') || 'cube';
    const isText = meshType === 'text';
    const isSparkles = meshType === 'sparkles';
    const isModel = !!this.findObjProp(obj, 'model') || !!this.findObjProp(obj, 'src');

    this.emit(`// Object: ${obj.name}`);

    if (isText) {
      this.emit(`var ${varName}GO = new GameObject("${obj.name}");`);
      this.emit(`${varName}GO.transform.SetParent(${parentVar});`);
      this.emit(`var ${varName}TM = ${varName}GO.AddComponent<TextMesh>();`);
      const text = this.findObjProp(obj, 'text');
      if (text) this.emit(`${varName}TM.text = "${text}";`);
      const fontSize = this.findObjProp(obj, 'font_size');
      if (fontSize) this.emit(`${varName}TM.fontSize = ${Math.round((fontSize as number) * 100)};`);
      const color = this.findObjProp(obj, 'color');
      if (color) this.emit(`${varName}TM.color = ${this.toColor(color)};`);
    } else if (isModel) {
      const src = this.findObjProp(obj, 'model') || this.findObjProp(obj, 'src');
      this.emit(`var ${varName}GO = Instantiate(Resources.Load<GameObject>("Models/${src}"));`);
      this.emit(`${varName}GO.name = "${obj.name}";`);
      this.emit(`${varName}GO.transform.SetParent(${parentVar});`);
    } else if (isSparkles) {
      this.emit(`// Sparkles: use ParticleSystem for "${obj.name}"`);
      this.emit(`var ${varName}GO = new GameObject("${obj.name}");`);
      this.emit(`${varName}GO.transform.SetParent(${parentVar});`);
      this.emit(`${varName}GO.AddComponent<ParticleSystem>();`);
    } else {
      const primitiveMap: Record<string, string> = {
        cube: 'PrimitiveType.Cube', box: 'PrimitiveType.Cube',
        sphere: 'PrimitiveType.Sphere', cylinder: 'PrimitiveType.Cylinder',
        plane: 'PrimitiveType.Plane', capsule: 'PrimitiveType.Capsule',
      };
      const primitive = primitiveMap[meshType as string] || 'PrimitiveType.Cube';
      this.emit(`var ${varName}GO = GameObject.CreatePrimitive(${primitive});`);
      this.emit(`${varName}GO.name = "${obj.name}";`);
      this.emit(`${varName}GO.transform.SetParent(${parentVar});`);
    }

    // Position, rotation, scale
    const pos = this.findObjProp(obj, 'position');
    if (pos) this.emit(`${varName}GO.transform.localPosition = ${this.toVector3(pos as any)};`);
    const rot = this.findObjProp(obj, 'rotation');
    if (rot) this.emit(`${varName}GO.transform.localEulerAngles = ${this.toVector3(rot as any)};`);
    const scale = this.findObjProp(obj, 'scale');
    if (scale) this.emit(`${varName}GO.transform.localScale = ${this.toVector3(scale as any)};`);
    const size = this.findObjProp(obj, 'size');
    if (size && !isText) {
      if (Array.isArray(size)) {
        this.emit(`${varName}GO.transform.localScale = ${this.toVector3(size)};`);
      } else {
        this.emit(`${varName}GO.transform.localScale = Vector3.one * ${size}f;`);
      }
    }

    // Material
    const material = this.findObjProp(obj, 'material');
    if (material && typeof material === 'object' && !isText && !isModel) {
      this.emit(`var ${varName}Mat = ${varName}GO.GetComponent<Renderer>().material;`);
      const mat = material as Record<string, any>;
      if (mat.color) this.emit(`${varName}Mat.color = ${this.toColor(mat.color)};`);
      if (mat.roughness !== undefined) this.emit(`${varName}Mat.SetFloat("_Smoothness", ${1 - mat.roughness}f);`);
      if (mat.metalness !== undefined) this.emit(`${varName}Mat.SetFloat("_Metallic", ${mat.metalness}f);`);
      if (mat.emissive) {
        this.emit(`${varName}Mat.EnableKeyword("_EMISSION");`);
        this.emit(`${varName}Mat.SetColor("_EmissionColor", ${this.toColor(mat.emissive)});`);
      }
    }

    // Physics traits
    if (obj.traits) {
      for (const trait of obj.traits) {
        if (trait.name === 'collidable') {
          this.emit(`// Collider already present from primitive`);
        } else if (trait.name === 'physics' || trait.name === 'grabbable') {
          this.emit(`var ${varName}RB = ${varName}GO.AddComponent<Rigidbody>();`);
          if (trait.config?.mass) this.emit(`${varName}RB.mass = ${trait.config.mass}f;`);
        } else if (trait.name === 'portal') {
          this.emit(`// Portal: "${trait.config?.destination}" — implement via SceneManager.LoadScene()`);
        }
        // Environment Understanding
        else if (trait.name === 'plane_detection') {
          this.emit(`// @plane_detection — AR Foundation: ARPlaneManager`);
          this.emit(`// ${varName}GO.AddComponent<UnityEngine.XR.ARFoundation.ARPlaneManager>();`);
        } else if (trait.name === 'mesh_detection') {
          this.emit(`// @mesh_detection — AR Foundation: ARMeshManager`);
        } else if (trait.name === 'anchor') {
          this.emit(`// @anchor — AR Foundation: ARAnchorManager`);
        } else if (trait.name === 'persistent_anchor' || trait.name === 'shared_anchor') {
          this.emit(`// @${trait.name} — Azure Spatial Anchors or AR Foundation`);
        } else if (trait.name === 'occlusion') {
          this.emit(`// @occlusion — AR Foundation: AROcclusionManager`);
        } else if (trait.name === 'light_estimation') {
          this.emit(`// @light_estimation — AR Foundation: ARCameraManager.requestedLightEstimation`);
        } else if (trait.name === 'geospatial' || trait.name === 'geospatial_anchor' || trait.name === 'terrain_anchor' || trait.name === 'rooftop_anchor') {
          this.emit(`// @${trait.name} — ARCore Geospatial API`);
        }
        // Physics Expansion
        else if (trait.name === 'cloth') {
          this.emit(`var ${varName}Cloth = ${varName}GO.AddComponent<Cloth>();`);
          if (trait.config?.stiffness) this.emit(`${varName}Cloth.stretchingStiffness = ${trait.config.stiffness}f;`);
          if (trait.config?.damping) this.emit(`${varName}Cloth.damping = ${trait.config.damping}f;`);
        } else if (trait.name === 'wind') {
          this.emit(`var ${varName}Wind = ${varName}GO.AddComponent<WindZone>();`);
          if (trait.config?.strength) this.emit(`${varName}Wind.windMain = ${trait.config.strength}f;`);
          if (trait.config?.turbulence) this.emit(`${varName}Wind.windTurbulence = ${trait.config.turbulence}f;`);
        } else if (trait.name === 'fluid' || trait.name === 'soft_body' || trait.name === 'rope' || trait.name === 'chain' || trait.name === 'buoyancy' || trait.name === 'destruction') {
          this.emit(`// @${trait.name} — custom physics: ${JSON.stringify(trait.config || {})}`);
        }
        // Spatial Audio
        else if (trait.name === 'reverb_zone') {
          this.emit(`var ${varName}Reverb = ${varName}GO.AddComponent<AudioReverbZone>();`);
          if (trait.config?.decay_time) this.emit(`${varName}Reverb.decayTime = ${trait.config.decay_time}f;`);
        } else if (trait.name === 'audio_occlusion') {
          this.emit(`${varName}GO.AddComponent<AudioLowPassFilter>();`);
          this.emit(`// @audio_occlusion — raycast-based low-pass filter`);
        } else if (trait.name === 'ambisonics' || trait.name === 'hrtf' || trait.name === 'audio_portal' || trait.name === 'audio_material' || trait.name === 'head_tracked_audio') {
          this.emit(`// @${trait.name} — spatial audio: ${JSON.stringify(trait.config || {})}`);
        }
        // Volumetric Content
        else if (trait.name === 'gaussian_splat' || trait.name === 'nerf' || trait.name === 'volumetric_video' || trait.name === 'point_cloud' || trait.name === 'photogrammetry') {
          this.emit(`// @${trait.name} — volumetric renderer: ${JSON.stringify(trait.config || {})}`);
        }
        // Input Modalities
        else if (trait.name === 'eye_tracking') {
          this.emit(`// @eye_tracking — XR Interaction Toolkit: XREyeInteractor`);
        } else if (trait.name === 'hand_tracking') {
          this.emit(`// @hand_tracking — XR Hands: XRHandTrackingSubsystem`);
        } else if (trait.name === 'body_tracking') {
          this.emit(`// @body_tracking — XR Body Tracking subsystem`);
        } else if (trait.name === 'face_tracking') {
          this.emit(`// @face_tracking — AR Foundation: ARFaceManager`);
        }
        // Accessibility
        else if (trait.name === 'accessible') {
          this.emit(`// @accessible(role: "${trait.config?.role || 'generic'}") — Unity Accessibility`);
        }
        // Catch-all for remaining expansion traits
        else {
          this.emit(`// @${trait.name}: ${JSON.stringify(trait.config || {})}`);
        }
      }
    }

    // Children
    if (obj.children) {
      for (const child of obj.children) {
        this.compileObject(child, `${varName}GO.transform`);
      }
    }

    this.emit('');
  }

  private compileSpatialGroup(group: HoloSpatialGroup, parentVar: string): void {
    const varName = this.sanitizeName(group.name);
    this.emit(`// Spatial Group: ${group.name}`);
    this.emit(`var ${varName}GO = new GameObject("${group.name}");`);
    this.emit(`${varName}GO.transform.SetParent(${parentVar});`);

    for (const prop of group.properties) {
      if (prop.key === 'position' && Array.isArray(prop.value)) {
        this.emit(`${varName}GO.transform.localPosition = ${this.toVector3(prop.value)};`);
      }
    }

    for (const obj of group.objects) {
      this.compileObject(obj, `${varName}GO.transform`);
    }

    if (group.groups) {
      for (const sub of group.groups) {
        this.compileSpatialGroup(sub, `${varName}GO.transform`);
      }
    }

    this.emit('');
  }

  private compileAudio(audio: HoloAudio): void {
    const varName = this.sanitizeName(audio.name);
    this.emit(`// Audio: ${audio.name}`);
    this.emit(`var ${varName}GO = new GameObject("${audio.name}");`);
    this.emit(`${varName}GO.transform.SetParent(transform);`);
    this.emit(`var ${varName}AS = ${varName}GO.AddComponent<AudioSource>();`);

    for (const prop of audio.properties) {
      if (prop.key === 'src' || prop.key === 'source') {
        this.emit(`${varName}AS.clip = Resources.Load<AudioClip>("Audio/${prop.value}");`);
      } else if (prop.key === 'volume') {
        this.emit(`${varName}AS.volume = ${prop.value}f;`);
      } else if (prop.key === 'loop') {
        this.emit(`${varName}AS.loop = ${prop.value};`);
      } else if (prop.key === 'spatial') {
        this.emit(`${varName}AS.spatialBlend = ${prop.value ? '1.0f' : '0.0f'};`);
      } else if (prop.key === 'position' && Array.isArray(prop.value)) {
        this.emit(`${varName}GO.transform.position = ${this.toVector3(prop.value)};`);
      } else if (prop.key === 'distance') {
        this.emit(`${varName}AS.maxDistance = ${prop.value}f;`);
      }
    }
    this.emit(`${varName}AS.Play();`);
    this.emit('');
  }

  private compileZone(zone: HoloZone): void {
    const varName = this.sanitizeName(zone.name);
    this.emit(`// Zone: ${zone.name}`);
    this.emit(`var ${varName}GO = new GameObject("${zone.name}");`);
    this.emit(`${varName}GO.transform.SetParent(transform);`);

    for (const prop of zone.properties) {
      if (prop.key === 'position' && Array.isArray(prop.value)) {
        this.emit(`${varName}GO.transform.position = ${this.toVector3(prop.value)};`);
      } else if (prop.key === 'shape' && prop.value === 'box') {
        this.emit(`var ${varName}Col = ${varName}GO.AddComponent<BoxCollider>();`);
        this.emit(`${varName}Col.isTrigger = true;`);
      } else if (prop.key === 'shape' && prop.value === 'sphere') {
        this.emit(`var ${varName}Col = ${varName}GO.AddComponent<SphereCollider>();`);
        this.emit(`${varName}Col.isTrigger = true;`);
      } else if (prop.key === 'size' && Array.isArray(prop.value)) {
        this.emit(`${varName}GO.GetComponent<Collider>().bounds.size == ${this.toVector3(prop.value)}; // Set via scale`);
      } else if (prop.key === 'radius') {
        this.emit(`${varName}GO.GetComponent<SphereCollider>().radius = ${prop.value}f;`);
      }
    }

    if (zone.handlers?.length) {
      this.emit(`// Zone handlers: ${zone.handlers.map(h => h.event).join(', ')} — implement via OnTriggerEnter/Exit`);
    }
    this.emit('');
  }

  private compileTimeline(timeline: HoloTimeline): void {
    const varName = this.sanitizeName(timeline.name);
    this.emit(`private IEnumerator ${varName}Routine()`);
    this.emit('{');
    this.indentLevel++;

    let lastTime = 0;
    for (const entry of timeline.entries) {
      const delay = entry.time - lastTime;
      if (delay > 0) {
        this.emit(`yield return new WaitForSeconds(${delay}f);`);
      }

      if (entry.action.kind === 'animate') {
        this.emit(`// Animate "${entry.action.target}" — use DOTween or AnimationCurve`);
        const props = entry.action.properties;
        for (const [key, value] of Object.entries(props)) {
          this.emit(`// ${key}: ${JSON.stringify(value)}`);
        }
      } else if (entry.action.kind === 'emit') {
        this.emit(`// Emit event: "${entry.action.event}"`);
      } else if (entry.action.kind === 'call') {
        this.emit(`// Call: ${entry.action.method}(${entry.action.args?.join(', ') || ''})`);
      }

      lastTime = entry.time;
    }

    if (timeline.loop) {
      this.emit(`StartCoroutine(${varName}Routine()); // loop`);
    }

    this.indentLevel--;
    this.emit('}');
    this.emit('');
  }

  private compileEffects(effects: HoloEffects): void {
    this.emit('// === Post-Processing (configure via URP Volume) ===');
    for (const effect of effects.effects) {
      this.emit(`// Effect: ${effect.effectType} — ${JSON.stringify(effect.properties)}`);
    }
    this.emit('');
  }

  private compileTransition(tr: HoloTransition): void {
    const varName = this.sanitizeName(tr.name);
    this.emit(`public void ${varName}()`);
    this.emit('{');
    this.indentLevel++;

    for (const prop of tr.properties) {
      if (prop.key === 'target') {
        this.emit(`// Load scene: "${prop.value}"`);
        this.emit(`UnityEngine.SceneManagement.SceneManager.LoadScene("${prop.value}");`);
      } else if (prop.key === 'effect') {
        this.emit(`// Transition effect: ${prop.value}`);
      } else if (prop.key === 'duration') {
        this.emit(`// Duration: ${prop.value}s`);
      }
    }

    this.indentLevel--;
    this.emit('}');
    this.emit('');
  }

  private compileUI(ui: HoloUI): void {
    this.emit('// === UI Setup ===');
    this.emit('// Create Canvas for HUD overlay');
    this.emit('var canvasGO = new GameObject("HoloUI");');
    this.emit('canvasGO.transform.SetParent(transform);');
    this.emit('var canvas = canvasGO.AddComponent<Canvas>();');
    this.emit('canvas.renderMode = RenderMode.ScreenSpaceOverlay;');
    this.emit('canvasGO.AddComponent<CanvasScaler>();');
    this.emit('');

    for (const el of ui.elements) {
      const varName = this.sanitizeName(el.name);
      const elType = el.properties.find(p => p.key === 'type')?.value;

      this.emit(`// UI Element: ${el.name} (${elType})`);
      this.emit(`var ${varName}GO = new GameObject("${el.name}");`);
      this.emit(`${varName}GO.transform.SetParent(canvasGO.transform);`);

      if (elType === 'text') {
        this.emit(`var ${varName}Text = ${varName}GO.AddComponent<Text>();`);
        const text = el.properties.find(p => p.key === 'text')?.value;
        if (text) this.emit(`${varName}Text.text = "${text}";`);
      } else if (elType === 'progress') {
        this.emit(`var ${varName}Slider = ${varName}GO.AddComponent<Slider>();`);
      }
      this.emit('');
    }
  }

  // ─── Helpers ───────────────────────────────────────────────────────────

  private emit(line: string): void {
    this.lines.push(this.options.indent.repeat(this.indentLevel) + line);
  }

  private sanitizeName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_');
  }

  private toVector3(arr: any): string {
    if (Array.isArray(arr) && arr.length >= 3) {
      return `new Vector3(${arr[0]}f, ${arr[1]}f, ${arr[2]}f)`;
    }
    if (Array.isArray(arr) && arr.length === 2) {
      return `new Vector2(${arr[0]}f, ${arr[1]}f)`;
    }
    return `new Vector3(${arr}f, ${arr}f, ${arr}f)`;
  }

  private toColor(value: any): string {
    if (typeof value === 'string' && value.startsWith('#')) {
      const hex = value.slice(1);
      const r = parseInt(hex.substring(0, 2), 16) / 255;
      const g = parseInt(hex.substring(2, 4), 16) / 255;
      const b = parseInt(hex.substring(4, 6), 16) / 255;
      return `new Color(${r.toFixed(3)}f, ${g.toFixed(3)}f, ${b.toFixed(3)}f)`;
    }
    return `Color.white`;
  }

  private toCSharpType(value: HoloValue): string {
    if (typeof value === 'number') return Number.isInteger(value) ? 'int' : 'float';
    if (typeof value === 'boolean') return 'bool';
    if (typeof value === 'string') return 'string';
    if (Array.isArray(value)) return 'object[]';
    return 'object';
  }

  private toCSharpValue(value: HoloValue): string {
    if (typeof value === 'number') return Number.isInteger(value) ? `${value}` : `${value}f`;
    if (typeof value === 'boolean') return value ? 'true' : 'false';
    if (typeof value === 'string') return `"${value}"`;
    if (value === null) return 'null';
    return 'null';
  }

  private findProp(props: any[], key: string): HoloValue | undefined {
    return props?.find((p: any) => p.key === key)?.value;
  }

  private findObjProp(obj: HoloObjectDecl, key: string): HoloValue | undefined {
    return obj.properties?.find(p => p.key === key)?.value;
  }
}
