/**
 * SDFCompiler Tests
 *
 * Tests for the HoloScript → SDF (Simulation Description Format) compiler.
 * Verifies correct XML generation for Gazebo simulation.
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { SDFCompiler, type SDFCompilerOptions } from './SDFCompiler';
import type { HoloComposition, HoloObjectDecl, HoloLight } from '../parser/HoloCompositionTypes';

describe('SDFCompiler', () => {
  let compiler: SDFCompiler;

  beforeEach(() => {
    compiler = new SDFCompiler();
  });

  // Helper to create a minimal composition
  function createComposition(overrides: Partial<HoloComposition> = {}): HoloComposition {
    return {
      type: 'Composition',
      name: 'TestWorld',
      objects: [],
      templates: [],
      spatialGroups: [],
      lights: [],
      imports: [],
      timelines: [],
      audio: [],
      zones: [],
      transitions: [],
      conditionals: [],
      iterators: [],
      npcs: [],
      quests: [],
      abilities: [],
      dialogues: [],
      stateMachines: [],
      achievements: [],
      talentTrees: [],
      shapes: [],
      ...overrides,
    };
  }

  // Helper to create an object declaration
  function createObject(overrides: Partial<HoloObjectDecl> = {}): HoloObjectDecl {
    return {
      name: 'TestObject',
      properties: [],
      traits: [],
      ...overrides,
    } as HoloObjectDecl;
  }

  // Helper to create a light
  function createLight(overrides: Partial<HoloLight> = {}): HoloLight {
    return {
      name: 'TestLight',
      type: 'point',
      ...overrides,
    } as HoloLight;
  }

  describe('Basic Compilation', () => {
    it('should generate valid SDF XML structure', () => {
      const composition = createComposition();
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<?xml version="1.0"?>');
      expect(sdf).toContain('<sdf version="1.8">');
      expect(sdf).toContain('<world name="holoscript_world">');
      expect(sdf).toContain('</world>');
      expect(sdf).toContain('</sdf>');
    });

    it('should include XML declaration and comments', () => {
      const composition = createComposition({ name: 'MyWorld' });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<!-- Auto-generated by HoloScript SDFCompiler -->');
      expect(sdf).toContain('<!-- Source: composition "MyWorld" -->');
    });

    it('should include ground plane by default', () => {
      const composition = createComposition();
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<model name="ground_plane">');
      expect(sdf).toContain('<static>true</static>');
      expect(sdf).toContain('<plane>');
      expect(sdf).toContain('<normal>0 0 1</normal>');
    });

    it('should include sun light by default', () => {
      const composition = createComposition();
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<light name="sun" type="directional">');
      expect(sdf).toContain('<cast_shadows>true</cast_shadows>');
    });
  });

  describe('Custom Options', () => {
    it('should use custom world name', () => {
      const customCompiler = new SDFCompiler({ worldName: 'my_custom_world' });
      const composition = createComposition();
      const sdf = customCompiler.compile(composition);

      expect(sdf).toContain('<world name="my_custom_world">');
    });

    it('should use custom SDF version', () => {
      const customCompiler = new SDFCompiler({ sdfVersion: '1.9' });
      const composition = createComposition();
      const sdf = customCompiler.compile(composition);

      expect(sdf).toContain('<sdf version="1.9">');
    });

    it('should exclude physics when includePhysics is false', () => {
      const customCompiler = new SDFCompiler({ includePhysics: false });
      const composition = createComposition();
      const sdf = customCompiler.compile(composition);

      expect(sdf).not.toContain('<physics name="default_physics"');
    });

    it('should exclude scene when includeScene is false', () => {
      const customCompiler = new SDFCompiler({ includeScene: false });
      const composition = createComposition();
      const sdf = customCompiler.compile(composition);

      expect(sdf).not.toContain('<scene>');
    });

    it('should use custom physics engine', () => {
      const customCompiler = new SDFCompiler({ physicsEngine: 'bullet' });
      const composition = createComposition();
      const sdf = customCompiler.compile(composition);

      expect(sdf).toContain('<physics name="default_physics" type="bullet">');
    });

    it('should use custom real-time factor', () => {
      const customCompiler = new SDFCompiler({ realTimeFactor: 0.5 });
      const composition = createComposition();
      const sdf = customCompiler.compile(composition);

      expect(sdf).toContain('<real_time_factor>0.5</real_time_factor>');
    });

    it('should use custom mesh path prefix', () => {
      const customCompiler = new SDFCompiler({ meshPathPrefix: 'file:///meshes/' });
      const composition = createComposition({
        objects: [
          createObject({
            name: 'CustomMesh',
            properties: [{ key: 'geometry', value: 'robot.dae' }],
          }),
        ],
      });
      const sdf = customCompiler.compile(composition);

      expect(sdf).toContain('file:///meshes/robot.dae');
    });
  });

  describe('Physics Configuration', () => {
    it('should include ODE solver settings by default', () => {
      const composition = createComposition();
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<ode>');
      expect(sdf).toContain('<solver>');
      expect(sdf).toContain('<type>quick</type>');
      expect(sdf).toContain('<iters>50</iters>');
      expect(sdf).toContain('<constraints>');
    });

    it('should include step size and update rate', () => {
      const composition = createComposition();
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<max_step_size>0.001</max_step_size>');
      expect(sdf).toContain('<real_time_update_rate>1000</real_time_update_rate>');
    });

    it('should not include ODE settings for other physics engines', () => {
      const customCompiler = new SDFCompiler({ physicsEngine: 'dart' });
      const composition = createComposition();
      const sdf = customCompiler.compile(composition);

      expect(sdf).not.toContain('<ode>');
    });
  });

  describe('Scene Configuration', () => {
    it('should set ambient light from environment', () => {
      const composition = createComposition({
        environment: { ambient_light: 0.6 },
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<ambient>0.6 0.6 0.6 1</ambient>');
    });

    it('should map skybox to background color', () => {
      const composition = createComposition({
        environment: { skybox: 'sunset' },
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<background>0.9 0.5 0.3 1</background>');
    });

    it('should handle night skybox', () => {
      const composition = createComposition({
        environment: { skybox: 'night' },
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<background>0.05 0.05 0.1 1</background>');
    });

    it('should handle nebula skybox', () => {
      const composition = createComposition({
        environment: { skybox: 'nebula' },
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<background>0.1 0.05 0.2 1</background>');
    });

    it('should enable shadows', () => {
      const composition = createComposition();
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<shadows>true</shadows>');
    });

    it('should use default ambient when not specified', () => {
      const composition = createComposition();
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<ambient>0.4 0.4 0.4 1</ambient>');
    });
  });

  describe('Object Processing', () => {
    it('should create model for each object', () => {
      const composition = createComposition({
        objects: [createObject({ name: 'Object1' }), createObject({ name: 'Object2' })],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<model name="object1">');
      expect(sdf).toContain('<model name="object2">');
    });

    it('should mark static objects without physics traits', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'StaticBox',
            traits: [], // No physics
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<static>true</static>');
    });

    it('should not mark dynamic objects as static', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'DynamicBox',
            traits: ['physics'],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      // Count static tags - should only be ground plane
      const staticCount = (sdf.match(/<static>true<\/static>/g) || []).length;
      expect(staticCount).toBe(1); // Only ground plane
    });

    it('should include link for each model', () => {
      const composition = createComposition({
        objects: [createObject({ name: 'MyModel' })],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<link name="mymodel_link">');
    });

    it('should sanitize object names', () => {
      const composition = createComposition({
        objects: [createObject({ name: 'My Object #1!' })],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<model name="my_object__1_">');
    });
  });

  describe('Geometry Handling', () => {
    it('should generate box geometry for cube', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Cube',
            properties: [
              { key: 'geometry', value: 'cube' },
              { key: 'scale', value: 2 },
            ],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<box><size>2 2 2</size></box>');
    });

    it('should generate sphere geometry', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Sphere',
            properties: [
              { key: 'geometry', value: 'sphere' },
              { key: 'scale', value: 2 },
            ],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<sphere><radius>1</radius></sphere>');
    });

    it('should generate cylinder geometry', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Cylinder',
            properties: [
              { key: 'geometry', value: 'cylinder' },
              { key: 'scale', value: 1 },
            ],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<cylinder><radius>0.5</radius><length>1</length></cylinder>');
    });

    it('should generate plane geometry', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Floor',
            properties: [
              { key: 'geometry', value: 'plane' },
              { key: 'scale', value: 10 },
            ],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<plane><normal>0 0 1</normal><size>10 10</size></plane>');
    });

    it('should generate capsule geometry', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Capsule',
            properties: [
              { key: 'geometry', value: 'capsule' },
              { key: 'scale', value: 3 },
            ],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<capsule><radius>1</radius><length>3</length></capsule>');
    });

    it('should handle mesh files', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Robot',
            properties: [{ key: 'geometry', value: 'robot.dae' }],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<mesh><uri>model://robot.dae</uri></mesh>');
    });

    it('should default to box geometry', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Unknown',
            properties: [{ key: 'geometry', value: 'unknowntype' }],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<box>');
    });
  });

  describe('Position and Rotation', () => {
    it('should include pose with position', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'PositionedObject',
            properties: [{ key: 'position', value: [1, 2, 3] }],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<pose>1 2 3');
    });

    it('should convert rotation from degrees to radians', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'RotatedObject',
            properties: [{ key: 'rotation', value: [90, 0, 0] }],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      // 90 degrees = π/2 radians ≈ 1.570796
      expect(sdf).toMatch(/pose>0 0 0 1\.5707/);
    });

    it('should default position and rotation to zero', () => {
      const composition = createComposition({
        objects: [createObject({ name: 'DefaultPose' })],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<pose>0 0 0 0 0 0</pose>');
    });
  });

  describe('Inertial Properties', () => {
    it('should include inertial for dynamic objects', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Dynamic',
            traits: ['physics'],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<inertial>');
      expect(sdf).toContain('<mass>');
      expect(sdf).toContain('<inertia>');
    });

    it('should extract mass from physics property', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Heavy',
            properties: [{ key: 'physics', value: { mass: 10 } }],
            traits: ['physics'],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<mass>10</mass>');
    });

    it('should use default mass of 1.0', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'DefaultMass',
            traits: ['physics'],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<mass>1</mass>');
    });

    it('should not include inertial for static objects', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Static',
            traits: [],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      // Count inertial tags - should not be in static model
      const modelSection = sdf.substring(
        sdf.indexOf('<model name="static">'),
        sdf.indexOf('</model>', sdf.indexOf('<model name="static">'))
      );
      expect(modelSection).not.toContain('<inertial>');
    });
  });

  describe('Collision Handling', () => {
    it('should add collision for collidable objects', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Collidable',
            properties: [{ key: 'geometry', value: 'cube' }],
            traits: ['collidable'],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      // Find the model section
      const modelSection = sdf.substring(
        sdf.indexOf('<model name="collidable">'),
        sdf.indexOf('</model>', sdf.indexOf('<model name="collidable">'))
      );
      expect(modelSection).toContain('<collision name="collision">');
    });

    it('should add collision for physics objects', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'PhysicsBody',
            properties: [{ key: 'geometry', value: 'sphere' }],
            traits: ['physics'],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      const modelSection = sdf.substring(
        sdf.indexOf('<model name="physicsbody">'),
        sdf.indexOf('</model>', sdf.indexOf('<model name="physicsbody">'))
      );
      expect(modelSection).toContain('<collision name="collision">');
    });

    it('should add collision for rigid objects', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'RigidBody',
            properties: [{ key: 'geometry', value: 'cube' }],
            traits: ['rigid'],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      const modelSection = sdf.substring(
        sdf.indexOf('<model name="rigidbody">'),
        sdf.indexOf('</model>', sdf.indexOf('<model name="rigidbody">'))
      );
      expect(modelSection).toContain('<collision name="collision">');
    });
  });

  describe('Visual and Material', () => {
    it('should always include visual for objects', () => {
      const composition = createComposition({
        objects: [createObject({ name: 'VisualObject' })],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<visual name="visual">');
    });

    it('should parse hex colors', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'ColoredBox',
            properties: [{ key: 'color', value: '#ff0000' }],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<ambient>1 0 0 1</ambient>');
      expect(sdf).toContain('<diffuse>1 0 0 1</diffuse>');
    });

    it('should parse named colors', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'GreenBox',
            properties: [{ key: 'color', value: 'green' }],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<ambient>0 1 0 1</ambient>');
    });

    it('should add emissive for glowing objects', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'GlowingOrb',
            properties: [{ key: 'color', value: '#ff00ff' }],
            traits: ['glowing'],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<emissive>');
    });

    it('should add emissive for emissive trait', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'EmissiveLight',
            properties: [{ key: 'color', value: 'yellow' }],
            traits: ['emissive'],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<emissive>');
    });

    it('should use default color when not specified', () => {
      const composition = createComposition({
        objects: [createObject({ name: 'DefaultColor' })],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<ambient>0.7 0.7 0.7 1</ambient>');
    });
  });

  describe('Light Processing', () => {
    it('should process point lights', () => {
      const composition = createComposition({
        lights: [
          createLight({
            name: 'PointLight',
            type: 'point',
            position: [0, 0, 5],
            color: '#ffffff',
            intensity: 1.0,
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<light name="pointlight" type="point">');
    });

    it('should process directional lights', () => {
      const composition = createComposition({
        lights: [
          createLight({
            name: 'DirectionalLight',
            type: 'directional',
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<light name="directionallight" type="directional">');
    });

    it('should process spot lights with angle', () => {
      const composition = createComposition({
        lights: [
          createLight({
            name: 'SpotLight',
            type: 'spot',
            angle: 30,
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<light name="spotlight" type="spot">');
      expect(sdf).toContain('<spot>');
      expect(sdf).toContain('<inner_angle>');
      expect(sdf).toContain('<outer_angle>');
      expect(sdf).toContain('<falloff>');
    });

    it('should include light position as pose', () => {
      const composition = createComposition({
        lights: [
          createLight({
            name: 'PositionedLight',
            position: [1, 2, 3],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<pose>1 2 3 0 0 0</pose>');
    });

    it('should include light color and intensity', () => {
      const composition = createComposition({
        lights: [
          createLight({
            name: 'ColorLight',
            color: '#ff0000',
            intensity: 2.0,
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      // Red channel * intensity = 1 * 2 = 2
      expect(sdf).toContain('<diffuse>2 0 0 1</diffuse>');
    });

    it('should include attenuation for lights with range', () => {
      const composition = createComposition({
        lights: [
          createLight({
            name: 'RangedLight',
            range: 10,
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<attenuation>');
      expect(sdf).toContain('<range>10</range>');
    });

    it('should honor castShadow property', () => {
      const composition = createComposition({
        lights: [
          createLight({
            name: 'NoShadowLight',
            castShadow: false,
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<cast_shadows>false</cast_shadows>');
    });
  });

  describe('Spatial Groups', () => {
    it('should add comment for spatial groups', () => {
      const composition = createComposition({
        spatialGroups: [
          {
            name: 'ObjectGroup',
            objects: [],
          },
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<!-- Spatial Group: ObjectGroup -->');
    });

    it('should process objects within spatial groups', () => {
      const composition = createComposition({
        spatialGroups: [
          {
            name: 'MyGroup',
            objects: [
              createObject({ name: 'GroupedObject1' }),
              createObject({ name: 'GroupedObject2' }),
            ],
          },
        ],
      });
      const sdf = compiler.compile(composition);

      expect(sdf).toContain('<model name="groupedobject1">');
      expect(sdf).toContain('<model name="groupedobject2">');
    });
  });

  describe('XML Escaping', () => {
    it('should escape special characters in world name', () => {
      const customCompiler = new SDFCompiler({ worldName: 'World<>&"Test' });
      const composition = createComposition();
      const sdf = customCompiler.compile(composition);

      expect(sdf).toContain('&lt;');
      expect(sdf).toContain('&gt;');
      expect(sdf).toContain('&amp;');
      expect(sdf).toContain('&quot;');
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty composition', () => {
      const composition = createComposition();
      const sdf = compiler.compile(composition);

      expect(sdf).toBeDefined();
      expect(sdf).toContain('<sdf');
      expect(sdf).toContain('</sdf>');
    });

    it('should handle object without geometry', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'NoGeometry',
            properties: [],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      // Should default to box
      expect(sdf).toContain('<box>');
    });

    it('should handle array scale values', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'ArrayScale',
            properties: [
              { key: 'geometry', value: 'cube' },
              { key: 'scale', value: [2, 3, 4] },
            ],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      // Should use first value
      expect(sdf).toContain('<size>2 2 2</size>');
    });

    it('should handle light without optional properties', () => {
      const composition = createComposition({
        lights: [
          createLight({
            name: 'MinimalLight',
          }),
        ],
      });

      expect(() => compiler.compile(composition)).not.toThrow();
    });

    it('should handle unknown light type', () => {
      const composition = createComposition({
        lights: [
          createLight({
            name: 'UnknownType',
            type: 'area' as any, // Unknown type
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      // Should default to point
      expect(sdf).toContain('type="point"');
    });

    it('should handle unknown named color', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'UnknownColor',
            properties: [{ key: 'color', value: 'ultraviolet' }],
          }),
        ],
      });
      const sdf = compiler.compile(composition);

      // Should use default gray
      expect(sdf).toContain('<ambient>0.7 0.7 0.7 1</ambient>');
    });
  });

  describe('Integration', () => {
    it('should compile a complex scene composition', () => {
      const composition = createComposition({
        name: 'RoboticsLab',
        environment: {
          skybox: 'day',
          ambient_light: 0.5,
        },
        objects: [
          createObject({
            name: 'WorkTable',
            properties: [
              { key: 'geometry', value: 'box' },
              { key: 'position', value: [0, 0, 0.5] },
              { key: 'scale', value: 2 },
              { key: 'color', value: '#8B4513' },
            ],
            traits: ['collidable'],
          }),
          createObject({
            name: 'RobotArm',
            properties: [
              { key: 'geometry', value: 'robot_arm.dae' },
              { key: 'position', value: [0, 0, 1] },
              { key: 'physics', value: { mass: 5 } },
            ],
            traits: ['physics', 'collidable'],
          }),
          createObject({
            name: 'TargetBall',
            properties: [
              { key: 'geometry', value: 'sphere' },
              { key: 'position', value: [1, 0, 1.2] },
              { key: 'scale', value: 0.1 },
              { key: 'color', value: 'red' },
              { key: 'physics', value: { mass: 0.1 } },
            ],
            traits: ['physics', 'collidable', 'grabbable'],
          }),
        ],
        lights: [
          createLight({
            name: 'OverheadLight',
            type: 'point',
            position: [0, 0, 3],
            color: '#ffffff',
            intensity: 1.5,
            range: 10,
          }),
          createLight({
            name: 'SpotlightOnTable',
            type: 'spot',
            position: [0, 2, 2],
            angle: 45,
            castShadow: true,
          }),
        ],
        spatialGroups: [
          {
            name: 'Tools',
            objects: [
              createObject({
                name: 'Wrench',
                properties: [
                  { key: 'geometry', value: 'wrench.stl' },
                  { key: 'position', value: [0.5, 0, 1.05] },
                ],
                traits: ['grabbable'],
              }),
            ],
          },
        ],
      });

      const customCompiler = new SDFCompiler({
        worldName: 'robotics_lab',
        physicsEngine: 'ode',
        realTimeFactor: 1.0,
      });
      const sdf = customCompiler.compile(composition);

      // Verify structure
      expect(sdf).toContain('<world name="robotics_lab">');
      expect(sdf).toContain('<model name="worktable">');
      expect(sdf).toContain('<model name="robotarm">');
      expect(sdf).toContain('<model name="targetball">');

      // Verify environment
      expect(sdf).toContain('<ambient>0.5 0.5 0.5 1</ambient>');
      expect(sdf).toContain('<background>0.3 0.5 0.9 1</background>'); // day skybox

      // Verify physics
      expect(sdf).toContain('<mass>5</mass>');
      expect(sdf).toContain('<mass>0.1</mass>');

      // Verify lights
      expect(sdf).toContain('<light name="overheadlight" type="point">');
      expect(sdf).toContain('<light name="spotlightontable" type="spot">');
      expect(sdf).toContain('<attenuation>');
      expect(sdf).toContain('<spot>');

      // Verify spatial group
      expect(sdf).toContain('<!-- Spatial Group: Tools -->');
      expect(sdf).toContain('<model name="wrench">');

      // Verify mesh references
      expect(sdf).toContain('<mesh><uri>model://robot_arm.dae</uri></mesh>');
      expect(sdf).toContain('<mesh><uri>model://wrench.stl</uri></mesh>');

      // Verify colors
      expect(sdf).toContain('<ambient>1 0 0 1</ambient>'); // red ball
    });
  });
});
