/**
 * USDPhysicsCompiler Tests
 *
 * Tests for the HoloScript â†’ USD Physics Schema compiler.
 * Verifies correct USDA generation for NVIDIA Isaac Sim and Omniverse.
 */

import { describe, it, expect, beforeEach } from 'vitest';
import {
  USDPhysicsCompiler,
  compileToUSDPhysics,
  compileForIsaacSim,
  type USDPhysicsCompilerOptions,
} from './USDPhysicsCompiler';
import type { HoloComposition, HoloObjectDecl, HoloSpatialGroup } from '../parser/HoloCompositionTypes';

describe('USDPhysicsCompiler', () => {
  let compiler: USDPhysicsCompiler;

  beforeEach(() => {
    compiler = new USDPhysicsCompiler();
  });

  // Helper to create a minimal composition
  function createComposition(overrides: Partial<HoloComposition> = {}): HoloComposition {
    return {
      type: 'Composition',
      name: 'TestComposition',
      objects: [],
      templates: [],
      spatialGroups: [],
      lights: [],
      imports: [],
      timelines: [],
      audio: [],
      zones: [],
      transitions: [],
      conditionals: [],
      iterators: [],
      npcs: [],
      quests: [],
      abilities: [],
      dialogues: [],
      stateMachines: [],
      achievements: [],
      talentTrees: [],
      shapes: [],
      ...overrides,
    };
  }

  // Helper to create an object declaration
  function createObject(overrides: Partial<HoloObjectDecl> = {}): HoloObjectDecl {
    return {
      name: 'TestObject',
      properties: [],
      traits: [],
      ...overrides,
    } as HoloObjectDecl;
  }

  // Helper to create a spatial group
  function createSpatialGroup(overrides: Partial<HoloSpatialGroup> = {}): HoloSpatialGroup {
    return {
      name: 'TestGroup',
      objects: [],
      ...overrides,
    } as HoloSpatialGroup;
  }

  describe('Basic Compilation', () => {
    it('should generate valid USDA structure', () => {
      const composition = createComposition();
      const usda = compiler.compile(composition);

      expect(usda).toContain('#usda 1.0');
      expect(usda).toContain('defaultPrim = "TestComposition"');
      expect(usda).toContain('def Xform "TestComposition"');
    });

    it('should include generator metadata', () => {
      const composition = createComposition({ name: 'MyScene' });
      const usda = compiler.compile(composition);

      expect(usda).toContain('doc = "Generated by HoloScript USDPhysicsCompiler for NVIDIA Isaac Sim"');
      expect(usda).toContain('generator = "HoloScript v3.0"');
      expect(usda).toContain('targetRuntime = "Isaac Sim / Omniverse"');
    });

    it('should use Z-up axis by default (Isaac Sim standard)', () => {
      const composition = createComposition();
      const usda = compiler.compile(composition);

      expect(usda).toContain('upAxis = "Z"');
    });

    it('should set default meters per unit to 1.0', () => {
      const composition = createComposition();
      const usda = compiler.compile(composition);

      expect(usda).toContain('metersPerUnit = 1');
    });
  });

  describe('Custom Options', () => {
    it('should use custom stage name', () => {
      const customCompiler = new USDPhysicsCompiler({ stageName: 'MyRobotStage' });
      const composition = createComposition();
      const usda = customCompiler.compile(composition);

      expect(usda).toContain('defaultPrim = "TestComposition"');
    });

    it('should use Y-up axis when specified', () => {
      const customCompiler = new USDPhysicsCompiler({ upAxis: 'Y' });
      const composition = createComposition();
      const usda = customCompiler.compile(composition);

      expect(usda).toContain('upAxis = "Y"');
    });

    it('should use custom gravity', () => {
      const customCompiler = new USDPhysicsCompiler({
        gravity: [0, 0, -1.62], // Moon gravity
      });
      const composition = createComposition();
      const usda = customCompiler.compile(composition);

      expect(usda).toContain('physics:gravityMagnitude = 1.62');
    });

    it('should use custom timestep', () => {
      const customCompiler = new USDPhysicsCompiler({
        physicsTimestep: 1 / 120, // 120 Hz
      });
      const composition = createComposition();
      const usda = customCompiler.compile(composition);

      expect(usda).toContain('timestep = 0.008333');
    });
  });

  describe('PhysicsScene', () => {
    it('should include PhysicsScene prim by default', () => {
      const composition = createComposition();
      const usda = compiler.compile(composition);

      expect(usda).toContain('def PhysicsScene "PhysicsScene"');
    });

    it('should include gravity settings', () => {
      const composition = createComposition();
      const usda = compiler.compile(composition);

      expect(usda).toContain('physics:gravityDirection');
      expect(usda).toContain('physics:gravityMagnitude');
    });

    it('should include Isaac Sim GPU dynamics settings', () => {
      const composition = createComposition();
      const usda = compiler.compile(composition);

      expect(usda).toContain('physxScene:enableGPUDynamics = true');
      expect(usda).toContain('physxScene:solverType = 1');
    });

    it('should exclude PhysicsScene when disabled', () => {
      const customCompiler = new USDPhysicsCompiler({ includePhysicsScene: false });
      const composition = createComposition();
      const usda = customCompiler.compile(composition);

      expect(usda).not.toContain('def PhysicsScene');
    });
  });

  describe('PhysicsMaterials', () => {
    it('should include default physics material', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Box',
            properties: [{ key: 'geometry', value: 'cube' }],
            traits: [{ name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('def Scope "PhysicsMaterials"');
      expect(usda).toContain('def Material "DefaultMaterial"');
      expect(usda).toContain('PhysicsMaterialAPI');
    });

    it('should include friction and restitution properties', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Box',
            traits: [{ name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('physics:staticFriction');
      expect(usda).toContain('physics:dynamicFriction');
      expect(usda).toContain('physics:restitution');
    });
  });

  describe('PhysicsRigidBodyAPI', () => {
    it('should add PhysicsRigidBodyAPI for @physics objects', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'RigidBox',
            properties: [{ key: 'geometry', value: 'cube' }],
            traits: [{ name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('prepend apiSchemas = ["PhysicsRigidBodyAPI"');
      expect(usda).toContain('physics:rigidBodyEnabled = true');
    });

    it('should add PhysicsRigidBodyAPI for @rigid objects', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'RigidSphere',
            properties: [{ key: 'geometry', value: 'sphere' }],
            traits: [{ name: 'rigid' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('PhysicsRigidBodyAPI');
    });

    it('should add kinematic flag for @kinematic objects', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'KinematicPlatform',
            traits: [{ name: 'physics' }, { name: 'kinematic' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('physics:kinematicEnabled = true');
    });
  });

  describe('PhysicsCollisionAPI', () => {
    it('should add PhysicsCollisionAPI for @collidable objects', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'CollisionBox',
            traits: [{ name: 'collidable' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('PhysicsCollisionAPI');
      expect(usda).toContain('physics:collisionEnabled = true');
    });

    it('should add PhysicsCollisionAPI for @trigger objects', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'TriggerZone',
            traits: [{ name: 'trigger' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('PhysicsCollisionAPI');
    });

    it('should add collision for physics objects automatically', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'PhysicsBox',
            traits: [{ name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('PhysicsCollisionAPI');
    });
  });

  describe('PhysicsMassAPI', () => {
    it('should add PhysicsMassAPI with default mass', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'MassBox',
            traits: [{ name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('PhysicsMassAPI');
      expect(usda).toContain('physics:mass = 1');
    });

    it('should use custom mass from trait config', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'HeavyBox',
            traits: [{ name: 'physics', mass: 50 }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('physics:mass = 50');
    });
  });

  describe('PhysicsArticulationRootAPI', () => {
    it('should add ArticulationRootAPI when @articulation_root trait is present', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'RobotBase',
            traits: [{ name: 'articulation_root' }, { name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('PhysicsArticulationRootAPI');
      expect(usda).toContain('physics:articulationEnabled = true');
    });

    it('should wrap robot parts in articulation hierarchy', () => {
      const composition = createComposition({
        spatialGroups: [
          createSpatialGroup({
            name: 'RobotArm',
            objects: [
              createObject({
                name: 'Shoulder',
                traits: [{ name: 'physics' }, { name: 'joint', type: 'hinge' }],
              }),
              createObject({
                name: 'Elbow',
                traits: [{ name: 'physics' }, { name: 'joint', type: 'hinge' }],
              }),
            ],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('def Xform "RobotArm"');
      expect(usda).toContain('PhysicsArticulationRootAPI');
    });

    it('should include Isaac Sim articulation settings', () => {
      const composition = createComposition({
        spatialGroups: [
          createSpatialGroup({
            name: 'Robot',
            objects: [
              createObject({
                name: 'Link1',
                traits: [{ name: 'physics' }, { name: 'joint', type: 'hinge' }],
              }),
            ],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('physxArticulation:enabledSelfCollisions');
      expect(usda).toContain('physxArticulation:solverPositionIterationCount');
      expect(usda).toContain('physxArticulation:solverVelocityIterationCount');
    });
  });

  describe('Joint Emission', () => {
    it('should emit revolute joint for hinge type', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Arm',
            traits: [{ name: 'physics' }, { name: 'joint', type: 'hinge', connectedBody: 'base' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('def PhysicsRevoluteJoint');
      expect(usda).toContain('rel physics:body0');
      expect(usda).toContain('rel physics:body1');
    });

    it('should emit prismatic joint for slider type', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Piston',
            traits: [{ name: 'physics' }, { name: 'joint', type: 'slider', connectedBody: 'base' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('def PhysicsPrismaticJoint');
    });

    it('should emit spherical joint for ball type', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'BallJoint',
            traits: [{ name: 'physics' }, { name: 'joint', type: 'ball', connectedBody: 'base' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('def PhysicsSphericalJoint');
    });

    it('should emit fixed joint for fixed type', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'FixedLink',
            traits: [{ name: 'physics' }, { name: 'joint', type: 'fixed', connectedBody: 'base' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('def PhysicsFixedJoint');
    });

    it('should include joint axis', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'RotatingArm',
            traits: [
              { name: 'physics' },
              { name: 'joint', type: 'hinge', axis: [0, 0, 1], connectedBody: 'base' },
            ],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('physics:axis = "Z"');
    });

    it('should include joint limits', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'LimitedJoint',
            traits: [
              { name: 'physics' },
              {
                name: 'joint',
                type: 'hinge',
                lowerLimit: -90,
                upperLimit: 90,
                connectedBody: 'base',
              },
            ],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('physics:lowerLimit');
      expect(usda).toContain('physics:upperLimit');
    });
  });

  describe('PhysicsDriveAPI', () => {
    it('should emit drive for motor configuration', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'MotorizedJoint',
            traits: [
              { name: 'physics' },
              {
                name: 'joint',
                type: 'hinge',
                connectedBody: 'base',
                motor: {
                  type: 'position',
                  maxForce: 100,
                  stiffness: 1000,
                  damping: 10,
                },
              },
            ],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('PhysicsDriveAPI');
      expect(usda).toContain(':type = "position"');
      expect(usda).toContain(':maxForce = 100');
      expect(usda).toContain(':stiffness = 1000');
      expect(usda).toContain(':damping = 10');
    });

    it('should support velocity drive type', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'VelocityMotor',
            traits: [
              { name: 'physics' },
              {
                name: 'joint',
                type: 'hinge',
                connectedBody: 'base',
                motor: { type: 'velocity' },
              },
            ],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain(':type = "velocity"');
    });
  });

  describe('Transform Emission', () => {
    it('should emit translation from position property', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'PositionedBox',
            properties: [{ key: 'position', value: [1, 2, 3] }],
            traits: [{ name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('xformOp:translate = (1, 2, 3)');
    });

    it('should emit orientation from rotation property', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'RotatedBox',
            properties: [{ key: 'rotation', value: [0, 90, 0] }],
            traits: [{ name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('xformOp:orient');
    });

    it('should emit scale from scale property', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'ScaledBox',
            properties: [{ key: 'scale', value: [2, 2, 2] }],
            traits: [{ name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('xformOp:scale = (2, 2, 2)');
    });

    it('should include xformOpOrder when transforms exist', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'TransformedBox',
            properties: [
              { key: 'position', value: [1, 0, 0] },
              { key: 'scale', value: [2, 2, 2] },
            ],
            traits: [{ name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('xformOpOrder');
    });
  });

  describe('Geometry Types', () => {
    it('should emit Cube for cube geometry', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Box',
            properties: [{ key: 'geometry', value: 'cube' }],
            traits: [{ name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('def Cube "Box"');
    });

    it('should emit Sphere for sphere geometry', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Ball',
            properties: [{ key: 'geometry', value: 'sphere' }],
            traits: [{ name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('def Sphere "Ball"');
    });

    it('should emit Cylinder for cylinder geometry', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Pipe',
            properties: [{ key: 'geometry', value: 'cylinder' }],
            traits: [{ name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('def Cylinder "Pipe"');
    });

    it('should emit Capsule for capsule geometry', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Pill',
            properties: [{ key: 'geometry', value: 'capsule' }],
            traits: [{ name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('def Capsule "Pill"');
    });
  });

  describe('Convenience Functions', () => {
    it('compileToUSDPhysics should work with default options', () => {
      const composition = createComposition({ name: 'TestScene' });
      const usda = compileToUSDPhysics(composition);

      expect(usda).toContain('#usda 1.0');
      expect(usda).toContain('PhysicsScene');
    });

    it('compileForIsaacSim should use Isaac Sim defaults', () => {
      const composition = createComposition({ name: 'IsaacScene' });
      const usda = compileForIsaacSim(composition);

      expect(usda).toContain('upAxis = "Z"');
      expect(usda).toContain('physxScene:enableGPUDynamics = true');
      expect(usda).toContain('metersPerUnit = 1');
    });

    it('compileForIsaacSim should allow option overrides', () => {
      const composition = createComposition({ name: 'CustomIsaac' });
      const usda = compileForIsaacSim(composition, {
        gravity: [0, 0, -1.62],
      });

      expect(usda).toContain('physics:gravityMagnitude = 1.62');
    });
  });

  describe('Spatial Groups', () => {
    it('should process spatial groups as Xform hierarchies', () => {
      const composition = createComposition({
        spatialGroups: [
          createSpatialGroup({
            name: 'RobotAssembly',
            objects: [
              createObject({ name: 'Link1', traits: [{ name: 'physics' }] }),
              createObject({ name: 'Link2', traits: [{ name: 'physics' }] }),
            ],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('def Xform "RobotAssembly"');
      expect(usda).toContain('Link1');
      expect(usda).toContain('Link2');
    });

    it('should add ArticulationRootAPI for groups with joints', () => {
      const composition = createComposition({
        spatialGroups: [
          createSpatialGroup({
            name: 'ArticulatedRobot',
            objects: [
              createObject({
                name: 'Arm',
                traits: [{ name: 'physics' }, { name: 'joint', type: 'hinge' }],
              }),
            ],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('PhysicsArticulationRootAPI');
    });
  });

  describe('Name Sanitization', () => {
    it('should sanitize names with special characters', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Object-With-Dashes',
            traits: [{ name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('Object_With_Dashes');
    });

    it('should handle names starting with numbers', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: '123Object',
            traits: [{ name: 'physics' }],
          }),
        ],
      });
      const usda = compiler.compile(composition);

      expect(usda).toContain('_123Object');
    });
  });
});
