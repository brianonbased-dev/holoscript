/**
 * HoloScript → Unreal Engine 5 C++ / Blueprint Compiler
 *
 * Translates a HoloComposition AST into Unreal Engine C++ code
 * with Blueprint-compatible UPROPERTY/UFUNCTION macros.
 *
 * Emits:
 *   - AActor-derived C++ classes
 *   - UStaticMeshComponent, UPointLightComponent, etc.
 *   - Physics with UPhysicsConstraintComponent
 *   - Audio with UAudioComponent
 *   - Niagara particle systems
 *   - Enhanced Input for VR interactions
 *
 * @version 1.0.0
 */

import type {
  HoloComposition,
  HoloObjectDecl,
  HoloLight,
  HoloEnvironment,
  HoloTimeline,
  HoloAudio,
  HoloTransition,
  HoloValue,
} from '../parser/HoloCompositionTypes';

export interface UnrealCompilerOptions {
  moduleName?: string;
  className?: string;
  indent?: string;
  engineVersion?: '5.0' | '5.1' | '5.2' | '5.3' | '5.4';
  useEnhancedInput?: boolean;
  generateBlueprints?: boolean;
}

export interface UnrealCompileResult {
  headerFile: string;
  sourceFile: string;
  blueprintJson?: string;
}

export class UnrealCompiler {
  private options: Required<UnrealCompilerOptions>;
  private headerLines: string[] = [];
  private sourceLines: string[] = [];
  private indentLevel: number = 0;
  private currentFile: 'header' | 'source' = 'header';

  constructor(options: UnrealCompilerOptions = {}) {
    this.options = {
      moduleName: options.moduleName || 'HoloWorld',
      className: options.className || 'AGeneratedScene',
      indent: options.indent || '\t',
      engineVersion: options.engineVersion || '5.4',
      useEnhancedInput: options.useEnhancedInput ?? true,
      generateBlueprints: options.generateBlueprints ?? false,
    };
  }

  compile(composition: HoloComposition): UnrealCompileResult {
    this.headerLines = [];
    this.sourceLines = [];
    this.indentLevel = 0;

    const headerFile = this.generateHeader(composition);
    const sourceFile = this.generateSource(composition);

    const result: UnrealCompileResult = {
      headerFile,
      sourceFile,
    };

    if (this.options.generateBlueprints) {
      result.blueprintJson = this.generateBlueprintJson(composition);
    }

    return result;
  }

  private generateHeader(composition: HoloComposition): string {
    this.headerLines = [];
    this.currentFile = 'header';
    this.indentLevel = 0;

    this.emitH('// Auto-generated by HoloScript UnrealCompiler');
    this.emitH(`// Source: composition "${composition.name}"`);
    this.emitH(`// Unreal Engine: ${this.options.engineVersion}`);
    this.emitH('// Do not edit manually — regenerate from .holo source');
    this.emitH('');
    this.emitH('#pragma once');
    this.emitH('');
    this.emitH('#include "CoreMinimal.h"');
    this.emitH('#include "GameFramework/Actor.h"');
    this.emitH('#include "Components/StaticMeshComponent.h"');
    this.emitH('#include "Components/PointLightComponent.h"');
    this.emitH('#include "Components/SpotLightComponent.h"');
    this.emitH('#include "Components/DirectionalLightComponent.h"');
    this.emitH('#include "Components/AudioComponent.h"');
    this.emitH('#include "Components/BoxComponent.h"');
    this.emitH('#include "Components/SphereComponent.h"');
    if (composition.objects?.some((o) => o.traits?.some((t) => t.name === 'physics'))) {
      this.emitH('#include "PhysicsEngine/PhysicsConstraintComponent.h"');
    }
    if (this.options.useEnhancedInput) {
      this.emitH('#include "EnhancedInputComponent.h"');
      this.emitH('#include "EnhancedInputSubsystems.h"');
    }
    this.emitH(`#include "${this.options.className.replace(/^A/, '')}.generated.h"`);
    this.emitH('');

    // Forward declarations
    this.emitH('// Forward declarations');
    this.emitH('class UNiagaraComponent;');
    this.emitH('class UWidgetComponent;');
    this.emitH('');

    // Class declaration
    this.emitH('UCLASS(Blueprintable, BlueprintType)');
    this.emitH(
      `class ${this.options.moduleName.toUpperCase()}_API ${this.options.className} : public AActor`
    );
    this.emitH('{');
    this.indentLevel++;
    this.emitH('GENERATED_BODY()');
    this.emitH('');
    this.emitH('public:');

    // Constructor
    this.emitH(`${this.options.className}();`);
    this.emitH('');

    // Components
    this.emitH('// === Scene Components ===');
    this.emitH('UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "HoloScript")');
    this.emitH('USceneComponent* RootSceneComponent;');
    this.emitH('');

    // Object components
    for (const obj of composition.objects || []) {
      const varName = this.sanitizeName(obj.name);
      const compType = this.getComponentType(obj);
      this.emitH(`UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Objects")`);
      this.emitH(`${compType}* ${varName};`);
    }
    this.emitH('');

    // Light components
    for (const light of composition.lights || []) {
      const varName = this.sanitizeName(light.name);
      const lightType = this.getLightComponentType(light.lightType);
      this.emitH(`UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Lighting")`);
      this.emitH(`${lightType}* ${varName};`);
    }
    this.emitH('');

    // Audio components
    for (const audio of composition.audio || []) {
      const varName = this.sanitizeName(audio.name);
      this.emitH(`UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Audio")`);
      this.emitH(`UAudioComponent* ${varName};`);
    }
    this.emitH('');

    // State properties
    if (composition.state) {
      this.emitH('// === State Properties ===');
      for (const prop of composition.state.properties) {
        const cppType = this.toCppType(prop.value);
        this.emitH(`UPROPERTY(EditAnywhere, BlueprintReadWrite, Replicated, Category = "State")`);
        this.emitH(`${cppType} ${prop.key};`);
      }
      this.emitH('');
    }

    // Lifecycle
    this.emitH('protected:');
    this.emitH('virtual void BeginPlay() override;');
    this.emitH('virtual void Tick(float DeltaTime) override;');
    this.emitH(
      'virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;'
    );
    this.emitH('');

    // Blueprint callable functions
    this.emitH('public:');
    this.emitH('// === Blueprint Callable Functions ===');

    // Actions from logic
    if (composition.logic?.actions) {
      for (const action of composition.logic.actions) {
        this.emitH(`UFUNCTION(BlueprintCallable, Category = "HoloScript")`);
        this.emitH(`void ${this.sanitizeName(action.name)}();`);
      }
    }
    this.emitH('');

    // Timeline functions
    for (const tl of composition.timelines || []) {
      const name = this.sanitizeName(tl.name);
      this.emitH(`UFUNCTION(BlueprintCallable, Category = "Timelines")`);
      this.emitH(`void Play${name}();`);
    }
    this.emitH('');

    // Transition functions
    for (const tr of composition.transitions || []) {
      const name = this.sanitizeName(tr.name);
      this.emitH(`UFUNCTION(BlueprintCallable, Category = "Transitions")`);
      this.emitH(`void ${name}Transition();`);
    }

    // Zone delegates
    if (composition.zones?.length) {
      this.emitH('');
      this.emitH('// === Zone Overlap Handlers ===');
      for (const zone of composition.zones) {
        const name = this.sanitizeName(zone.name);
        this.emitH(`UFUNCTION()`);
        this.emitH(
          `void On${name}BeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);`
        );
        this.emitH(`UFUNCTION()`);
        this.emitH(
          `void On${name}EndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);`
        );
      }
    }

    this.emitH('');
    this.emitH('private:');
    this.emitH('void SetupComponents();');
    this.emitH('void SetupEnvironment();');
    if (composition.zones?.length) {
      this.emitH('void SetupZones();');
    }

    this.indentLevel--;
    this.emitH('};');

    return this.headerLines.join('\n');
  }

  private generateSource(composition: HoloComposition): string {
    this.sourceLines = [];
    this.currentFile = 'source';
    this.indentLevel = 0;

    const headerName = this.options.className.replace(/^A/, '');

    this.emitS('// Auto-generated by HoloScript UnrealCompiler');
    this.emitS(`// Source: composition "${composition.name}"`);
    this.emitS('');
    this.emitS(`#include "${headerName}.h"`);
    this.emitS('#include "Net/UnrealNetwork.h"');
    this.emitS('#include "Engine/StaticMesh.h"');
    this.emitS('#include "Materials/MaterialInstanceDynamic.h"');
    if (composition.audio?.length) {
      this.emitS('#include "Sound/SoundBase.h"');
    }
    this.emitS('');

    // Constructor
    this.emitS(`${this.options.className}::${this.options.className}()`);
    this.emitS('{');
    this.indentLevel++;
    this.emitS('PrimaryActorTick.bCanEverTick = true;');
    this.emitS('bReplicates = true;');
    this.emitS('');
    this.emitS('// Root component');
    this.emitS(
      'RootSceneComponent = CreateDefaultSubobject<USceneComponent>(TEXT("RootSceneComponent"));'
    );
    this.emitS('RootComponent = RootSceneComponent;');
    this.emitS('');
    this.emitS('SetupComponents();');
    this.indentLevel--;
    this.emitS('}');
    this.emitS('');

    // SetupComponents
    this.emitS(`void ${this.options.className}::SetupComponents()`);
    this.emitS('{');
    this.indentLevel++;

    // Create object components
    for (const obj of composition.objects || []) {
      this.compileObjectSetup(obj);
    }

    // Create light components
    for (const light of composition.lights || []) {
      this.compileLightSetup(light);
    }

    // Create audio components
    for (const audio of composition.audio || []) {
      this.compileAudioSetup(audio);
    }

    this.indentLevel--;
    this.emitS('}');
    this.emitS('');

    // SetupEnvironment
    this.emitS(`void ${this.options.className}::SetupEnvironment()`);
    this.emitS('{');
    this.indentLevel++;
    if (composition.environment) {
      this.compileEnvironment(composition.environment);
    } else {
      this.emitS('// No environment configuration');
    }
    this.indentLevel--;
    this.emitS('}');
    this.emitS('');

    // SetupZones
    if (composition.zones?.length) {
      this.emitS(`void ${this.options.className}::SetupZones()`);
      this.emitS('{');
      this.indentLevel++;
      for (const zone of composition.zones) {
        this.compileZoneSetup(zone);
      }
      this.indentLevel--;
      this.emitS('}');
      this.emitS('');

      // Zone overlap handlers
      for (const zone of composition.zones) {
        this.compileZoneHandlers(zone);
      }
    }

    // BeginPlay
    this.emitS(`void ${this.options.className}::BeginPlay()`);
    this.emitS('{');
    this.indentLevel++;
    this.emitS('Super::BeginPlay();');
    this.emitS('');
    this.emitS('SetupEnvironment();');
    if (composition.zones?.length) {
      this.emitS('SetupZones();');
    }
    this.emitS('');
    this.emitS(`UE_LOG(LogTemp, Log, TEXT("HoloScript scene '${composition.name}' initialized"));`);

    // Auto-play timelines
    for (const tl of composition.timelines || []) {
      if (tl.autoplay) {
        this.emitS(`Play${this.sanitizeName(tl.name)}();`);
      }
    }

    this.indentLevel--;
    this.emitS('}');
    this.emitS('');

    // Tick
    this.emitS(`void ${this.options.className}::Tick(float DeltaTime)`);
    this.emitS('{');
    this.indentLevel++;
    this.emitS('Super::Tick(DeltaTime);');
    this.indentLevel--;
    this.emitS('}');
    this.emitS('');

    // Replication
    this.emitS(
      `void ${this.options.className}::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const`
    );
    this.emitS('{');
    this.indentLevel++;
    this.emitS('Super::GetLifetimeReplicatedProps(OutLifetimeProps);');
    if (composition.state) {
      this.emitS('');
      for (const prop of composition.state.properties) {
        this.emitS(`DOREPLIFETIME(${this.options.className}, ${prop.key});`);
      }
    }
    this.indentLevel--;
    this.emitS('}');
    this.emitS('');

    // Timeline functions
    for (const tl of composition.timelines || []) {
      this.compileTimelineFunction(tl);
    }

    // Transition functions
    for (const tr of composition.transitions || []) {
      this.compileTransitionFunction(tr);
    }

    // Action functions
    if (composition.logic?.actions) {
      for (const action of composition.logic.actions) {
        this.compileActionFunction(action);
      }
    }

    return this.sourceLines.join('\n');
  }

  private compileObjectSetup(obj: HoloObjectDecl): void {
    const varName = this.sanitizeName(obj.name);
    const meshType = this.findObjProp(obj, 'mesh') || this.findObjProp(obj, 'type') || 'cube';
    const isModel = !!this.findObjProp(obj, 'model') || !!this.findObjProp(obj, 'src');

    this.emitS(`// Object: ${obj.name}`);
    this.emitS(`${varName} = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("${obj.name}"));`);
    this.emitS(`${varName}->SetupAttachment(RootComponent);`);

    // Mesh assignment
    if (!isModel) {
      const meshPath = this.getMeshPath(meshType as string);
      if (meshPath) {
        this.emitS(
          `static ConstructorHelpers::FObjectFinder<UStaticMesh> ${varName}MeshAsset(TEXT("${meshPath}"));`
        );
        this.emitS(
          `if (${varName}MeshAsset.Succeeded()) { ${varName}->SetStaticMesh(${varName}MeshAsset.Object); }`
        );
      }
    }

    // Transform
    const pos = this.findObjProp(obj, 'position');
    if (pos && Array.isArray(pos)) {
      // Convert from HoloScript coordinate system to Unreal (multiply by 100 for cm)
      this.emitS(
        `${varName}->SetRelativeLocation(FVector(${(pos[0] as number) * 100}f, ${(pos[2] as number) * 100}f, ${(pos[1] as number) * 100}f));`
      );
    }

    const rot = this.findObjProp(obj, 'rotation');
    if (rot && Array.isArray(rot)) {
      this.emitS(`${varName}->SetRelativeRotation(FRotator(${rot[0]}f, ${rot[1]}f, ${rot[2]}f));`);
    }

    const scale = this.findObjProp(obj, 'scale');
    if (scale) {
      if (Array.isArray(scale)) {
        this.emitS(
          `${varName}->SetRelativeScale3D(FVector(${scale[0]}f, ${scale[1]}f, ${scale[2]}f));`
        );
      } else {
        this.emitS(`${varName}->SetRelativeScale3D(FVector(${scale}f));`);
      }
    }

    // Physics traits
    if (obj.traits) {
      for (const trait of obj.traits) {
        this.compileTraitSetup(varName, trait);
      }
    }

    this.emitS('');
  }

  private compileTraitSetup(
    varName: string,
    trait: { name: string; config?: Record<string, HoloValue> }
  ): void {
    switch (trait.name) {
      case 'physics':
        this.emitS(`${varName}->SetSimulatePhysics(true);`);
        if (trait.config?.mass) {
          this.emitS(`${varName}->SetMassOverrideInKg(NAME_None, ${trait.config.mass}f, true);`);
        }
        break;
      case 'collidable':
        this.emitS(`${varName}->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);`);
        this.emitS(`${varName}->SetCollisionResponseToAllChannels(ECR_Block);`);
        break;
      case 'grabbable':
        this.emitS(`// @grabbable — implement via GrabComponent or VR interaction framework`);
        break;
      case 'pointable':
      case 'hoverable':
        this.emitS(`// @${trait.name} — implement via line trace interaction`);
        break;
      case 'portal':
        this.emitS(`// @portal — destination: "${trait.config?.destination || 'unknown'}"`);
        break;
      case 'emissive':
      case 'glowing':
        this.emitS(`// @${trait.name} — apply emissive material`);
        break;
      case 'transparent':
        this.emitS(`// @transparent — set material blend mode`);
        break;
      default:
        this.emitS(`// @${trait.name} — custom trait implementation required`);
    }
  }

  private compileLightSetup(light: HoloLight): void {
    const varName = this.sanitizeName(light.name);
    const lightType = this.getLightComponentType(light.lightType);

    this.emitS(`// Light: ${light.name}`);
    this.emitS(`${varName} = CreateDefaultSubobject<${lightType}>(TEXT("${light.name}"));`);
    this.emitS(`${varName}->SetupAttachment(RootComponent);`);

    for (const prop of light.properties) {
      if (prop.key === 'color') {
        this.emitS(`${varName}->SetLightColor(${this.toLinearColor(prop.value)});`);
      } else if (prop.key === 'intensity') {
        const intensity = (prop.value as number) * 10000; // Convert to Unreal candela
        this.emitS(`${varName}->SetIntensity(${intensity}f);`);
      } else if (prop.key === 'position' && Array.isArray(prop.value)) {
        const pos = prop.value as number[];
        this.emitS(
          `${varName}->SetRelativeLocation(FVector(${pos[0] * 100}f, ${pos[2] * 100}f, ${pos[1] * 100}f));`
        );
      } else if (prop.key === 'cast_shadow' || prop.key === 'castShadow') {
        this.emitS(`${varName}->SetCastShadows(${prop.value ? 'true' : 'false'});`);
      }
    }
    this.emitS('');
  }

  private compileAudioSetup(audio: HoloAudio): void {
    const varName = this.sanitizeName(audio.name);
    this.emitS(`// Audio: ${audio.name}`);
    this.emitS(`${varName} = CreateDefaultSubobject<UAudioComponent>(TEXT("${audio.name}"));`);
    this.emitS(`${varName}->SetupAttachment(RootComponent);`);
    this.emitS(`${varName}->bAutoActivate = false;`);
    this.emitS('');
  }

  private compileEnvironment(env: HoloEnvironment): void {
    for (const prop of env.properties) {
      if (prop.key === 'skybox' || prop.key === 'preset') {
        this.emitS(
          `// Environment preset: "${prop.value}" — configure via BP_Sky_Sphere or SkyAtmosphere`
        );
      } else if (prop.key === 'fog' && typeof prop.value === 'object') {
        this.emitS('// Fog settings — configure via ExponentialHeightFog actor');
      } else if (prop.key === 'ambient_light') {
        this.emitS(`// Ambient light: ${prop.value} — configure via SkyLight`);
      }
    }
  }

  private compileZoneSetup(zone: any): void {
    const varName = this.sanitizeName(zone.name);
    this.emitS(`// Zone: ${zone.name} — bind overlap events`);
    this.emitS(
      `// ${varName}Trigger->OnComponentBeginOverlap.AddDynamic(this, &${this.options.className}::On${varName}BeginOverlap);`
    );
    this.emitS(
      `// ${varName}Trigger->OnComponentEndOverlap.AddDynamic(this, &${this.options.className}::On${varName}EndOverlap);`
    );
  }

  private compileZoneHandlers(zone: any): void {
    const varName = this.sanitizeName(zone.name);

    this.emitS(
      `void ${this.options.className}::On${varName}BeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)`
    );
    this.emitS('{');
    this.indentLevel++;
    this.emitS(`UE_LOG(LogTemp, Log, TEXT("Actor entered zone: ${zone.name}"));`);
    this.indentLevel--;
    this.emitS('}');
    this.emitS('');

    this.emitS(
      `void ${this.options.className}::On${varName}EndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)`
    );
    this.emitS('{');
    this.indentLevel++;
    this.emitS(`UE_LOG(LogTemp, Log, TEXT("Actor exited zone: ${zone.name}"));`);
    this.indentLevel--;
    this.emitS('}');
    this.emitS('');
  }

  private compileTimelineFunction(timeline: HoloTimeline): void {
    const name = this.sanitizeName(timeline.name);
    this.emitS(`void ${this.options.className}::Play${name}()`);
    this.emitS('{');
    this.indentLevel++;
    this.emitS(`UE_LOG(LogTemp, Log, TEXT("Playing timeline: ${timeline.name}"));`);
    this.emitS('// Timeline implementation via FTimeline or native Sequencer');
    for (const entry of timeline.entries) {
      this.emitS(`// At ${entry.time}s: ${entry.action.kind}`);
    }
    this.indentLevel--;
    this.emitS('}');
    this.emitS('');
  }

  private compileTransitionFunction(transition: HoloTransition): void {
    const name = this.sanitizeName(transition.name);
    this.emitS(`void ${this.options.className}::${name}Transition()`);
    this.emitS('{');
    this.indentLevel++;
    const dest = transition.properties.find((p) => p.key === 'destination' || p.key === 'to');
    if (dest) {
      this.emitS(`UE_LOG(LogTemp, Log, TEXT("Transitioning to: ${dest.value}"));`);
      this.emitS(`UGameplayStatics::OpenLevel(this, TEXT("${dest.value}"));`);
    }
    this.indentLevel--;
    this.emitS('}');
    this.emitS('');
  }

  private compileActionFunction(action: any): void {
    const name = this.sanitizeName(action.name);
    this.emitS(`void ${this.options.className}::${name}()`);
    this.emitS('{');
    this.indentLevel++;
    this.emitS(`UE_LOG(LogTemp, Log, TEXT("Action: ${action.name}"));`);
    this.emitS('// Action implementation');
    this.indentLevel--;
    this.emitS('}');
    this.emitS('');
  }

  private generateBlueprintJson(composition: HoloComposition): string {
    return JSON.stringify(
      {
        type: 'Blueprint',
        class: this.options.className,
        composition: composition.name,
        objects:
          composition.objects?.map((o) => ({
            name: o.name,
            traits: o.traits?.map((t) => t.name) || [],
          })) || [],
      },
      null,
      2
    );
  }

  // === Utility Methods ===

  private emitH(line: string): void {
    const indent = this.options.indent.repeat(this.indentLevel);
    this.headerLines.push(indent + line);
  }

  private emitS(line: string): void {
    const indent = this.options.indent.repeat(this.indentLevel);
    this.sourceLines.push(indent + line);
  }

  private sanitizeName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^[0-9]/, '_$&');
  }

  private getComponentType(obj: HoloObjectDecl): string {
    const meshType = this.findObjProp(obj, 'mesh') || this.findObjProp(obj, 'type');
    if (meshType === 'text') return 'UTextRenderComponent';
    return 'UStaticMeshComponent';
  }

  private getLightComponentType(lightType: string): string {
    const typeMap: Record<string, string> = {
      directional: 'UDirectionalLightComponent',
      point: 'UPointLightComponent',
      spot: 'USpotLightComponent',
      area: 'URectLightComponent',
    };
    return typeMap[lightType] || 'UPointLightComponent';
  }

  private getMeshPath(meshType: string): string | null {
    const meshPaths: Record<string, string> = {
      cube: '/Engine/BasicShapes/Cube.Cube',
      box: '/Engine/BasicShapes/Cube.Cube',
      sphere: '/Engine/BasicShapes/Sphere.Sphere',
      cylinder: '/Engine/BasicShapes/Cylinder.Cylinder',
      cone: '/Engine/BasicShapes/Cone.Cone',
      plane: '/Engine/BasicShapes/Plane.Plane',
    };
    return meshPaths[meshType] || null;
  }

  private findObjProp(obj: HoloObjectDecl, key: string): HoloValue | undefined {
    return obj.properties?.find((p) => p.key === key)?.value;
  }

  private toCppType(value: HoloValue): string {
    if (value === null) return 'UObject*';
    if (typeof value === 'boolean') return 'bool';
    if (typeof value === 'number') return Number.isInteger(value) ? 'int32' : 'float';
    if (typeof value === 'string') return 'FString';
    if (Array.isArray(value)) {
      if (value.length === 3 && value.every((v) => typeof v === 'number')) return 'FVector';
      if (value.length === 4 && value.every((v) => typeof v === 'number')) return 'FQuat';
      return 'TArray<float>';
    }
    return 'UObject*';
  }

  private toLinearColor(value: HoloValue): string {
    if (typeof value === 'string') {
      if (value.startsWith('#')) {
        const hex = value.slice(1);
        if (hex.length === 6) {
          const r = parseInt(hex.slice(0, 2), 16) / 255;
          const g = parseInt(hex.slice(2, 4), 16) / 255;
          const b = parseInt(hex.slice(4, 6), 16) / 255;
          return `FLinearColor(${r}f, ${g}f, ${b}f)`;
        }
      }
      const colors: Record<string, string> = {
        red: 'FLinearColor::Red',
        green: 'FLinearColor::Green',
        blue: 'FLinearColor::Blue',
        white: 'FLinearColor::White',
        black: 'FLinearColor::Black',
        yellow: 'FLinearColor::Yellow',
      };
      return colors[value.toLowerCase()] || 'FLinearColor::White';
    }
    if (Array.isArray(value) && value.length >= 3) {
      const [r, g, b, a = 1] = value as number[];
      return `FLinearColor(${r}f, ${g}f, ${b}f, ${a}f)`;
    }
    return 'FLinearColor::White';
  }
}

export function compileToUnreal(
  composition: HoloComposition,
  options?: UnrealCompilerOptions
): UnrealCompileResult {
  const compiler = new UnrealCompiler(options);
  return compiler.compile(composition);
}
