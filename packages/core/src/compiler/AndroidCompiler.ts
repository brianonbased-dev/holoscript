/**
 * HoloScript → Android Kotlin ARCore Compiler
 *
 * Translates a HoloComposition AST into Kotlin code targeting
 * ARCore for Android augmented reality experiences.
 *
 * Emits:
 *   - Kotlin Activity with ARCore Session
 *   - SceneForm / Filament rendering
 *   - Plane detection and hit testing
 *   - Touch gesture handling
 *   - Spatial audio integration
 *
 * @version 1.0.0
 */

import type {
  HoloComposition,
  HoloObjectDecl,
  HoloValue,
} from '../parser/HoloCompositionTypes';

export interface AndroidCompilerOptions {
  packageName?: string;
  className?: string;
  indent?: string;
  minSdk?: number;
  targetSdk?: number;
  useJetpackCompose?: boolean;
  useSceneform?: boolean; // Deprecated but simpler
  useFilament?: boolean; // Modern but complex
}

export interface AndroidCompileResult {
  activityFile: string;
  stateFile: string;
  nodeFactoryFile: string;
  manifestFile: string;
  buildGradle: string;
}

export class AndroidCompiler {
  private options: Required<AndroidCompilerOptions>;
  private lines: string[] = [];
  private indentLevel: number = 0;

  constructor(options: AndroidCompilerOptions = {}) {
    this.options = {
      packageName: options.packageName || 'com.holoscript.generated',
      className: options.className || 'GeneratedARScene',
      indent: options.indent || '    ',
      minSdk: options.minSdk || 26,
      targetSdk: options.targetSdk || 34,
      useJetpackCompose: options.useJetpackCompose ?? true,
      useSceneform: options.useSceneform ?? true,
      useFilament: options.useFilament ?? false,
    };
  }

  compile(composition: HoloComposition): AndroidCompileResult {
    return {
      activityFile: this.generateActivityFile(composition),
      stateFile: this.generateStateFile(composition),
      nodeFactoryFile: this.generateNodeFactoryFile(composition),
      manifestFile: this.generateManifestFile(composition),
      buildGradle: this.generateBuildGradle(composition),
    };
  }

  private generateActivityFile(composition: HoloComposition): string {
    this.lines = [];
    this.indentLevel = 0;

    const pkg = this.options.packageName;
    const cls = this.options.className;

    this.emit('// Auto-generated by HoloScript AndroidCompiler');
    this.emit(`// Source: composition "${composition.name}"`);
    this.emit('// Do not edit manually — regenerate from .holo source');
    this.emit('');
    this.emit(`package ${pkg}`);
    this.emit('');
    this.emit('import android.os.Bundle');
    this.emit('import android.view.MotionEvent');
    this.emit('import android.view.View');
    this.emit('import android.widget.Toast');
    this.emit('import androidx.appcompat.app.AppCompatActivity');
    this.emit('import androidx.lifecycle.ViewModelProvider');
    this.emit('import com.google.ar.core.*');
    this.emit('import com.google.ar.core.exceptions.*');
    this.emit('import com.google.ar.sceneform.*');
    this.emit('import com.google.ar.sceneform.math.Vector3');
    this.emit('import com.google.ar.sceneform.rendering.*');
    this.emit('import com.google.ar.sceneform.ux.*');
    this.emit('import java.util.concurrent.CompletableFuture');
    this.emit('');

    this.emit(`class ${cls}Activity : AppCompatActivity() {`);
    this.indentLevel++;

    // Properties
    this.emit('private lateinit var arFragment: ArFragment');
    this.emit('private lateinit var sceneState: SceneState');
    this.emit('private val placedNodes = mutableMapOf<String, TransformableNode>()');
    this.emit('');

    // onCreate
    this.emit('override fun onCreate(savedInstanceState: Bundle?) {');
    this.indentLevel++;
    this.emit('super.onCreate(savedInstanceState)');
    this.emit(`setContentView(R.layout.activity_ar_scene)`);
    this.emit('');
    this.emit('sceneState = ViewModelProvider(this)[SceneState::class.java]');
    this.emit(
      'arFragment = supportFragmentManager.findFragmentById(R.id.ar_fragment) as ArFragment'
    );
    this.emit('');
    this.emit('setupARSession()');
    this.emit('setupTapListener()');
    this.emit('setupUI()');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Setup AR Session
    this.emit('private fun setupARSession() {');
    this.indentLevel++;
    this.emit('arFragment.arSceneView.scene.addOnUpdateListener { frameTime ->');
    this.indentLevel++;
    this.emit('val frame = arFragment.arSceneView.arFrame ?: return@addOnUpdateListener');
    this.emit('');
    this.emit('// Track planes');
    this.emit('for (plane in frame.getUpdatedTrackables(Plane::class.java)) {');
    this.indentLevel++;
    this.emit('if (plane.trackingState == TrackingState.TRACKING) {');
    this.indentLevel++;
    this.emit('sceneState.onPlaneDetected(plane)');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Setup tap listener
    this.emit('private fun setupTapListener() {');
    this.indentLevel++;
    this.emit('arFragment.setOnTapArPlaneListener { hitResult, plane, motionEvent ->');
    this.indentLevel++;
    this.emit(
      'if (plane.type != Plane.Type.HORIZONTAL_UPWARD_FACING) return@setOnTapArPlaneListener'
    );
    this.emit('');
    this.emit('placeObject(hitResult)');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Place object
    this.emit('private fun placeObject(hitResult: HitResult) {');
    this.indentLevel++;
    this.emit('val anchor = hitResult.createAnchor()');
    this.emit('val anchorNode = AnchorNode(anchor)');
    this.emit('anchorNode.setParent(arFragment.arSceneView.scene)');
    this.emit('');
    this.emit('// Create node from factory');
    this.emit('NodeFactory.createDefaultNode(this) { renderable ->');
    this.indentLevel++;
    this.emit('val transformableNode = TransformableNode(arFragment.transformationSystem)');
    this.emit('transformableNode.setParent(anchorNode)');
    this.emit('transformableNode.renderable = renderable');
    this.emit('transformableNode.select()');
    this.emit('');
    this.emit('val id = java.util.UUID.randomUUID().toString()');
    this.emit('placedNodes[id] = transformableNode');
    this.emit('');
    this.emit('// Setup interaction');
    this.emit('transformableNode.setOnTapListener { _, _ ->');
    this.indentLevel++;
    this.emit('sceneState.onNodeTapped(id)');
    this.emit('animateNodeTap(transformableNode)');
    this.indentLevel--;
    this.emit('}');
    this.emit('');
    this.emit('android.util.Log.d("HoloScript", "Placed object: $id")');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Animate tap
    this.emit('private fun animateNodeTap(node: TransformableNode) {');
    this.indentLevel++;
    this.emit('val originalScale = node.localScale');
    this.emit(
      'val scaledUp = Vector3(originalScale.x * 1.2f, originalScale.y * 1.2f, originalScale.z * 1.2f)'
    );
    this.emit('');
    this.emit('android.animation.ObjectAnimator.ofObject(');
    this.indentLevel++;
    this.emit('node, "localScale",');
    this.emit('com.google.ar.sceneform.math.Vector3Evaluator(),');
    this.emit('originalScale, scaledUp, originalScale');
    this.indentLevel--;
    this.emit(').apply {');
    this.indentLevel++;
    this.emit('duration = 200');
    this.emit('start()');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Setup UI
    this.emit('private fun setupUI() {');
    this.indentLevel++;
    this.emit('findViewById<View>(R.id.reset_button)?.setOnClickListener {');
    this.indentLevel++;
    this.emit('resetScene()');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Reset scene
    this.emit('private fun resetScene() {');
    this.indentLevel++;
    this.emit('for (node in placedNodes.values) {');
    this.indentLevel++;
    this.emit('node.anchor?.detach()');
    this.emit('node.setParent(null)');
    this.indentLevel--;
    this.emit('}');
    this.emit('placedNodes.clear()');
    this.emit('');
    this.emit('sceneState.reset()');
    this.emit('Toast.makeText(this, "Scene reset", Toast.LENGTH_SHORT).show()');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Lifecycle
    this.emit('override fun onResume() {');
    this.indentLevel++;
    this.emit('super.onResume()');
    this.emit('checkARCoreAvailability()');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    this.emit('private fun checkARCoreAvailability() {');
    this.indentLevel++;
    this.emit('val availability = ArCoreApk.getInstance().checkAvailability(this)');
    this.emit('if (availability.isTransient) {');
    this.indentLevel++;
    this.emit('android.os.Handler(mainLooper).postDelayed({ checkARCoreAvailability() }, 200)');
    this.emit('return');
    this.indentLevel--;
    this.emit('}');
    this.emit('if (!availability.isSupported) {');
    this.indentLevel++;
    this.emit(
      'Toast.makeText(this, "ARCore is not supported on this device", Toast.LENGTH_LONG).show()'
    );
    this.emit('finish()');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');

    this.indentLevel--;
    this.emit('}');

    return this.lines.join('\n');
  }

  private generateStateFile(composition: HoloComposition): string {
    this.lines = [];
    this.indentLevel = 0;

    const pkg = this.options.packageName;

    this.emit('// Auto-generated by HoloScript AndroidCompiler');
    this.emit(`// State: ${composition.name}`);
    this.emit('');
    this.emit(`package ${pkg}`);
    this.emit('');
    this.emit('import androidx.lifecycle.ViewModel');
    this.emit('import androidx.lifecycle.MutableLiveData');
    this.emit('import androidx.lifecycle.LiveData');
    this.emit('import com.google.ar.core.Plane');
    this.emit('');

    this.emit('class SceneState : ViewModel() {');
    this.indentLevel++;

    // State properties from composition
    if (composition.state) {
      this.emit('// === State Properties ===');
      for (const prop of composition.state.properties) {
        const kotlinType = this.toKotlinType(prop.value);
        const kotlinValue = this.toKotlinValue(prop.value);
        this.emit(`private val _${prop.key} = MutableLiveData(${kotlinValue})`);
        this.emit(`val ${prop.key}: LiveData<${kotlinType}> get() = _${prop.key}`);
        this.emit('');
      }
    }

    // Detected planes
    this.emit('// === AR State ===');
    this.emit('private val _detectedPlanes = MutableLiveData<List<Plane>>(emptyList())');
    this.emit('val detectedPlanes: LiveData<List<Plane>> get() = _detectedPlanes');
    this.emit('');

    this.emit('private val _tappedNodes = MutableLiveData<String?>()');
    this.emit('val tappedNodes: LiveData<String?> get() = _tappedNodes');
    this.emit('');

    // Plane detection callback
    this.emit('fun onPlaneDetected(plane: Plane) {');
    this.indentLevel++;
    this.emit('val current = _detectedPlanes.value.orEmpty().toMutableList()');
    this.emit('if (!current.contains(plane)) {');
    this.indentLevel++;
    this.emit('current.add(plane)');
    this.emit('_detectedPlanes.value = current');
    this.emit('android.util.Log.d("HoloScript", "Plane detected: ${plane.type}")');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Node tapped callback
    this.emit('fun onNodeTapped(nodeId: String) {');
    this.indentLevel++;
    this.emit('_tappedNodes.value = nodeId');
    this.emit('android.util.Log.d("HoloScript", "Node tapped: $nodeId")');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Reset
    this.emit('fun reset() {');
    this.indentLevel++;
    this.emit('_detectedPlanes.value = emptyList()');
    this.emit('_tappedNodes.value = null');
    if (composition.state) {
      for (const prop of composition.state.properties) {
        const kotlinValue = this.toKotlinValue(prop.value);
        this.emit(`_${prop.key}.value = ${kotlinValue}`);
      }
    }
    this.emit('android.util.Log.d("HoloScript", "State reset")');
    this.indentLevel--;
    this.emit('}');

    // Actions
    if (composition.logic?.actions) {
      this.emit('');
      this.emit('// === Actions ===');
      for (const action of composition.logic.actions) {
        this.compileAction(action);
      }
    }

    this.indentLevel--;
    this.emit('}');

    return this.lines.join('\n');
  }

  private generateNodeFactoryFile(composition: HoloComposition): string {
    this.lines = [];
    this.indentLevel = 0;

    const pkg = this.options.packageName;

    this.emit('// Auto-generated by HoloScript AndroidCompiler');
    this.emit(`// Node Factory: ${composition.name}`);
    this.emit('');
    this.emit(`package ${pkg}`);
    this.emit('');
    this.emit('import android.content.Context');
    this.emit('import com.google.ar.sceneform.math.Vector3');
    this.emit('import com.google.ar.sceneform.rendering.*');
    this.emit('import com.google.android.filament.utils.Float3');
    this.emit('');

    this.emit('object NodeFactory {');
    this.indentLevel++;

    // Default node
    this.emit('fun createDefaultNode(context: Context, callback: (Renderable) -> Unit) {');
    this.indentLevel++;
    if (composition.objects?.length) {
      const firstObj = composition.objects[0];
      const color = this.findObjProp(firstObj, 'color');
      this.emit('MaterialFactory.makeOpaqueWithColor(');
      this.indentLevel++;
      this.emit('context,');
      this.emit(`Color(${this.toAndroidColor(color)})`);
      this.indentLevel--;
      this.emit(').thenAccept { material ->');
      this.indentLevel++;

      const meshType =
        this.findObjProp(firstObj, 'mesh') || this.findObjProp(firstObj, 'type') || 'cube';
      const geometry = this.getSceneformGeometry(meshType as string);
      this.emit(`${geometry}.thenAccept { renderable ->`);
      this.indentLevel++;
      this.emit('renderable.material = material');
      this.emit('callback(renderable)');
      this.indentLevel--;
      this.emit('}');
      this.indentLevel--;
      this.emit('}');
    } else {
      this.emit('MaterialFactory.makeOpaqueWithColor(context, Color(android.graphics.Color.BLUE))');
      this.emit('    .thenCompose { material ->');
      this.emit(
        '        ShapeFactory.makeCube(Vector3(0.1f, 0.1f, 0.1f), Vector3.zero(), material)'
      );
      this.emit('    }');
      this.emit('    .thenAccept { renderable -> callback(renderable) }');
    }
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Object factory methods
    for (const obj of composition.objects || []) {
      this.compileObjectFactory(obj);
    }

    this.indentLevel--;
    this.emit('}');

    return this.lines.join('\n');
  }

  private compileObjectFactory(obj: HoloObjectDecl): void {
    const methodName = `create${this.sanitizeName(obj.name)}`;

    this.emit(`fun ${methodName}(context: Context, callback: (Renderable) -> Unit) {`);
    this.indentLevel++;

    const color = this.findObjProp(obj, 'color');
    const meshType = this.findObjProp(obj, 'mesh') || this.findObjProp(obj, 'type') || 'cube';

    this.emit('MaterialFactory.makeOpaqueWithColor(');
    this.indentLevel++;
    this.emit('context,');
    this.emit(`Color(${this.toAndroidColor(color)})`);
    this.indentLevel--;
    this.emit(').thenAccept { material ->');
    this.indentLevel++;

    const geometry = this.getSceneformGeometry(meshType as string);
    this.emit(`${geometry}.thenAccept { renderable ->`);
    this.indentLevel++;
    this.emit('renderable.material = material');
    this.emit('callback(renderable)');
    this.indentLevel--;
    this.emit('}');

    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');
    this.emit('');
  }

  private generateManifestFile(composition: HoloComposition): string {
    const pkg = this.options.packageName;
    const cls = this.options.className;

    return `<?xml version="1.0" encoding="utf-8"?>
<!-- Auto-generated by HoloScript AndroidCompiler -->
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="${pkg}">

    <!-- AR Required -->
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-feature android:name="android.hardware.camera.ar" android:required="true" />
    
    <!-- ARCore Required -->
    <uses-feature android:glEsVersion="0x00030000" android:required="true" />

    <application
        android:allowBackup="true"
        android:label="${composition.name}"
        android:supportsRtl="true"
        android:theme="@style/Theme.AppCompat.NoActionBar">
        
        <!-- ARCore metadata -->
        <meta-data android:name="com.google.ar.core" android:value="required" />
        
        <activity
            android:name=".${cls}Activity"
            android:exported="true"
            android:configChanges="orientation|screenSize"
            android:screenOrientation="locked">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>`;
  }

  private generateBuildGradle(composition: HoloComposition): string {
    return `// Auto-generated by HoloScript AndroidCompiler
// Source: ${composition.name}

plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

android {
    namespace '${this.options.packageName}'
    compileSdk ${this.options.targetSdk}

    defaultConfig {
        applicationId "${this.options.packageName}"
        minSdk ${this.options.minSdk}
        targetSdk ${this.options.targetSdk}
        versionCode 1
        versionName "1.0"
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }
    
    kotlinOptions {
        jvmTarget = '17'
    }
    
    buildFeatures {
        viewBinding true
        compose ${this.options.useJetpackCompose}
    }
}

dependencies {
    implementation 'androidx.core:core-ktx:1.12.0'
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.11.0'
    implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0'
    implementation 'androidx.lifecycle:lifecycle-livedata-ktx:2.7.0'
    
    // ARCore
    implementation 'com.google.ar:core:1.41.0'
    
    // Sceneform (maintained fork)
    implementation 'com.gorisse.thomas:sceneform:1.22.0'
    
    // Optional: Jetpack Compose
    ${
      this.options.useJetpackCompose
        ? `implementation platform('androidx.compose:compose-bom:2024.01.00')
    implementation 'androidx.compose.ui:ui'
    implementation 'androidx.compose.material3:material3'
    implementation 'androidx.activity:activity-compose:1.8.2'`
        : '// Compose disabled'
    }
}`;
  }

  private compileAction(action: any): void {
    const rawName = this.sanitizeName(action.name);
    const name = rawName.charAt(0).toLowerCase() + rawName.slice(1);
    this.emit(`fun ${name}() {`);
    this.indentLevel++;
    this.emit(`android.util.Log.d("HoloScript", "Action: ${action.name}")`);
    this.emit('// Action implementation');
    this.indentLevel--;
    this.emit('}');
    this.emit('');
  }

  // === Utility Methods ===

  private emit(line: string): void {
    const indent = this.options.indent.repeat(this.indentLevel);
    this.lines.push(indent + line);
  }

  private sanitizeName(name: string): string {
    const result = name.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^[0-9]/, '_$&');
    return result.charAt(0).toUpperCase() + result.slice(1);
  }

  private getSceneformGeometry(meshType: string): string {
    const geometries: Record<string, string> = {
      cube: 'ShapeFactory.makeCube(Vector3(0.1f, 0.1f, 0.1f), Vector3.zero(), material)',
      box: 'ShapeFactory.makeCube(Vector3(0.1f, 0.1f, 0.1f), Vector3.zero(), material)',
      sphere: 'ShapeFactory.makeSphere(0.05f, Vector3.zero(), material)',
      cylinder: 'ShapeFactory.makeCylinder(0.05f, 0.1f, Vector3.zero(), material)',
    };
    return (
      geometries[meshType] ||
      'ShapeFactory.makeCube(Vector3(0.1f, 0.1f, 0.1f), Vector3.zero(), material)'
    );
  }

  private findObjProp(obj: HoloObjectDecl, key: string): HoloValue | undefined {
    return obj.properties?.find((p) => p.key === key)?.value;
  }

  private toKotlinType(value: HoloValue): string {
    if (value === null) return 'Any?';
    if (typeof value === 'boolean') return 'Boolean';
    if (typeof value === 'number') return Number.isInteger(value) ? 'Int' : 'Float';
    if (typeof value === 'string') return 'String';
    if (Array.isArray(value)) {
      if (value.length === 3 && value.every((v) => typeof v === 'number')) return 'Vector3';
      return 'List<Any>';
    }
    return 'Any';
  }

  private toKotlinValue(value: HoloValue): string {
    if (value === null) return 'null';
    if (typeof value === 'boolean') return value ? 'true' : 'false';
    if (typeof value === 'number') {
      return Number.isInteger(value) ? `${value}` : `${value}f`;
    }
    if (typeof value === 'string') return `"${value}"`;
    if (Array.isArray(value)) {
      if (value.length === 3 && value.every((v) => typeof v === 'number')) {
        return `Vector3(${value[0]}f, ${value[1]}f, ${value[2]}f)`;
      }
      return `listOf(${value.map((v) => this.toKotlinValue(v)).join(', ')})`;
    }
    return 'null';
  }

  private toAndroidColor(value: HoloValue | undefined): string {
    if (!value) return 'android.graphics.Color.BLUE';

    if (typeof value === 'string') {
      if (value.startsWith('#')) {
        return `android.graphics.Color.parseColor("${value}")`;
      }
      const colors: Record<string, string> = {
        red: 'android.graphics.Color.RED',
        green: 'android.graphics.Color.GREEN',
        blue: 'android.graphics.Color.BLUE',
        white: 'android.graphics.Color.WHITE',
        black: 'android.graphics.Color.BLACK',
        yellow: 'android.graphics.Color.YELLOW',
        cyan: 'android.graphics.Color.CYAN',
        magenta: 'android.graphics.Color.MAGENTA',
      };
      return colors[value.toLowerCase()] || 'android.graphics.Color.BLUE';
    }
    if (Array.isArray(value) && value.length >= 3) {
      const [r, g, b, a = 1] = value as number[];
      return `android.graphics.Color.argb(${Math.round(a * 255)}, ${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)})`;
    }
    return 'android.graphics.Color.BLUE';
  }
}

export function compileToAndroid(
  composition: HoloComposition,
  options?: AndroidCompilerOptions
): AndroidCompileResult {
  const compiler = new AndroidCompiler(options);
  return compiler.compile(composition);
}
