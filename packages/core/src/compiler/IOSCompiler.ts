/**
 * HoloScript → iOS Swift ARKit Compiler
 *
 * Translates a HoloComposition AST into Swift code targeting
 * ARKit for iPhone and iPad augmented reality experiences.
 *
 * Emits:
 *   - SwiftUI + ARKit integration
 *   - ARSCNView with SceneKit nodes
 *   - Plane detection and hit testing
 *   - World tracking configuration
 *   - Gesture recognizers for interaction
 *   - Spatial audio with SceneKit
 *
 * @version 1.0.0
 */

import type {
  HoloComposition,
  HoloObjectDecl,
  HoloLight,
  HoloAudio,
  HoloValue,
} from '../parser/HoloCompositionTypes';

export interface IOSCompilerOptions {
  className?: string;
  indent?: string;
  iosVersion?: '15.0' | '16.0' | '17.0' | '18.0';
  useSwiftUI?: boolean;
  useCombine?: boolean;
  useRealityKit?: boolean; // For newer iOS, RealityKit is preferred
}

export interface IOSCompileResult {
  viewFile: string;
  sceneFile: string;
  stateFile: string;
  infoPlist: string;
}

export class IOSCompiler {
  private options: Required<IOSCompilerOptions>;
  private lines: string[] = [];
  private indentLevel: number = 0;

  constructor(options: IOSCompilerOptions = {}) {
    this.options = {
      className: options.className || 'GeneratedARScene',
      indent: options.indent || '    ',
      iosVersion: options.iosVersion || '17.0',
      useSwiftUI: options.useSwiftUI ?? true,
      useCombine: options.useCombine ?? true,
      useRealityKit: options.useRealityKit ?? false,
    };
  }

  compile(composition: HoloComposition): IOSCompileResult {
    return {
      viewFile: this.generateViewFile(composition),
      sceneFile: this.generateSceneFile(composition),
      stateFile: this.generateStateFile(composition),
      infoPlist: this.generateInfoPlist(composition),
    };
  }

  private generateViewFile(composition: HoloComposition): string {
    this.lines = [];
    this.indentLevel = 0;

    this.emit('// Auto-generated by HoloScript IOSCompiler');
    this.emit(`// Source: composition "${composition.name}"`);
    this.emit(`// iOS: ${this.options.iosVersion}`);
    this.emit('// Do not edit manually — regenerate from .holo source');
    this.emit('');
    this.emit('import SwiftUI');
    this.emit('import ARKit');
    this.emit('import SceneKit');
    if (this.options.useCombine) {
      this.emit('import Combine');
    }
    this.emit('');

    // SwiftUI View
    this.emit(`struct ${this.options.className}View: View {`);
    this.indentLevel++;

    this.emit('@StateObject private var sceneState = SceneState()');
    this.emit('@State private var arView: ARSCNView?');
    this.emit('');

    this.emit('var body: some View {');
    this.indentLevel++;
    this.emit('ZStack {');
    this.indentLevel++;
    this.emit('ARViewContainer(sceneState: sceneState)');
    this.emit('    .edgesIgnoringSafeArea(.all)');
    this.emit('');

    // UI overlay
    this.emit('VStack {');
    this.indentLevel++;
    this.emit('Spacer()');
    this.emit('HStack {');
    this.indentLevel++;
    this.emit('Button("Reset") {');
    this.indentLevel++;
    this.emit('sceneState.resetScene()');
    this.indentLevel--;
    this.emit('}');
    this.emit('.padding()');
    this.emit('.background(Color.white.opacity(0.8))');
    this.emit('.cornerRadius(10)');
    this.indentLevel--;
    this.emit('}');
    this.emit('.padding()');
    this.indentLevel--;
    this.emit('}');

    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');

    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // ARView Container
    this.emit('struct ARViewContainer: UIViewRepresentable {');
    this.indentLevel++;
    this.emit('@ObservedObject var sceneState: SceneState');
    this.emit('');

    this.emit('func makeUIView(context: Context) -> ARSCNView {');
    this.indentLevel++;
    this.emit('let arView = ARSCNView(frame: .zero)');
    this.emit('arView.delegate = context.coordinator');
    this.emit('arView.autoenablesDefaultLighting = true');
    this.emit('arView.automaticallyUpdatesLighting = true');
    this.emit('');
    this.emit('// Configure AR session');
    this.emit('let configuration = ARWorldTrackingConfiguration()');
    this.emit('configuration.planeDetection = [.horizontal, .vertical]');
    this.emit('configuration.environmentTexturing = .automatic');
    if (parseFloat(this.options.iosVersion) >= 17.0) {
      this.emit('configuration.sceneReconstruction = .meshWithClassification');
    }
    this.emit('');
    this.emit('arView.session.run(configuration)');
    this.emit('');
    this.emit('// Add tap gesture');
    this.emit(
      'let tapGesture = UITapGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handleTap(_:)))'
    );
    this.emit('arView.addGestureRecognizer(tapGesture)');
    this.emit('');
    this.emit('// Add pan gesture for dragging');
    this.emit(
      'let panGesture = UIPanGestureRecognizer(target: context.coordinator, action: #selector(Coordinator.handlePan(_:)))'
    );
    this.emit('arView.addGestureRecognizer(panGesture)');
    this.emit('');
    this.emit('context.coordinator.arView = arView');
    this.emit('sceneState.arView = arView');
    this.emit('');
    this.emit('return arView');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    this.emit('func updateUIView(_ uiView: ARSCNView, context: Context) {');
    this.indentLevel++;
    this.emit('// Update view if needed');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    this.emit('func makeCoordinator() -> Coordinator {');
    this.indentLevel++;
    this.emit('Coordinator(sceneState: sceneState)');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Coordinator class
    this.emit('class Coordinator: NSObject, ARSCNViewDelegate {');
    this.indentLevel++;
    this.emit('var sceneState: SceneState');
    this.emit('weak var arView: ARSCNView?');
    this.emit('var selectedNode: SCNNode?');
    this.emit('');

    this.emit('init(sceneState: SceneState) {');
    this.indentLevel++;
    this.emit('self.sceneState = sceneState');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Tap handler
    this.emit('@objc func handleTap(_ gesture: UITapGestureRecognizer) {');
    this.indentLevel++;
    this.emit('guard let arView = arView else { return }');
    this.emit('let location = gesture.location(in: arView)');
    this.emit('');
    this.emit('// Check for hit on existing nodes');
    this.emit('let hitResults = arView.hitTest(location, options: [:])');
    this.emit('if let hit = hitResults.first {');
    this.indentLevel++;
    this.emit('sceneState.handleNodeTap(hit.node)');
    this.emit('return');
    this.indentLevel--;
    this.emit('}');
    this.emit('');
    this.emit('// Raycast to place new object');
    this.emit(
      'if let query = arView.raycastQuery(from: location, allowing: .estimatedPlane, alignment: .any) {'
    );
    this.indentLevel++;
    this.emit('let results = arView.session.raycast(query)');
    this.emit('if let result = results.first {');
    this.indentLevel++;
    this.emit('sceneState.placeObject(at: result.worldTransform)');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Pan handler
    this.emit('@objc func handlePan(_ gesture: UIPanGestureRecognizer) {');
    this.indentLevel++;
    this.emit('guard let arView = arView else { return }');
    this.emit('let location = gesture.location(in: arView)');
    this.emit('');
    this.emit('switch gesture.state {');
    this.emit('case .began:');
    this.indentLevel++;
    this.emit('let hitResults = arView.hitTest(location, options: [:])');
    this.emit('selectedNode = hitResults.first?.node');
    this.indentLevel--;
    this.emit('case .changed:');
    this.indentLevel++;
    this.emit('guard let node = selectedNode else { return }');
    this.emit(
      'if let query = arView.raycastQuery(from: location, allowing: .estimatedPlane, alignment: .any),'
    );
    this.emit('   let result = arView.session.raycast(query).first {');
    this.indentLevel++;
    this.emit('node.simdWorldPosition = simd_make_float3(result.worldTransform.columns.3)');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('case .ended, .cancelled:');
    this.indentLevel++;
    this.emit('selectedNode = nil');
    this.indentLevel--;
    this.emit('default:');
    this.indentLevel++;
    this.emit('break');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // ARSCNView delegate methods
    this.emit(
      'func renderer(_ renderer: SCNSceneRenderer, didAdd node: SCNNode, for anchor: ARAnchor) {'
    );
    this.indentLevel++;
    this.emit('if let planeAnchor = anchor as? ARPlaneAnchor {');
    this.indentLevel++;
    this.emit('sceneState.didDetectPlane(planeAnchor, node: node)');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    this.emit(
      'func renderer(_ renderer: SCNSceneRenderer, didUpdate node: SCNNode, for anchor: ARAnchor) {'
    );
    this.indentLevel++;
    this.emit('if let planeAnchor = anchor as? ARPlaneAnchor {');
    this.indentLevel++;
    this.emit('sceneState.didUpdatePlane(planeAnchor, node: node)');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');

    this.indentLevel--;
    this.emit('}');

    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Preview
    this.emit('#Preview {');
    this.indentLevel++;
    this.emit(`${this.options.className}View()`);
    this.indentLevel--;
    this.emit('}');

    return this.lines.join('\n');
  }

  private generateSceneFile(composition: HoloComposition): string {
    this.lines = [];
    this.indentLevel = 0;

    this.emit('// Auto-generated by HoloScript IOSCompiler');
    this.emit(`// Scene: ${composition.name}`);
    this.emit('');
    this.emit('import Foundation');
    this.emit('import SceneKit');
    this.emit('import ARKit');
    this.emit('');

    this.emit(`enum ${this.options.className}Objects {`);
    this.indentLevel++;

    // Generate node creation methods for each object
    for (const obj of composition.objects || []) {
      this.compileObjectFactory(obj);
    }

    this.emit('');
    this.emit('// Factory method to create all scene objects');
    this.emit('static func createSceneNodes() -> [String: SCNNode] {');
    this.indentLevel++;
    this.emit('var nodes: [String: SCNNode] = [:]');
    for (const obj of composition.objects || []) {
      const varName = this.sanitizeName(obj.name);
      this.emit(`nodes["${obj.name}"] = make${varName}()`);
    }
    this.emit('return nodes');
    this.indentLevel--;
    this.emit('}');

    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Light factories
    if (composition.lights?.length) {
      this.emit('enum SceneLights {');
      this.indentLevel++;
      for (const light of composition.lights) {
        this.compileLightFactory(light);
      }
      this.indentLevel--;
      this.emit('}');
      this.emit('');
    }

    // Audio factories
    if (composition.audio?.length) {
      this.emit('enum SceneAudio {');
      this.indentLevel++;
      for (const audio of composition.audio) {
        this.compileAudioFactory(audio);
      }
      this.indentLevel--;
      this.emit('}');
    }

    return this.lines.join('\n');
  }

  private generateStateFile(composition: HoloComposition): string {
    this.lines = [];
    this.indentLevel = 0;

    this.emit('// Auto-generated by HoloScript IOSCompiler');
    this.emit(`// State: ${composition.name}`);
    this.emit('');
    this.emit('import Foundation');
    this.emit('import SceneKit');
    this.emit('import ARKit');
    if (this.options.useCombine) {
      this.emit('import Combine');
    }
    this.emit('');

    this.emit('class SceneState: ObservableObject {');
    this.indentLevel++;

    // Published state properties
    if (composition.state) {
      this.emit('// === Published State ===');
      for (const prop of composition.state.properties) {
        const swiftType = this.toSwiftType(prop.value);
        const swiftValue = this.toSwiftValue(prop.value);
        this.emit(`@Published var ${prop.key}: ${swiftType} = ${swiftValue}`);
      }
      this.emit('');
    }

    // AR references
    this.emit('// === AR References ===');
    this.emit('weak var arView: ARSCNView?');
    this.emit('var placedNodes: [String: SCNNode] = [:]');
    this.emit('var detectedPlanes: [UUID: SCNNode] = [:]');
    this.emit('');

    // Init
    this.emit('init() {');
    this.indentLevel++;
    this.emit('print("[HoloScript] Scene state initialized")');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Place object method
    this.emit('func placeObject(at transform: simd_float4x4) {');
    this.indentLevel++;
    this.emit('guard let arView = arView else { return }');
    this.emit('');
    this.emit(`let nodes = ${this.options.className}Objects.createSceneNodes()`);
    this.emit('guard let node = nodes.values.first else { return }');
    this.emit('');
    this.emit('node.simdWorldTransform = transform');
    this.emit('arView.scene.rootNode.addChildNode(node)');
    this.emit('');
    this.emit('let id = UUID().uuidString');
    this.emit('placedNodes[id] = node');
    this.emit('print("[HoloScript] Placed object: \\(id)")');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Handle node tap
    this.emit('func handleNodeTap(_ node: SCNNode) {');
    this.indentLevel++;
    this.emit('print("[HoloScript] Tapped node: \\(node.name ?? "unnamed")")');
    this.emit('');
    this.emit('// Visual feedback');
    this.emit('let originalScale = node.scale');
    this.emit('SCNTransaction.begin()');
    this.emit('SCNTransaction.animationDuration = 0.1');
    this.emit(
      'node.scale = SCNVector3(originalScale.x * 1.2, originalScale.y * 1.2, originalScale.z * 1.2)'
    );
    this.emit('SCNTransaction.commit()');
    this.emit('');
    this.emit('DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {');
    this.indentLevel++;
    this.emit('SCNTransaction.begin()');
    this.emit('SCNTransaction.animationDuration = 0.1');
    this.emit('node.scale = originalScale');
    this.emit('SCNTransaction.commit()');
    this.indentLevel--;
    this.emit('}');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Plane detection
    this.emit('func didDetectPlane(_ anchor: ARPlaneAnchor, node: SCNNode) {');
    this.indentLevel++;
    this.emit(
      'let plane = SCNPlane(width: CGFloat(anchor.planeExtent.width), height: CGFloat(anchor.planeExtent.height))'
    );
    this.emit('plane.firstMaterial?.diffuse.contents = UIColor.white.withAlphaComponent(0.3)');
    this.emit('');
    this.emit('let planeNode = SCNNode(geometry: plane)');
    this.emit('planeNode.eulerAngles.x = -.pi / 2');
    this.emit('planeNode.position = SCNVector3(anchor.center.x, 0, anchor.center.z)');
    this.emit('');
    this.emit('node.addChildNode(planeNode)');
    this.emit('detectedPlanes[anchor.identifier] = planeNode');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    this.emit('func didUpdatePlane(_ anchor: ARPlaneAnchor, node: SCNNode) {');
    this.indentLevel++;
    this.emit('guard let planeNode = detectedPlanes[anchor.identifier],');
    this.emit('      let plane = planeNode.geometry as? SCNPlane else { return }');
    this.emit('');
    this.emit('plane.width = CGFloat(anchor.planeExtent.width)');
    this.emit('plane.height = CGFloat(anchor.planeExtent.height)');
    this.emit('planeNode.position = SCNVector3(anchor.center.x, 0, anchor.center.z)');
    this.indentLevel--;
    this.emit('}');
    this.emit('');

    // Reset scene
    this.emit('func resetScene() {');
    this.indentLevel++;
    this.emit('guard let arView = arView else { return }');
    this.emit('');
    this.emit('// Remove placed nodes');
    this.emit('for node in placedNodes.values {');
    this.indentLevel++;
    this.emit('node.removeFromParentNode()');
    this.indentLevel--;
    this.emit('}');
    this.emit('placedNodes.removeAll()');
    this.emit('');
    this.emit('// Reset AR session');
    this.emit('let configuration = ARWorldTrackingConfiguration()');
    this.emit('configuration.planeDetection = [.horizontal, .vertical]');
    this.emit(
      'arView.session.run(configuration, options: [.resetTracking, .removeExistingAnchors])'
    );
    this.emit('');
    this.emit('print("[HoloScript] Scene reset")');
    this.indentLevel--;
    this.emit('}');

    // Actions from composition state
    if (composition.logic?.actions) {
      this.emit('');
      this.emit('// === Actions ===');
      for (const action of composition.logic.actions) {
        this.compileAction(action);
      }
    }

    this.indentLevel--;
    this.emit('}');

    return this.lines.join('\n');
  }

  private generateInfoPlist(composition: HoloComposition): string {
    return `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>NSCameraUsageDescription</key>
    <string>This app uses the camera for augmented reality experiences.</string>
    <key>UIRequiredDeviceCapabilities</key>
    <array>
        <string>arkit</string>
        <string>arm64</string>
    </array>
    <key>UIApplicationSceneManifest</key>
    <dict>
        <key>UIApplicationSupportsMultipleScenes</key>
        <true/>
    </dict>
    <key>CFBundleDisplayName</key>
    <string>${composition.name}</string>
    <key>MinimumOSVersion</key>
    <string>${this.options.iosVersion}</string>
</dict>
</plist>`;
  }

  private compileObjectFactory(obj: HoloObjectDecl): void {
    const varName = this.sanitizeName(obj.name);
    const meshType = this.findObjProp(obj, 'mesh') || this.findObjProp(obj, 'type') || 'cube';

    this.emit(`static func make${varName}() -> SCNNode {`);
    this.indentLevel++;

    // Geometry
    const geometry = this.getSceneKitGeometry(meshType as string);
    this.emit(`let geometry = ${geometry}`);
    this.emit('');

    // Material
    const color = this.findObjProp(obj, 'color');
    const material = this.findObjProp(obj, 'material');
    this.emit('let material = SCNMaterial()');
    if (color) {
      this.emit(`material.diffuse.contents = ${this.toUIColor(color)}`);
    } else {
      this.emit('material.diffuse.contents = UIColor.systemBlue');
    }
    if (material && typeof material === 'object') {
      const mat = material as Record<string, any>;
      if (mat.metalness !== undefined) {
        this.emit(`material.metalness.contents = ${mat.metalness}`);
      }
      if (mat.roughness !== undefined) {
        this.emit(`material.roughness.contents = ${mat.roughness}`);
      }
    }
    this.emit('geometry.materials = [material]');
    this.emit('');

    // Create node
    this.emit('let node = SCNNode(geometry: geometry)');
    this.emit(`node.name = "${obj.name}"`);

    // Transform
    const pos = this.findObjProp(obj, 'position');
    if (pos && Array.isArray(pos)) {
      this.emit(`node.position = SCNVector3(${pos[0]}, ${pos[1]}, ${pos[2]})`);
    }

    const scale = this.findObjProp(obj, 'scale');
    if (scale) {
      if (Array.isArray(scale)) {
        this.emit(`node.scale = SCNVector3(${scale[0]}, ${scale[1]}, ${scale[2]})`);
      } else {
        this.emit(`node.scale = SCNVector3(${scale}, ${scale}, ${scale})`);
      }
    }

    const rot = this.findObjProp(obj, 'rotation');
    if (rot && Array.isArray(rot)) {
      this.emit(`node.eulerAngles = SCNVector3(${rot[0]}, ${rot[1]}, ${rot[2]})`);
    }

    // Physics
    if (obj.traits?.some((t) => t.name === 'physics')) {
      this.emit('');
      this.emit('let physicsBody = SCNPhysicsBody(type: .dynamic, shape: nil)');
      const physicsTrait = obj.traits.find((t) => t.name === 'physics');
      if (physicsTrait?.config?.mass) {
        this.emit(`physicsBody.mass = ${physicsTrait.config.mass}`);
      }
      this.emit('node.physicsBody = physicsBody');
    } else if (obj.traits?.some((t) => t.name === 'collidable')) {
      this.emit('');
      this.emit('let physicsBody = SCNPhysicsBody(type: .static, shape: nil)');
      this.emit('node.physicsBody = physicsBody');
    }

    this.emit('');
    this.emit('return node');
    this.indentLevel--;
    this.emit('}');
    this.emit('');
  }

  private compileLightFactory(light: HoloLight): void {
    const varName = this.sanitizeName(light.name);

    this.emit(`static func make${varName}() -> SCNNode {`);
    this.indentLevel++;

    const lightTypeMap: Record<string, string> = {
      directional: 'SCNLight.LightType.directional',
      point: 'SCNLight.LightType.omni',
      spot: 'SCNLight.LightType.spot',
      ambient: 'SCNLight.LightType.ambient',
    };

    this.emit('let light = SCNLight()');
    this.emit(`light.type = ${lightTypeMap[light.lightType] || 'SCNLight.LightType.omni'}`);

    for (const prop of light.properties) {
      if (prop.key === 'color') {
        this.emit(`light.color = ${this.toUIColor(prop.value)}`);
      } else if (prop.key === 'intensity') {
        this.emit(`light.intensity = ${(prop.value as number) * 1000}`);
      } else if (prop.key === 'cast_shadow' || prop.key === 'castShadow') {
        this.emit(`light.castsShadow = ${prop.value ? 'true' : 'false'}`);
      }
    }

    this.emit('');
    this.emit('let node = SCNNode()');
    this.emit(`node.name = "${light.name}"`);
    this.emit('node.light = light');

    const posProp = light.properties.find((p) => p.key === 'position');
    if (posProp && Array.isArray(posProp.value)) {
      const pos = posProp.value as number[];
      this.emit(`node.position = SCNVector3(${pos[0]}, ${pos[1]}, ${pos[2]})`);
    }

    this.emit('');
    this.emit('return node');
    this.indentLevel--;
    this.emit('}');
    this.emit('');
  }

  private compileAudioFactory(audio: HoloAudio): void {
    const varName = this.sanitizeName(audio.name);

    this.emit(`static func make${varName}() -> SCNAudioSource? {`);
    this.indentLevel++;

    const srcProp = audio.properties.find((p) => p.key === 'src' || p.key === 'source');
    if (srcProp) {
      this.emit(
        `guard let audioSource = SCNAudioSource(named: "${srcProp.value}") else { return nil }`
      );
    } else {
      this.emit('return nil');
      this.indentLevel--;
      this.emit('}');
      return;
    }

    const loopProp = audio.properties.find((p) => p.key === 'loop');
    if (loopProp) {
      this.emit(`audioSource.loops = ${loopProp.value ? 'true' : 'false'}`);
    }

    const volumeProp = audio.properties.find((p) => p.key === 'volume');
    if (volumeProp) {
      this.emit(`audioSource.volume = ${volumeProp.value}`);
    }

    this.emit('audioSource.isPositional = true');
    this.emit('audioSource.load()');
    this.emit('return audioSource');
    this.indentLevel--;
    this.emit('}');
    this.emit('');
  }

  private compileAction(action: any): void {
    const name = this.sanitizeName(action.name);
    this.emit(`func ${name}() {`);
    this.indentLevel++;
    this.emit(`print("[HoloScript] Action: ${action.name}")`);
    this.emit('// Action implementation');
    this.indentLevel--;
    this.emit('}');
    this.emit('');
  }

  // === Utility Methods ===

  private emit(line: string): void {
    const indent = this.options.indent.repeat(this.indentLevel);
    this.lines.push(indent + line);
  }

  private sanitizeName(name: string): string {
    const result = name.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^[0-9]/, '_$&');
    return result.charAt(0).toUpperCase() + result.slice(1);
  }

  private getSceneKitGeometry(meshType: string): string {
    const geometries: Record<string, string> = {
      cube: 'SCNBox(width: 0.1, height: 0.1, length: 0.1, chamferRadius: 0)',
      box: 'SCNBox(width: 0.1, height: 0.1, length: 0.1, chamferRadius: 0)',
      sphere: 'SCNSphere(radius: 0.05)',
      cylinder: 'SCNCylinder(radius: 0.05, height: 0.1)',
      cone: 'SCNCone(topRadius: 0, bottomRadius: 0.05, height: 0.1)',
      capsule: 'SCNCapsule(capRadius: 0.025, height: 0.1)',
      plane: 'SCNPlane(width: 0.2, height: 0.2)',
      torus: 'SCNTorus(ringRadius: 0.05, pipeRadius: 0.02)',
    };
    return geometries[meshType] || 'SCNBox(width: 0.1, height: 0.1, length: 0.1, chamferRadius: 0)';
  }

  private findObjProp(obj: HoloObjectDecl, key: string): HoloValue | undefined {
    return obj.properties?.find((p) => p.key === key)?.value;
  }

  private toSwiftType(value: HoloValue): string {
    if (value === null) return 'Any?';
    if (typeof value === 'boolean') return 'Bool';
    if (typeof value === 'number') return Number.isInteger(value) ? 'Int' : 'Double';
    if (typeof value === 'string') return 'String';
    if (Array.isArray(value)) {
      if (value.length === 3 && value.every((v) => typeof v === 'number')) return 'SCNVector3';
      return '[Any]';
    }
    return 'Any';
  }

  private toSwiftValue(value: HoloValue): string {
    if (value === null) return 'nil';
    if (typeof value === 'boolean') return value ? 'true' : 'false';
    if (typeof value === 'number') return `${value}`;
    if (typeof value === 'string') return `"${value}"`;
    if (Array.isArray(value)) {
      if (value.length === 3 && value.every((v) => typeof v === 'number')) {
        return `SCNVector3(${value[0]}, ${value[1]}, ${value[2]})`;
      }
      return `[${value.map((v) => this.toSwiftValue(v)).join(', ')}]`;
    }
    return 'nil';
  }

  private toUIColor(value: HoloValue): string {
    if (typeof value === 'string') {
      if (value.startsWith('#')) {
        const hex = value.slice(1);
        if (hex.length === 6) {
          const r = parseInt(hex.slice(0, 2), 16) / 255;
          const g = parseInt(hex.slice(2, 4), 16) / 255;
          const b = parseInt(hex.slice(4, 6), 16) / 255;
          return `UIColor(red: ${r}, green: ${g}, blue: ${b}, alpha: 1.0)`;
        }
      }
      const colors: Record<string, string> = {
        red: 'UIColor.systemRed',
        green: 'UIColor.systemGreen',
        blue: 'UIColor.systemBlue',
        white: 'UIColor.white',
        black: 'UIColor.black',
        yellow: 'UIColor.systemYellow',
        cyan: 'UIColor.systemCyan',
        magenta: 'UIColor.systemPink',
      };
      return colors[value.toLowerCase()] || 'UIColor.systemBlue';
    }
    if (Array.isArray(value) && value.length >= 3) {
      const [r, g, b, a = 1] = value as number[];
      return `UIColor(red: ${r}, green: ${g}, blue: ${b}, alpha: ${a})`;
    }
    return 'UIColor.systemBlue';
  }
}

export function compileToIOS(
  composition: HoloComposition,
  options?: IOSCompilerOptions
): IOSCompileResult {
  const compiler = new IOSCompiler(options);
  return compiler.compile(composition);
}
