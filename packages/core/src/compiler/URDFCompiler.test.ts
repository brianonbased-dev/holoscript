/**
 * URDFCompiler Tests
 *
 * Tests for the HoloScript → URDF (Unified Robot Description Format) compiler.
 * Verifies correct XML generation for ROS 2 / Gazebo robotics integration.
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { URDFCompiler, type URDFCompilerOptions } from './URDFCompiler';
import type { HoloComposition, HoloObjectDecl } from '../parser/HoloCompositionTypes';

describe('URDFCompiler', () => {
  let compiler: URDFCompiler;

  beforeEach(() => {
    compiler = new URDFCompiler();
  });

  // Helper to create a minimal composition
  function createComposition(overrides: Partial<HoloComposition> = {}): HoloComposition {
    return {
      type: 'Composition',
      name: 'TestComposition',
      objects: [],
      templates: [],
      spatialGroups: [],
      lights: [],
      imports: [],
      timelines: [],
      audio: [],
      zones: [],
      transitions: [],
      conditionals: [],
      iterators: [],
      npcs: [],
      quests: [],
      abilities: [],
      dialogues: [],
      stateMachines: [],
      achievements: [],
      talentTrees: [],
      shapes: [],
      ...overrides,
    };
  }

  // Helper to create an object declaration
  function createObject(overrides: Partial<HoloObjectDecl> = {}): HoloObjectDecl {
    return {
      name: 'TestObject',
      properties: [],
      traits: [],
      ...overrides,
    } as HoloObjectDecl;
  }

  describe('Basic Compilation', () => {
    it('should generate valid URDF XML structure', () => {
      const composition = createComposition();
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<?xml version="1.0"?>');
      expect(urdf).toContain('<robot name="HoloScriptRobot">');
      expect(urdf).toContain('</robot>');
    });

    it('should include XML declaration and comments', () => {
      const composition = createComposition({ name: 'MyRobot' });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<!-- Auto-generated by HoloScript URDFCompiler -->');
      expect(urdf).toContain('<!-- Source: composition "MyRobot" -->');
    });

    it('should always include base_link', () => {
      const composition = createComposition();
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<link name="base_link">');
    });

    it('should include default material', () => {
      const composition = createComposition();
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<material name="default">');
      expect(urdf).toContain('<color rgba="0.8 0.8 0.8 1.0"/>');
    });
  });

  describe('Custom Options', () => {
    it('should use custom robot name', () => {
      const customCompiler = new URDFCompiler({ robotName: 'MyCustomRobot' });
      const composition = createComposition();
      const urdf = customCompiler.compile(composition);

      expect(urdf).toContain('<robot name="MyCustomRobot">');
    });

    it('should exclude visual when includeVisual is false', () => {
      const customCompiler = new URDFCompiler({ includeVisual: false });
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Cube',
            properties: [{ key: 'geometry', value: 'cube' }],
          }),
        ],
      });
      const urdf = customCompiler.compile(composition);

      // Should have the link but not a visual element inside it (except base_link)
      expect(urdf).toContain('<link name="cube">');
      // Count visual occurrences - only base_link might have visual if any
      const visualCount = (urdf.match(/<visual>/g) || []).length;
      expect(visualCount).toBe(0);
    });

    it('should exclude collision when includeCollision is false', () => {
      const customCompiler = new URDFCompiler({ includeCollision: false });
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Cube',
            properties: [{ key: 'geometry', value: 'cube' }],
            traits: ['physics', 'collidable'],
          }),
        ],
      });
      const urdf = customCompiler.compile(composition);

      expect(urdf).not.toContain('<collision>');
    });

    it('should use custom mesh path prefix', () => {
      const customCompiler = new URDFCompiler({
        meshPathPrefix: 'file:///custom/path/',
        includeVisual: true,
      });
      const composition = createComposition({
        objects: [
          createObject({
            name: 'CustomMesh',
            properties: [{ key: 'geometry', value: 'robot.stl' }],
          }),
        ],
      });
      const urdf = customCompiler.compile(composition);

      expect(urdf).toContain('file:///custom/path/robot.stl');
    });

    it('should use custom default mass', () => {
      const customCompiler = new URDFCompiler({
        defaultMass: 5.0,
        includeInertial: true,
      });
      const composition = createComposition({
        objects: [
          createObject({
            name: 'HeavyBox',
            properties: [{ key: 'geometry', value: 'cube' }],
          }),
        ],
      });
      const urdf = customCompiler.compile(composition);

      expect(urdf).toContain('<mass value="5"/>');
    });
  });

  describe('Object Processing', () => {
    it('should create link for each object', () => {
      const composition = createComposition({
        objects: [
          createObject({ name: 'Object1' }),
          createObject({ name: 'Object2' }),
          createObject({ name: 'Object3' }),
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<link name="object1">');
      expect(urdf).toContain('<link name="object2">');
      expect(urdf).toContain('<link name="object3">');
    });

    it('should create joints connecting objects to base_link', () => {
      const composition = createComposition({
        objects: [createObject({ name: 'MyObject' })],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<joint name="base_link_to_myobject_joint" type="fixed">');
      expect(urdf).toContain('<parent link="base_link"/>');
      expect(urdf).toContain('<child link="myobject"/>');
    });

    it('should sanitize object names for URDF', () => {
      const composition = createComposition({
        objects: [createObject({ name: 'My Object #1!' })],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<link name="my_object__1_">');
    });
  });

  describe('Geometry Handling', () => {
    it('should generate box geometry for cube', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Cube',
            properties: [
              { key: 'geometry', value: 'cube' },
              { key: 'scale', value: 2 },
            ],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<box size="2 2 2"/>');
    });

    it('should generate sphere geometry', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Sphere',
            properties: [
              { key: 'geometry', value: 'sphere' },
              { key: 'scale', value: 1 },
            ],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<sphere radius="0.5"/>');
    });

    it('should generate cylinder geometry', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Cylinder',
            properties: [
              { key: 'geometry', value: 'cylinder' },
              { key: 'scale', value: 1 },
            ],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<cylinder radius="0.5" length="1"/>');
    });

    it('should handle mesh files', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Robot',
            properties: [{ key: 'geometry', value: 'robot_arm.stl' }],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<mesh filename="package://meshes/robot_arm.stl"/>');
    });

    it('should convert .glb to .stl for mesh references', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Model',
            properties: [{ key: 'geometry', value: 'model.glb' }],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('model.stl');
    });
  });

  describe('Position and Rotation', () => {
    it('should extract position from properties', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'PositionedObject',
            properties: [
              { key: 'geometry', value: 'cube' },
              { key: 'position', value: [1, 2, 3] },
            ],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<origin xyz="1 2 3"');
    });

    it('should convert rotation from degrees to radians', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'RotatedObject',
            properties: [
              { key: 'geometry', value: 'cube' },
              { key: 'rotation', value: [90, 0, 0] },
            ],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      // 90 degrees = π/2 radians ≈ 1.570796
      expect(urdf).toMatch(/rpy="1\.5707\d*/);
    });

    it('should default position to [0,0,0]', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'DefaultPosition',
            properties: [{ key: 'geometry', value: 'cube' }],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<origin xyz="0 0 0"');
    });
  });

  describe('Physics and Inertial', () => {
    it('should include inertial properties by default', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'PhysicsObject',
            properties: [{ key: 'geometry', value: 'cube' }],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<inertial>');
      expect(urdf).toContain('<mass value=');
      expect(urdf).toContain('<inertia');
    });

    it('should extract mass from physics property', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'HeavyObject',
            properties: [
              { key: 'geometry', value: 'cube' },
              { key: 'physics', value: { mass: 10 } },
            ],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<mass value="10"/>');
    });

    it('should calculate inertia for box geometry', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'InertiaBox',
            properties: [
              { key: 'geometry', value: 'box' },
              { key: 'scale', value: 1 },
              { key: 'physics', value: { mass: 1 } },
            ],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      // For a 1m cube with mass 1: I = m*(w²+h²)/12 = 1*(1+1)/12 ≈ 0.166667
      expect(urdf).toMatch(/ixx="0\.166\d*/);
    });

    it('should calculate inertia for sphere geometry', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'InertiaSphere',
            properties: [
              { key: 'geometry', value: 'sphere' },
              { key: 'scale', value: 1 },
              { key: 'physics', value: { mass: 1 } },
            ],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      // For a sphere with radius 0.5 and mass 1: I = (2/5)*m*r² = 0.4*1*0.25 = 0.1
      expect(urdf).toMatch(/ixx="0\.1\d*/);
    });
  });

  describe('Collision Handling', () => {
    it('should add collision for objects with collidable trait', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Collidable',
            properties: [{ key: 'geometry', value: 'cube' }],
            traits: ['collidable'],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<collision>');
    });

    it('should add collision for objects with physics trait', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'PhysicsBody',
            properties: [{ key: 'geometry', value: 'cube' }],
            traits: ['physics'],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<collision>');
    });

    it('should add collision for objects with rigid trait', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'RigidBody',
            properties: [{ key: 'geometry', value: 'cube' }],
            traits: ['rigid'],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<collision>');
    });

    it('should not add collision for non-collidable objects', () => {
      const customCompiler = new URDFCompiler({ includeCollision: true });
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Visual',
            properties: [{ key: 'geometry', value: 'cube' }],
            traits: [], // No physics traits
          }),
        ],
      });
      const urdf = customCompiler.compile(composition);

      // Should have only base_link inertial, no collision in visual objects
      const collisionMatches = urdf.match(/<collision>/g) || [];
      expect(collisionMatches.length).toBe(0);
    });
  });

  describe('Spatial Groups', () => {
    it('should process spatial groups as parent links', () => {
      const composition = createComposition({
        spatialGroups: [
          {
            name: 'ArmGroup',
            objects: [createObject({ name: 'Shoulder' }), createObject({ name: 'Elbow' })],
          },
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<link name="armgroup">');
      expect(urdf).toContain('<link name="shoulder">');
      expect(urdf).toContain('<link name="elbow">');
    });

    it('should create joints for spatial group hierarchy', () => {
      const composition = createComposition({
        spatialGroups: [
          {
            name: 'LegGroup',
            objects: [createObject({ name: 'Foot' })],
          },
        ],
      });
      const urdf = compiler.compile(composition);

      // Group connects to base_link
      expect(urdf).toContain('<joint name="base_link_to_leggroup_joint"');
      // Object connects to group
      expect(urdf).toContain('<joint name="leggroup_to_foot_joint"');
    });
  });

  describe('HoloScript Extensions', () => {
    it('should include HoloScript extensions as comments by default', () => {
      const composition = createComposition({
        name: 'MyScene',
        environment: { skybox: 'sunset' },
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<!-- HoloScript Extensions -->');
      expect(urdf).toContain('<!-- Original composition: "MyScene" -->');
      expect(urdf).toContain('<!-- Environment skybox: sunset -->');
    });

    it('should include template names in extensions', () => {
      const composition = createComposition({
        templates: [
          { name: 'Template1', properties: [], traits: [] } as any,
          { name: 'Template2', properties: [], traits: [] } as any,
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<!-- Templates: Template1, Template2 -->');
    });

    it('should exclude extensions when option is false', () => {
      const customCompiler = new URDFCompiler({ includeHoloExtensions: false });
      const composition = createComposition({
        environment: { skybox: 'sunset' },
      });
      const urdf = customCompiler.compile(composition);

      expect(urdf).not.toContain('<!-- HoloScript Extensions -->');
    });
  });

  describe('XML Escaping', () => {
    it('should escape special characters in robot name', () => {
      const customCompiler = new URDFCompiler({ robotName: 'Robot<>&"Test' });
      const composition = createComposition();
      const urdf = customCompiler.compile(composition);

      expect(urdf).toContain('&lt;');
      expect(urdf).toContain('&gt;');
      expect(urdf).toContain('&amp;');
      expect(urdf).toContain('&quot;');
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty composition', () => {
      const composition = createComposition();
      const urdf = compiler.compile(composition);

      expect(urdf).toBeDefined();
      expect(urdf).toContain('<robot');
      expect(urdf).toContain('</robot>');
    });

    it('should handle object without geometry', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'NoGeometry',
            properties: [],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      expect(urdf).toContain('<link name="nogeometry">');
      // Should not have visual/collision without geometry
    });

    it('should handle array scale values', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'ArrayScale',
            properties: [
              { key: 'geometry', value: 'cube' },
              { key: 'scale', value: [2, 3, 4] },
            ],
          }),
        ],
      });
      const urdf = compiler.compile(composition);

      // Should use first value of array
      expect(urdf).toContain('<box size="2 2 2"/>');
    });

    it('should handle missing optional properties gracefully', () => {
      const composition = createComposition({
        objects: [
          createObject({
            name: 'Minimal',
            properties: [],
            traits: undefined as any,
          }),
        ],
      });

      expect(() => compiler.compile(composition)).not.toThrow();
    });
  });

  describe('Integration', () => {
    it('should compile a complex robot composition', () => {
      const composition = createComposition({
        name: 'RobotArm',
        objects: [
          createObject({
            name: 'Base',
            properties: [
              { key: 'geometry', value: 'cylinder' },
              { key: 'position', value: [0, 0, 0] },
              { key: 'scale', value: 0.5 },
              { key: 'physics', value: { mass: 5 } },
            ],
            traits: ['physics', 'collidable'],
          }),
          createObject({
            name: 'Arm1',
            properties: [
              { key: 'geometry', value: 'box' },
              { key: 'position', value: [0, 0, 0.5] },
              { key: 'scale', value: 0.3 },
              { key: 'physics', value: { mass: 2 } },
            ],
            traits: ['physics'],
          }),
          createObject({
            name: 'Gripper',
            properties: [
              { key: 'geometry', value: 'robot_gripper.stl' },
              { key: 'position', value: [0, 0, 1] },
              { key: 'physics', value: { mass: 0.5 } },
            ],
            traits: ['physics', 'collidable', 'grabbable'],
          }),
        ],
        environment: { skybox: 'day' },
      });

      const customCompiler = new URDFCompiler({ robotName: 'RobotArm' });
      const urdf = customCompiler.compile(composition);

      // Verify structure
      expect(urdf).toContain('<robot name="RobotArm">');
      expect(urdf).toContain('<link name="base">');
      expect(urdf).toContain('<link name="arm1">');
      expect(urdf).toContain('<link name="gripper">');

      // Verify physics
      expect(urdf).toContain('<mass value="5"/>');
      expect(urdf).toContain('<mass value="2"/>');
      expect(urdf).toContain('<mass value="0.5"/>');

      // Verify geometries
      expect(urdf).toContain('<cylinder');
      expect(urdf).toContain('<box');
      expect(urdf).toContain('<mesh filename="package://meshes/robot_gripper.stl"/>');

      // Verify collision
      expect(urdf).toContain('<collision>');

      // Verify extensions
      expect(urdf).toContain('<!-- Environment skybox: day -->');
    });
  });
});
