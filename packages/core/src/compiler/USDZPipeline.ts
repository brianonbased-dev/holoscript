/**
 * USDZ Pipeline for HoloScript
 *
 * Generates USD ASCII (.usda) files from HoloScript compositions.
 * USDA files can be converted to USDZ using Apple's usdz_converter or
 * Python's pxr library.
 *
 * Pipeline: HoloScript AST → USDA (text) → usdz_converter → .usdz
 *
 * @version 1.0.0
 */

import type {
  HoloComposition,
  HoloObjectDecl,
  HoloSpatialGroup,
  HoloValue,
} from '../parser/HoloCompositionTypes';

// =============================================================================
// TYPES
// =============================================================================

export interface USDZPipelineOptions {
  /** Default up axis (Y or Z) */
  upAxis?: 'Y' | 'Z';
  /** Meters per unit */
  metersPerUnit?: number;
  /** Include animations */
  includeAnimations?: boolean;
  /** Export materials */
  exportMaterials?: boolean;
  /** Default material */
  defaultMaterial?: string;
}

export interface USDMaterial {
  name: string;
  baseColor?: [number, number, number];
  metallic?: number;
  roughness?: number;
  emissiveColor?: [number, number, number];
  opacity?: number;
  ior?: number;
}

export interface USDGeometry {
  type: 'sphere' | 'cube' | 'cylinder' | 'cone' | 'plane' | 'mesh';
  radius?: number;
  size?: [number, number, number];
  height?: number;
  /** Custom mesh data */
  points?: number[][];
  faceVertexCounts?: number[];
  faceVertexIndices?: number[];
}

export interface USDXform {
  name: string;
  translation?: [number, number, number];
  rotation?: [number, number, number]; // Euler angles in degrees
  scale?: [number, number, number];
  geometry?: USDGeometry;
  material?: string;
  children?: USDXform[];
}

export interface USDADocument {
  header: string;
  stage: string;
  materials: string;
  prims: string;
}

// =============================================================================
// USDZ PIPELINE
// =============================================================================

export class USDZPipeline {
  private options: Required<USDZPipelineOptions>;
  private materials: Map<string, USDMaterial> = new Map();
  private indentLevel: number = 0;

  constructor(options: USDZPipelineOptions = {}) {
    this.options = {
      upAxis: options.upAxis ?? 'Y',
      metersPerUnit: options.metersPerUnit ?? 1.0,
      includeAnimations: options.includeAnimations ?? false,
      exportMaterials: options.exportMaterials ?? true,
      defaultMaterial: options.defaultMaterial ?? 'DefaultMaterial',
    };
  }

  /**
   * Generate USDA from a HoloScript composition
   */
  generateUSDA(composition: HoloComposition): string {
    this.materials.clear();
    this.indentLevel = 0;

    const doc = this.buildDocument(composition);

    return [doc.header, doc.stage, doc.materials, doc.prims].join('\n\n');
  }

  /**
   * Build the complete USDA document
   */
  private buildDocument(composition: HoloComposition): USDADocument {
    // Collect materials from objects
    this.collectMaterials(composition);

    const header = this.generateHeader(composition.name);
    const stage = this.generateStageMetadata();
    const materials = this.options.exportMaterials ? this.generateMaterials() : '';
    const prims = this.generatePrims(composition);

    return { header, stage, materials, prims };
  }

  /**
   * Generate USDA header
   */
  private generateHeader(name: string): string {
    return `#usda 1.0
(
    defaultPrim = "${this.sanitizeName(name)}"
    doc = "Generated by HoloScript USDZPipeline"
    metersPerUnit = ${this.options.metersPerUnit}
    upAxis = "${this.options.upAxis}"
)`;
  }

  /**
   * Generate stage metadata
   */
  private generateStageMetadata(): string {
    const lines: string[] = [];
    lines.push('# Stage Configuration');
    lines.push(`# Up Axis: ${this.options.upAxis}`);
    lines.push(`# Meters Per Unit: ${this.options.metersPerUnit}`);
    return lines.join('\n');
  }

  /**
   * Collect all materials from composition
   */
  private collectMaterials(composition: HoloComposition): void {
    // Add default material
    this.materials.set(this.options.defaultMaterial, {
      name: this.options.defaultMaterial,
      baseColor: [0.8, 0.8, 0.8],
      metallic: 0,
      roughness: 0.5,
    });

    // Collect from objects
    if (composition.objects) {
      for (const obj of composition.objects) {
        this.collectMaterialsFromObject(obj);
      }
    }

    // Collect from spatial groups
    if (composition.spatialGroups) {
      for (const group of composition.spatialGroups) {
        this.collectMaterialsFromGroup(group);
      }
    }
  }

  /**
   * Collect materials from a single object
   */
  private collectMaterialsFromObject(obj: HoloObjectDecl): void {
    const color = this.findProp(obj, 'color');
    const material = this.findProp(obj, 'material');
    const surface = this.findProp(obj, 'surface');

    if (color || material || surface) {
      const matName = `Material_${this.sanitizeName(obj.name)}`;
      const mat: USDMaterial = { name: matName };

      if (typeof color === 'string') {
        mat.baseColor = this.hexToRGB(color);
      } else if (Array.isArray(color)) {
        mat.baseColor = color as [number, number, number];
      }

      if (typeof material === 'object' && material !== null) {
        const m = material as Record<string, unknown>;
        if (m.color) mat.baseColor = this.parseColor(m.color);
        if (typeof m.metalness === 'number') mat.metallic = m.metalness;
        if (typeof m.roughness === 'number') mat.roughness = m.roughness;
        if (m.emissive) mat.emissiveColor = this.parseColor(m.emissive);
        if (typeof m.opacity === 'number') mat.opacity = m.opacity;
      }

      // Surface presets
      if (surface === 'metal') {
        mat.metallic = 1.0;
        mat.roughness = 0.2;
      } else if (surface === 'glass') {
        mat.opacity = 0.1;
        mat.roughness = 0.0;
        mat.ior = 1.5;
      } else if (surface === 'plastic') {
        mat.metallic = 0;
        mat.roughness = 0.5;
      } else if (surface === 'emissive' || surface === 'hologram') {
        mat.emissiveColor = mat.baseColor || [1, 1, 1];
      }

      this.materials.set(matName, mat);
    }

    // Recurse into children
    if (obj.children) {
      for (const child of obj.children) {
        this.collectMaterialsFromObject(child);
      }
    }
  }

  /**
   * Collect materials from spatial group
   */
  private collectMaterialsFromGroup(group: HoloSpatialGroup): void {
    for (const obj of group.objects) {
      this.collectMaterialsFromObject(obj);
    }
    if (group.groups) {
      for (const sub of group.groups) {
        this.collectMaterialsFromGroup(sub);
      }
    }
  }

  /**
   * Generate all materials
   */
  private generateMaterials(): string {
    const lines: string[] = [];
    lines.push('# Materials');

    for (const [name, mat] of this.materials) {
      lines.push('');
      lines.push(`def Material "${name}"`);
      lines.push('{');

      // Surface shader
      lines.push(`    token outputs:surface.connect = </${name}/PBRShader.outputs:surface>`);
      lines.push('');

      // PBR Shader
      lines.push(`    def Shader "PBRShader"`);
      lines.push('    {');
      lines.push('        uniform token info:id = "UsdPreviewSurface"');

      if (mat.baseColor) {
        lines.push(
          `        color3f inputs:diffuseColor = (${mat.baseColor[0]}, ${mat.baseColor[1]}, ${mat.baseColor[2]})`
        );
      }

      lines.push(`        float inputs:metallic = ${mat.metallic ?? 0}`);
      lines.push(`        float inputs:roughness = ${mat.roughness ?? 0.5}`);

      if (mat.emissiveColor) {
        lines.push(
          `        color3f inputs:emissiveColor = (${mat.emissiveColor[0]}, ${mat.emissiveColor[1]}, ${mat.emissiveColor[2]})`
        );
      }

      if (mat.opacity !== undefined && mat.opacity < 1) {
        lines.push(`        float inputs:opacity = ${mat.opacity}`);
      }

      if (mat.ior !== undefined) {
        lines.push(`        float inputs:ior = ${mat.ior}`);
      }

      lines.push('        token outputs:surface');
      lines.push('    }');
      lines.push('}');
    }

    return lines.join('\n');
  }

  /**
   * Generate all prims (scene hierarchy)
   */
  private generatePrims(composition: HoloComposition): string {
    const lines: string[] = [];
    const rootName = this.sanitizeName(composition.name);

    lines.push('# Scene Hierarchy');
    lines.push('');
    lines.push(`def Xform "${rootName}" (`);
    lines.push('    kind = "assembly"');
    lines.push(')');
    lines.push('{');

    this.indentLevel = 1;

    // Generate objects
    if (composition.objects) {
      for (const obj of composition.objects) {
        lines.push(...this.generateObjectPrim(obj, rootName));
      }
    }

    // Generate spatial groups
    if (composition.spatialGroups) {
      for (const group of composition.spatialGroups) {
        lines.push(...this.generateGroupPrim(group, rootName));
      }
    }

    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate a single object prim
   */
  private generateObjectPrim(obj: HoloObjectDecl, parentPath: string): string[] {
    const lines: string[] = [];
    const name = this.sanitizeName(obj.name);
    const indent = '    '.repeat(this.indentLevel);
    const primPath = `${parentPath}/${name}`;

    const mesh = this.findProp(obj, 'mesh') || this.findProp(obj, 'type') || 'cube';
    const position = this.findProp(obj, 'position') as number[] | undefined;
    const rotation = this.findProp(obj, 'rotation') as number[] | undefined;
    const scale = this.findProp(obj, 'scale');
    const model = this.findProp(obj, 'model') || this.findProp(obj, 'src');

    lines.push('');
    lines.push(`${indent}def Xform "${name}"`);
    lines.push(`${indent}{`);

    // Transform
    if (position) {
      lines.push(
        `${indent}    double3 xformOp:translate = (${position[0]}, ${position[1]}, ${position[2]})`
      );
    }

    if (rotation) {
      // Convert degrees to radians for USD
      lines.push(
        `${indent}    float3 xformOp:rotateXYZ = (${rotation[0]}, ${rotation[1]}, ${rotation[2]})`
      );
    }

    if (scale) {
      if (Array.isArray(scale)) {
        lines.push(`${indent}    float3 xformOp:scale = (${scale[0]}, ${scale[1]}, ${scale[2]})`);
      } else {
        lines.push(`${indent}    float3 xformOp:scale = (${scale}, ${scale}, ${scale})`);
      }
    }

    const ops: string[] = [];
    if (position) ops.push('"xformOp:translate"');
    if (rotation) ops.push('"xformOp:rotateXYZ"');
    if (scale) ops.push('"xformOp:scale"');
    if (ops.length > 0) {
      lines.push(`${indent}    uniform token[] xformOpOrder = [${ops.join(', ')}]`);
    }

    // Reference external model
    if (model) {
      lines.push(`${indent}    # External model reference: ${model}`);
      lines.push(
        `${indent}    # prepend references = @${model}@</DefaultPrim> (requires asset bundling)`
      );
    } else {
      // Generate geometry
      lines.push(...this.generateGeometry(mesh as string, obj, indent + '    '));
    }

    // Material binding
    const matName = `Material_${name}`;
    if (this.materials.has(matName)) {
      lines.push(`${indent}    rel material:binding = </${matName}>`);
    } else {
      lines.push(`${indent}    rel material:binding = </${this.options.defaultMaterial}>`);
    }

    // Children
    if (obj.children) {
      this.indentLevel++;
      for (const child of obj.children) {
        lines.push(...this.generateObjectPrim(child, primPath));
      }
      this.indentLevel--;
    }

    lines.push(`${indent}}`);

    return lines;
  }

  /**
   * Generate geometry prim
   */
  private generateGeometry(meshType: string, obj: HoloObjectDecl, indent: string): string[] {
    const lines: string[] = [];
    const size = this.findProp(obj, 'size');
    const radius = (this.findProp(obj, 'radius') as number) ?? 0.5;

    switch (meshType) {
      case 'sphere':
        lines.push(`${indent}def Sphere "Geometry"`);
        lines.push(`${indent}{`);
        lines.push(`${indent}    double radius = ${radius}`);
        lines.push(`${indent}}`);
        break;

      case 'cube':
      case 'box':
        const boxSize = Array.isArray(size) ? size : [1, 1, 1];
        lines.push(`${indent}def Cube "Geometry"`);
        lines.push(`${indent}{`);
        lines.push(`${indent}    double size = ${Math.max(...(boxSize as number[]))}`);
        lines.push(`${indent}}`);
        break;

      case 'cylinder':
        const cylRadius = radius;
        const cylHeight = Array.isArray(size) ? (size as number[])[1] : 1;
        lines.push(`${indent}def Cylinder "Geometry"`);
        lines.push(`${indent}{`);
        lines.push(`${indent}    double height = ${cylHeight}`);
        lines.push(`${indent}    double radius = ${cylRadius}`);
        lines.push(`${indent}}`);
        break;

      case 'cone':
        const coneRadius = radius;
        const coneHeight = Array.isArray(size) ? (size as number[])[1] : 1;
        lines.push(`${indent}def Cone "Geometry"`);
        lines.push(`${indent}{`);
        lines.push(`${indent}    double height = ${coneHeight}`);
        lines.push(`${indent}    double radius = ${coneRadius}`);
        lines.push(`${indent}}`);
        break;

      case 'plane':
        const planeSize = typeof size === 'number' ? size : 1;
        lines.push(`${indent}def Mesh "Geometry"`);
        lines.push(`${indent}{`);
        lines.push(`${indent}    int[] faceVertexCounts = [4]`);
        lines.push(`${indent}    int[] faceVertexIndices = [0, 1, 2, 3]`);
        const half = planeSize / 2;
        lines.push(
          `${indent}    point3f[] points = [(${-half}, 0, ${-half}), (${half}, 0, ${-half}), (${half}, 0, ${half}), (${-half}, 0, ${half})]`
        );
        lines.push(`${indent}}`);
        break;

      case 'text':
        // Text requires mesh generation or font support
        const text = this.findProp(obj, 'text') || 'Text';
        lines.push(`${indent}# Text: "${text}" — requires font rasterization`);
        lines.push(`${indent}# Use MeshResource.generateText in RealityKit`);
        break;

      default:
        lines.push(`${indent}# Unsupported geometry type: ${meshType}`);
        lines.push(`${indent}def Cube "Geometry"`);
        lines.push(`${indent}{`);
        lines.push(`${indent}    double size = 1.0`);
        lines.push(`${indent}}`);
    }

    return lines;
  }

  /**
   * Generate spatial group prim
   */
  private generateGroupPrim(group: HoloSpatialGroup, parentPath: string): string[] {
    const lines: string[] = [];
    const name = this.sanitizeName(group.name);
    const indent = '    '.repeat(this.indentLevel);
    const primPath = `${parentPath}/${name}`;

    lines.push('');
    lines.push(`${indent}def Xform "${name}"`);
    lines.push(`${indent}{`);

    const position = group.properties.find((p) => p.key === 'position')?.value as
      | number[]
      | undefined;
    if (position) {
      lines.push(
        `${indent}    double3 xformOp:translate = (${position[0]}, ${position[1]}, ${position[2]})`
      );
      lines.push(`${indent}    uniform token[] xformOpOrder = ["xformOp:translate"]`);
    }

    this.indentLevel++;
    for (const obj of group.objects) {
      lines.push(...this.generateObjectPrim(obj, primPath));
    }

    if (group.groups) {
      for (const sub of group.groups) {
        lines.push(...this.generateGroupPrim(sub, primPath));
      }
    }
    this.indentLevel--;

    lines.push(`${indent}}`);

    return lines;
  }

  // =============================================================================
  // HELPERS
  // =============================================================================

  private findProp(obj: HoloObjectDecl, key: string): HoloValue | undefined {
    return obj.properties?.find((p) => p.key === key)?.value;
  }

  private sanitizeName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^(\d)/, '_$1');
  }

  private hexToRGB(hex: string): [number, number, number] {
    const h = hex.startsWith('#') ? hex.slice(1) : hex;
    const r = parseInt(h.substring(0, 2), 16) / 255;
    const g = parseInt(h.substring(2, 4), 16) / 255;
    const b = parseInt(h.substring(4, 6), 16) / 255;
    return [r, g, b];
  }

  private parseColor(value: unknown): [number, number, number] {
    if (typeof value === 'string') {
      return this.hexToRGB(value);
    }
    if (Array.isArray(value) && value.length >= 3) {
      return [value[0], value[1], value[2]];
    }
    return [1, 1, 1];
  }
}

// =============================================================================
// EXPORT FUNCTIONS
// =============================================================================

/**
 * Generate USDA from composition
 */
export function generateUSDA(
  composition: HoloComposition,
  options?: USDZPipelineOptions
): string {
  const pipeline = new USDZPipeline(options);
  return pipeline.generateUSDA(composition);
}

/**
 * Generate conversion command for usdz_converter
 */
export function getUSDZConversionCommand(usdaPath: string, usdzPath: string): string {
  return `xcrun usdz_converter "${usdaPath}" "${usdzPath}"`;
}

/**
 * Generate Python script for USD conversion
 */
export function getPythonConversionScript(usdaPath: string, usdzPath: string): string {
  return `#!/usr/bin/env python3
from pxr import Usd, UsdUtils

# Convert USDA to USDZ
stage = Usd.Stage.Open("${usdaPath}")
UsdUtils.CreateNewUsdzPackage("${usdaPath}", "${usdzPath}")
print(f"Converted {usdaPath} to {usdzPath}")
`;
}
