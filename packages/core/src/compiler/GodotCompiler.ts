/**
 * HoloScript → Godot GDScript Compiler
 *
 * Translates a HoloComposition AST into a Godot 4.x GDScript file
 * that builds the scene tree programmatically via _ready().
 *
 * Emits:
 *   - extends Node3D script
 *   - _ready() for scene construction
 *   - MeshInstance3D, CollisionShape3D, RigidBody3D, Light3D, Camera3D
 *   - AudioStreamPlayer3D, Area3D (zones), Timer (timelines)
 *   - UI via CanvasLayer + Control nodes
 *
 * @version 1.0.0
 */

import type {
  HoloComposition,
  HoloObjectDecl,
  HoloSpatialGroup,
  HoloLight,
  HoloEnvironment,
  HoloCamera,
  HoloTimeline,
  HoloAudio,
  HoloZone,
  HoloUI,
  HoloTransition,
  HoloEffects,
  HoloValue,
} from '../parser/HoloCompositionTypes';

export interface GodotCompilerOptions {
  className?: string;
  indent?: string;
  godotVersion?: '4.0' | '4.1' | '4.2' | '4.3';
}

export class GodotCompiler {
  private options: Required<GodotCompilerOptions>;
  private lines: string[] = [];
  private indentLevel: number = 0;

  constructor(options: GodotCompilerOptions = {}) {
    this.options = {
      className: options.className || 'GeneratedScene',
      indent: options.indent || '\t',
      godotVersion: options.godotVersion || '4.3',
    };
  }

  compile(composition: HoloComposition): string {
    this.lines = [];
    this.indentLevel = 0;

    this.emit(`# Auto-generated by HoloScript GodotCompiler`);
    this.emit(`# Source: composition "${composition.name}"`);
    this.emit(`# Target: Godot ${this.options.godotVersion}`);
    this.emit(`# Do not edit manually — regenerate from .holo source`);
    this.emit('');
    this.emit('extends Node3D');
    this.emit(`class_name ${this.options.className}`);
    this.emit('');

    // State variables
    if (composition.state) {
      this.emit('# === State ===');
      for (const prop of composition.state.properties) {
        const gdVal = this.toGDScriptValue(prop.value);
        this.emit(`var ${prop.key} = ${gdVal}`);
      }
      this.emit('');
    }

    // Ready function
    this.emit('func _ready():');
    this.indentLevel++;

    // Environment
    if (composition.environment) {
      this.compileEnvironment(composition.environment);
    }

    // Lights
    if (composition.lights) {
      for (const light of composition.lights) {
        this.compileLight(light);
      }
    }

    // Camera
    if (composition.camera) {
      this.compileCamera(composition.camera);
    }

    // Objects
    if (composition.objects) {
      for (const obj of composition.objects) {
        this.compileObject(obj, 'self');
      }
    }

    // Spatial groups
    if (composition.spatialGroups) {
      for (const group of composition.spatialGroups) {
        this.compileSpatialGroup(group, 'self');
      }
    }

    // Audio
    if (composition.audio) {
      for (const audio of composition.audio) {
        this.compileAudio(audio);
      }
    }

    // Zones
    if (composition.zones) {
      for (const zone of composition.zones) {
        this.compileZone(zone);
      }
    }

    // Timelines
    if (composition.timelines) {
      for (const tl of composition.timelines) {
        if (tl.autoplay) {
          this.emit(`_play_${this.sanitizeName(tl.name)}()`);
        }
      }
    }

    // UI
    if (composition.ui) {
      this.compileUI(composition.ui);
    }

    this.indentLevel--;
    this.emit('');

    // Timeline functions
    if (composition.timelines) {
      for (const tl of composition.timelines) {
        this.compileTimeline(tl);
      }
    }

    // Transition functions
    if (composition.transitions) {
      for (const tr of composition.transitions) {
        this.compileTransition(tr);
      }
    }

    // Effects (as comments)
    if (composition.effects) {
      this.compileEffects(composition.effects);
    }

    return this.lines.join('\n');
  }

  private compileEnvironment(env: HoloEnvironment): void {
    this.emit('# === Environment ===');
    for (const prop of env.properties) {
      if (prop.key === 'preset' || prop.key === 'skybox') {
        this.emit(`var env = WorldEnvironment.new()`);
        this.emit(`env.environment = Environment.new()`);
        this.emit(`env.environment.background_mode = Environment.BG_SKY`);
        this.emit(`add_child(env)`);
      } else if (prop.key === 'fog' && typeof prop.value === 'object') {
        const fog = prop.value as Record<string, any>;
        this.emit(`# Fog settings`);
        if (fog.color) this.emit(`# fog_color: ${fog.color}`);
        if (fog.near !== undefined) this.emit(`# fog_near: ${fog.near}`);
        if (fog.far !== undefined) this.emit(`# fog_far: ${fog.far}`);
      } else if (prop.key === 'ambient_light') {
        this.emit(`# Ambient light intensity: ${prop.value}`);
      }
    }
    this.emit('');
  }

  private compileLight(light: HoloLight): void {
    const varName = this.sanitizeName(light.name);
    this.emit(`# Light: ${light.name}`);

    const typeMap: Record<string, string> = {
      directional: 'DirectionalLight3D',
      point: 'OmniLight3D',
      spot: 'SpotLight3D',
    };
    const gdType = typeMap[light.lightType] || 'DirectionalLight3D';
    this.emit(`var ${varName} = ${gdType}.new()`);
    this.emit(`${varName}.name = "${light.name}"`);

    for (const prop of light.properties) {
      if (prop.key === 'color') {
        this.emit(`${varName}.light_color = ${this.toColor(prop.value)}`);
      } else if (prop.key === 'intensity') {
        this.emit(`${varName}.light_energy = ${prop.value}`);
      } else if (prop.key === 'position' && Array.isArray(prop.value)) {
        this.emit(`${varName}.position = ${this.toVector3(prop.value)}`);
      } else if (prop.key === 'cast_shadow' || prop.key === 'castShadow') {
        this.emit(`${varName}.shadow_enabled = ${prop.value}`);
      } else if (prop.key === 'distance') {
        this.emit(`${varName}.omni_range = ${prop.value}`);
      }
    }

    this.emit(`add_child(${varName})`);
    this.emit('');
  }

  private compileCamera(camera: HoloCamera): void {
    this.emit('# === Camera ===');
    this.emit('var cam = Camera3D.new()');
    const fov = this.findProp(camera.properties, 'fov');
    if (fov) this.emit(`cam.fov = ${fov}`);
    const pos = this.findProp(camera.properties, 'position');
    if (pos) this.emit(`cam.position = ${this.toVector3(pos as any)}`);
    const lookAt =
      this.findProp(camera.properties, 'look_at') || this.findProp(camera.properties, 'lookAt');
    if (lookAt) this.emit(`cam.look_at(${this.toVector3(lookAt as any)})`);
    const near = this.findProp(camera.properties, 'near');
    if (near) this.emit(`cam.near = ${near}`);
    const far = this.findProp(camera.properties, 'far');
    if (far) this.emit(`cam.far = ${far}`);
    this.emit('cam.current = true');
    this.emit('add_child(cam)');
    this.emit('');
  }

  private compileObject(obj: HoloObjectDecl, parentVar: string): void {
    const varName = this.sanitizeName(obj.name);
    const meshType = this.findObjProp(obj, 'mesh') || this.findObjProp(obj, 'type') || 'cube';
    const isText = meshType === 'text';
    const isModel = !!this.findObjProp(obj, 'model') || !!this.findObjProp(obj, 'src');
    const isSparkles = meshType === 'sparkles';
    const isLight = ['directional', 'point', 'spot', 'hemisphere', 'ambient', 'area'].includes(
      meshType as string
    );

    this.emit(`# Object: ${obj.name}`);

    if (isLight) {
      const lightMap: Record<string, string> = {
        directional: 'DirectionalLight3D',
        point: 'OmniLight3D',
        spot: 'SpotLight3D',
      };
      this.emit(`var ${varName} = ${lightMap[meshType as string] || 'DirectionalLight3D'}.new()`);
    } else if (isText) {
      this.emit(`var ${varName} = Label3D.new()`);
      const text = this.findObjProp(obj, 'text');
      if (text) this.emit(`${varName}.text = "${text}"`);
      const fontSize = this.findObjProp(obj, 'font_size');
      if (fontSize) this.emit(`${varName}.font_size = ${Math.round((fontSize as number) * 100)}`);
      const color = this.findObjProp(obj, 'color');
      if (color) this.emit(`${varName}.modulate = ${this.toColor(color)}`);
    } else if (isModel) {
      const src = this.findObjProp(obj, 'model') || this.findObjProp(obj, 'src');
      this.emit(`var ${varName} = load("res://models/${src}.glb").instantiate()`);
    } else if (isSparkles) {
      this.emit(`var ${varName} = GPUParticles3D.new()`);
    } else {
      // Physics body wrapper if needed
      const hasPhysics = obj.traits?.some((t) => t.name === 'physics' || t.name === 'grabbable');
      if (hasPhysics) {
        this.emit(`var ${varName}_body = RigidBody3D.new()`);
        this.emit(`${varName}_body.name = "${obj.name}"`);
      }

      this.emit(`var ${varName} = MeshInstance3D.new()`);

      const meshMap: Record<string, string> = {
        sphere: 'SphereMesh',
        box: 'BoxMesh',
        cube: 'BoxMesh',
        cylinder: 'CylinderMesh',
        cone: 'CylinderMesh',
        plane: 'PlaneMesh',
        torus: 'TorusMesh',
        capsule: 'CapsuleMesh',
      };
      const gdMesh = meshMap[meshType as string] || 'BoxMesh';
      this.emit(`${varName}.mesh = ${gdMesh}.new()`);

      // Size
      const size = this.findObjProp(obj, 'size');
      if (size && gdMesh === 'BoxMesh' && Array.isArray(size)) {
        this.emit(`${varName}.mesh.size = ${this.toVector3(size)}`);
      } else if (typeof size === 'number' && gdMesh === 'PlaneMesh') {
        this.emit(`${varName}.mesh.size = Vector2(${size}, ${size})`);
      }

      // Material
      const material = this.findObjProp(obj, 'material');
      if (material && typeof material === 'object') {
        const mat = material as Record<string, any>;
        this.emit(`var ${varName}_mat = StandardMaterial3D.new()`);
        if (mat.color) this.emit(`${varName}_mat.albedo_color = ${this.toColor(mat.color)}`);
        if (mat.roughness !== undefined) this.emit(`${varName}_mat.roughness = ${mat.roughness}`);
        if (mat.metalness !== undefined) this.emit(`${varName}_mat.metallic = ${mat.metalness}`);
        if (mat.emissive) {
          this.emit(`${varName}_mat.emission_enabled = true`);
          this.emit(`${varName}_mat.emission = ${this.toColor(mat.emissive)}`);
        }
        if (mat.transmission) {
          this.emit(`${varName}_mat.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA`);
        }
        this.emit(`${varName}.material_override = ${varName}_mat`);
      }

      // Collider
      const hasCollider = obj.traits?.some(
        (t) => t.name === 'collidable' || t.name === 'physics' || t.name === 'grabbable'
      );
      if (hasCollider && !hasPhysics) {
        this.emit(`var ${varName}_static = StaticBody3D.new()`);
        this.emit(`var ${varName}_shape = CollisionShape3D.new()`);
        this.emit(`${varName}_shape.shape = ${varName}.mesh.create_convex_shape()`);
        this.emit(`${varName}_static.add_child(${varName}_shape)`);
        this.emit(`${varName}_static.add_child(${varName})`);
      }

      if (hasPhysics) {
        this.emit(`var ${varName}_shape = CollisionShape3D.new()`);
        this.emit(`${varName}_shape.shape = ${varName}.mesh.create_convex_shape()`);
        this.emit(`${varName}_body.add_child(${varName}_shape)`);
        this.emit(`${varName}_body.add_child(${varName})`);
      }
    }

    this.emit(`${varName}.name = "${obj.name}"`);

    // Position, rotation, scale
    const pos = this.findObjProp(obj, 'position');
    if (pos) this.emit(`${varName}.position = ${this.toVector3(pos as any)}`);
    const rot = this.findObjProp(obj, 'rotation');
    if (rot && Array.isArray(rot)) {
      this.emit(`${varName}.rotation_degrees = ${this.toVector3(rot)}`);
    }
    const scale = this.findObjProp(obj, 'scale');
    if (scale) this.emit(`${varName}.scale = ${this.toVector3(scale as any)}`);

    // Add to parent
    const hasPhysics = obj.traits?.some((t) => t.name === 'physics' || t.name === 'grabbable');
    if (hasPhysics) {
      this.emit(`${parentVar}.add_child(${varName}_body)`);
    } else {
      this.emit(`${parentVar}.add_child(${varName})`);
    }

    // Expanded trait handling
    if (obj.traits) {
      for (const trait of obj.traits) {
        const tn = trait.name;
        // Skip traits already handled inline
        if (tn === 'collidable' || tn === 'physics' || tn === 'grabbable') continue;

        // Environment Understanding
        if (tn === 'plane_detection') {
          this.emit(`# @plane_detection — use XRServer plane detection`);
        } else if (tn === 'mesh_detection') {
          this.emit(`# @mesh_detection — use XRServer mesh tracking`);
        } else if (tn === 'anchor' || tn === 'persistent_anchor' || tn === 'shared_anchor') {
          this.emit(`# @${tn} — XRAnchor3D`);
        } else if (tn === 'occlusion') {
          this.emit(`# @occlusion — Environment3D occlusion`);
        } else if (tn === 'light_estimation') {
          this.emit(`# @light_estimation — XR light estimation`);
        }
        // Physics Expansion
        else if (tn === 'cloth') {
          this.emit(`var ${varName}_soft = SoftBody3D.new()`);
          this.emit(`${varName}_soft.name = "${obj.name}_cloth"`);
          this.emit(`# @cloth — configure SoftBody3D stiffness/damping`);
        } else if (tn === 'wind') {
          this.emit(`# @wind — use GPUParticles3D attractor or custom force`);
        } else if (tn === 'fluid') {
          this.emit(`# @fluid — custom SPH/particle fluid simulation`);
        } else if (tn === 'destruction') {
          this.emit(`# @destruction — pre-fractured mesh swap on impact`);
        } else if (tn === 'rope' || tn === 'chain') {
          this.emit(`# @${tn} — use PinJoint3D chain or custom solver`);
        }
        // Spatial Audio
        else if (tn === 'reverb_zone') {
          this.emit(`var ${varName}_reverb = AudioEffectReverb.new()`);
          this.emit(`# @reverb_zone — add to AudioBus`);
        } else if (
          tn === 'ambisonics' ||
          tn === 'hrtf' ||
          tn === 'audio_occlusion' ||
          tn === 'audio_portal' ||
          tn === 'audio_material' ||
          tn === 'head_tracked_audio'
        ) {
          this.emit(`# @${tn} — spatial audio: ${JSON.stringify(trait.config || {})}`);
        }
        // Volumetric Content
        else if (
          tn === 'gaussian_splat' ||
          tn === 'nerf' ||
          tn === 'volumetric_video' ||
          tn === 'point_cloud' ||
          tn === 'photogrammetry'
        ) {
          this.emit(`# @${tn} — volumetric renderer: ${JSON.stringify(trait.config || {})}`);
        }
        // Accessibility
        else if (
          tn === 'accessible' ||
          tn === 'alt_text' ||
          tn === 'screen_reader' ||
          tn === 'high_contrast' ||
          tn === 'motion_reduced' ||
          tn === 'magnifiable'
        ) {
          this.emit(`# @${tn} — accessibility: ${JSON.stringify(trait.config || {})}`);
        }
        // Input Modalities
        else if (
          tn === 'eye_tracking' ||
          tn === 'hand_tracking' ||
          tn === 'body_tracking' ||
          tn === 'face_tracking' ||
          tn === 'controller'
        ) {
          this.emit(`# @${tn} — XR input: ${JSON.stringify(trait.config || {})}`);
        }
        // Catch-all
        else {
          this.emit(`# @${tn}: ${JSON.stringify(trait.config || {})}`);
        }
      }
    }

    // Children
    if (obj.children) {
      for (const child of obj.children) {
        this.compileObject(child, varName);
      }
    }

    this.emit('');
  }

  private compileSpatialGroup(group: HoloSpatialGroup, parentVar: string): void {
    const varName = this.sanitizeName(group.name);
    this.emit(`# Spatial Group: ${group.name}`);
    this.emit(`var ${varName} = Node3D.new()`);
    this.emit(`${varName}.name = "${group.name}"`);

    for (const prop of group.properties) {
      if (prop.key === 'position' && Array.isArray(prop.value)) {
        this.emit(`${varName}.position = ${this.toVector3(prop.value)}`);
      }
    }

    this.emit(`${parentVar}.add_child(${varName})`);

    for (const obj of group.objects) {
      this.compileObject(obj, varName);
    }

    if (group.groups) {
      for (const sub of group.groups) {
        this.compileSpatialGroup(sub, varName);
      }
    }

    this.emit('');
  }

  private compileAudio(audio: HoloAudio): void {
    const varName = this.sanitizeName(audio.name);
    const spatial = audio.properties.find((p) => p.key === 'spatial')?.value;

    this.emit(`# Audio: ${audio.name}`);
    if (spatial) {
      this.emit(`var ${varName} = AudioStreamPlayer3D.new()`);
    } else {
      this.emit(`var ${varName} = AudioStreamPlayer.new()`);
    }
    this.emit(`${varName}.name = "${audio.name}"`);

    for (const prop of audio.properties) {
      if (prop.key === 'src' || prop.key === 'source') {
        this.emit(`${varName}.stream = load("res://audio/${prop.value}")`);
      } else if (prop.key === 'volume') {
        this.emit(`${varName}.volume_db = linear_to_db(${prop.value})`);
      } else if (prop.key === 'position' && Array.isArray(prop.value)) {
        this.emit(`${varName}.position = ${this.toVector3(prop.value)}`);
      } else if (prop.key === 'distance') {
        this.emit(`${varName}.max_distance = ${prop.value}`);
      }
    }

    const loop = audio.properties.find((p) => p.key === 'loop')?.value;
    this.emit(`add_child(${varName})`);
    this.emit(`${varName}.play()`);
    if (loop) {
      this.emit(`${varName}.finished.connect(func(): ${varName}.play())`);
    }
    this.emit('');
  }

  private compileZone(zone: HoloZone): void {
    const varName = this.sanitizeName(zone.name);
    this.emit(`# Zone: ${zone.name}`);
    this.emit(`var ${varName} = Area3D.new()`);
    this.emit(`${varName}.name = "${zone.name}"`);

    const shape = zone.properties.find((p) => p.key === 'shape')?.value;
    this.emit(`var ${varName}_shape = CollisionShape3D.new()`);

    if (shape === 'box') {
      this.emit(`${varName}_shape.shape = BoxShape3D.new()`);
      const size = zone.properties.find((p) => p.key === 'size')?.value;
      if (size && Array.isArray(size)) {
        this.emit(`${varName}_shape.shape.size = ${this.toVector3(size)}`);
      }
    } else if (shape === 'sphere') {
      this.emit(`${varName}_shape.shape = SphereShape3D.new()`);
      const radius = zone.properties.find((p) => p.key === 'radius')?.value;
      if (radius) this.emit(`${varName}_shape.shape.radius = ${radius}`);
    }

    this.emit(`${varName}.add_child(${varName}_shape)`);

    const pos = zone.properties.find((p) => p.key === 'position')?.value;
    if (pos) this.emit(`${varName}.position = ${this.toVector3(pos as any)}`);

    // Connect handlers
    for (const handler of zone.handlers) {
      if (handler.event === 'on_enter') {
        this.emit(`${varName}.body_entered.connect(func(body): print("${zone.name}: enter"))`);
      } else if (handler.event === 'on_exit') {
        this.emit(`${varName}.body_exited.connect(func(body): print("${zone.name}: exit"))`);
      }
    }

    this.emit(`add_child(${varName})`);
    this.emit('');
  }

  private compileTimeline(tl: HoloTimeline): void {
    const varName = this.sanitizeName(tl.name);
    this.emit(`func _play_${varName}():`);
    this.indentLevel++;

    this.emit(`var tween = create_tween()`);
    if (tl.loop) {
      this.emit(`tween.set_loops()`);
    }

    for (const entry of tl.entries) {
      if (entry.action.kind === 'animate') {
        this.emit(
          `tween.tween_callback(func(): pass) # animate "${entry.action.target}" at ${entry.time}s`
        );
        for (const [key, value] of Object.entries(entry.action.properties)) {
          this.emit(`# ${key}: ${JSON.stringify(value)}`);
        }
      } else if (entry.action.kind === 'emit') {
        this.emit(
          `tween.tween_callback(func(): print("Event: ${entry.action.event}")).set_delay(${entry.time})`
        );
      } else if (entry.action.kind === 'call') {
        this.emit(
          `tween.tween_callback(func(): ${entry.action.method}()).set_delay(${entry.time})`
        );
      }
    }

    this.indentLevel--;
    this.emit('');
  }

  private compileTransition(tr: HoloTransition): void {
    const varName = this.sanitizeName(tr.name);
    this.emit(`func ${varName}():`);
    this.indentLevel++;

    const target = tr.properties.find((p) => p.key === 'target')?.value;
    const effect = tr.properties.find((p) => p.key === 'effect')?.value;
    const duration = tr.properties.find((p) => p.key === 'duration')?.value;

    this.emit(`# Transition: ${effect} (${duration}s)`);
    if (target) {
      this.emit(`get_tree().change_scene_to_file("res://scenes/${target}.tscn")`);
    }

    this.indentLevel--;
    this.emit('');
  }

  private compileEffects(effects: HoloEffects): void {
    this.emit('# === Post-Processing (configure via WorldEnvironment) ===');
    for (const effect of effects.effects) {
      this.emit(`# Effect: ${effect.effectType} — ${JSON.stringify(effect.properties)}`);
    }
    this.emit('');
  }

  private compileUI(ui: HoloUI): void {
    this.emit('# === UI Overlay ===');
    this.emit('var ui_layer = CanvasLayer.new()');
    this.emit('ui_layer.name = "HoloUI"');
    this.emit('add_child(ui_layer)');
    this.emit('');

    for (const el of ui.elements) {
      const varName = this.sanitizeName(el.name);
      const elType = el.properties.find((p) => p.key === 'type')?.value;

      this.emit(`# UI: ${el.name} (${elType})`);
      if (elType === 'text') {
        this.emit(`var ${varName} = Label.new()`);
        const text = el.properties.find((p) => p.key === 'text')?.value;
        if (text) this.emit(`${varName}.text = "${text}"`);
      } else if (elType === 'progress') {
        this.emit(`var ${varName} = ProgressBar.new()`);
      } else if (elType === 'panel') {
        this.emit(`var ${varName} = Panel.new()`);
      } else {
        this.emit(`var ${varName} = Control.new()`);
      }
      this.emit(`${varName}.name = "${el.name}"`);

      const pos = el.properties.find((p) => p.key === 'position')?.value;
      if (pos && Array.isArray(pos)) {
        this.emit(`${varName}.position = Vector2(${pos[0]}, ${pos[1]})`);
      }
      const size = el.properties.find((p) => p.key === 'size')?.value;
      if (size && Array.isArray(size)) {
        this.emit(`${varName}.size = Vector2(${size[0]}, ${size[1]})`);
      }

      this.emit(`ui_layer.add_child(${varName})`);
      this.emit('');
    }
  }

  // ─── Helpers ───────────────────────────────────────────────────────────

  private emit(line: string): void {
    this.lines.push(this.options.indent.repeat(this.indentLevel) + line);
  }

  private sanitizeName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_');
  }

  private toVector3(arr: any): string {
    if (Array.isArray(arr) && arr.length >= 3) {
      return `Vector3(${arr[0]}, ${arr[1]}, ${arr[2]})`;
    }
    return `Vector3(${arr}, ${arr}, ${arr})`;
  }

  private toColor(value: any): string {
    if (typeof value === 'string' && value.startsWith('#')) {
      return `Color.html("${value}")`;
    }
    return `Color.WHITE`;
  }

  private toGDScriptValue(value: HoloValue): string {
    if (typeof value === 'number') return `${value}`;
    if (typeof value === 'boolean') return value ? 'true' : 'false';
    if (typeof value === 'string') return `"${value}"`;
    if (value === null) return 'null';
    if (Array.isArray(value)) return `[${value.map((v) => this.toGDScriptValue(v)).join(', ')}]`;
    return 'null';
  }

  private findProp(props: any[], key: string): HoloValue | undefined {
    return props?.find((p: any) => p.key === key)?.value;
  }

  private findObjProp(obj: HoloObjectDecl, key: string): HoloValue | undefined {
    return obj.properties?.find((p) => p.key === key)?.value;
  }
}
