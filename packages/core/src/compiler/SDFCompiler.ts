/**
 * HoloScript → SDF (Simulation Description Format) Compiler
 *
 * Exports HoloScript compositions to SDF XML format for Gazebo simulation.
 * SDF is more feature-rich than URDF, supporting environments, lights, and sensors.
 *
 * Maps:
 *   - Composition → World
 *   - Objects → Models with links
 *   - Environment → World properties (sky, lighting)
 *   - Lights → Light elements
 *   - @physics → Physics properties
 *   - @collidable → Collision geometry
 *   - @sensor → Sensor elements
 *
 * @version 1.0.0
 */

import type {
  HoloComposition,
  HoloObjectDecl,
  HoloSpatialGroup,
  HoloLight,
  HoloEnvironment,
  HoloValue,
} from '../parser/HoloCompositionTypes';

export interface SDFCompilerOptions {
  /** World name */
  worldName?: string;
  /** SDF version */
  sdfVersion?: string;
  /** Include physics configuration */
  includePhysics?: boolean;
  /** Physics engine */
  physicsEngine?: 'ode' | 'bullet' | 'dart' | 'simbody';
  /** Real-time factor */
  realTimeFactor?: number;
  /** Include scene lighting */
  includeScene?: boolean;
  /** Mesh export path prefix */
  meshPathPrefix?: string;
}

export class SDFCompiler {
  private options: Required<SDFCompilerOptions>;
  private lines: string[] = [];
  private indentLevel: number = 0;

  constructor(options: SDFCompilerOptions = {}) {
    this.options = {
      worldName: options.worldName || 'holoscript_world',
      sdfVersion: options.sdfVersion || '1.8',
      includePhysics: options.includePhysics ?? true,
      physicsEngine: options.physicsEngine || 'ode',
      realTimeFactor: options.realTimeFactor ?? 1.0,
      includeScene: options.includeScene ?? true,
      meshPathPrefix: options.meshPathPrefix || 'model://',
    };
  }

  compile(composition: HoloComposition): string {
    this.lines = [];
    this.indentLevel = 0;

    this.emit('<?xml version="1.0"?>');
    this.emit(`<!-- Auto-generated by HoloScript SDFCompiler -->`);
    this.emit(`<!-- Source: composition "${composition.name}" -->`);
    this.emit('');
    this.emit(`<sdf version="${this.options.sdfVersion}">`);
    this.indentLevel++;

    this.emit(`<world name="${this.escapeXml(this.options.worldName)}">`);
    this.indentLevel++;

    // Physics
    if (this.options.includePhysics) {
      this.emitPhysics();
    }

    // Scene (sky, ambient, shadows)
    if (this.options.includeScene) {
      this.emitScene(composition.environment);
    }

    // Ground plane
    this.emitGroundPlane();

    // Sun light
    this.emitSunLight();

    // Lights from composition
    if (composition.lights) {
      for (const light of composition.lights) {
        this.emitLight(light);
      }
    }

    // Objects
    if (composition.objects) {
      for (const obj of composition.objects) {
        this.emitModel(obj);
      }
    }

    // Spatial groups
    if (composition.spatialGroups) {
      for (const group of composition.spatialGroups) {
        this.emitSpatialGroup(group);
      }
    }

    this.indentLevel--;
    this.emit('</world>');

    this.indentLevel--;
    this.emit('</sdf>');

    return this.lines.join('\n');
  }

  private emitPhysics(): void {
    this.emit(`<physics name="default_physics" type="${this.options.physicsEngine}">`);
    this.indentLevel++;
    this.emit('<max_step_size>0.001</max_step_size>');
    this.emit(`<real_time_factor>${this.options.realTimeFactor}</real_time_factor>');
    this.emit('<real_time_update_rate>1000</real_time_update_rate>');
    
    if (this.options.physicsEngine === 'ode') {
      this.emit('<ode>');
      this.indentLevel++;
      this.emit('<solver>');
      this.indentLevel++;
      this.emit('<type>quick</type>');
      this.emit('<iters>50</iters>');
      this.emit('<sor>1.3</sor>');
      this.indentLevel--;
      this.emit('</solver>');
      this.emit('<constraints>');
      this.indentLevel++;
      this.emit('<cfm>0</cfm>');
      this.emit('<erp>0.2</erp>');
      this.indentLevel--;
      this.emit('</constraints>');
      this.indentLevel--;
      this.emit('</ode>');
    }
    
    this.indentLevel--;
    this.emit('</physics>');
    this.emit('');
  }

  private emitScene(environment?: HoloEnvironment): void {
    this.emit('<scene>');
    this.indentLevel++;
    
    // Ambient light
    const ambientLevel = environment?.ambient_light ?? 0.4;
    this.emit(`<ambient>${ambientLevel} ${ambientLevel} ${ambientLevel} 1</ambient>`);
    
    // Background (sky color)
    if (environment?.skybox) {
      const skyColors: Record<string, string> = {
        sunset: '0.9 0.5 0.3 1',
        night: '0.05 0.05 0.1 1',
        nebula: '0.1 0.05 0.2 1',
        day: '0.3 0.5 0.9 1',
        overcast: '0.5 0.5 0.5 1',
      };
      this.emit(`<background>${skyColors[environment.skybox] || '0.7 0.7 0.7 1'}</background>`);
    } else {
      this.emit('<background>0.7 0.7 0.7 1</background>');
    }
    
    this.emit('<shadows>true</shadows>');
    
    this.indentLevel--;
    this.emit('</scene>');
    this.emit('');
  }

  private emitGroundPlane(): void {
    this.emit('<model name="ground_plane">');
    this.indentLevel++;
    this.emit('<static>true</static>');
    this.emit('<link name="link">');
    this.indentLevel++;
    
    this.emit('<collision name="collision">');
    this.indentLevel++;
    this.emit('<geometry>');
    this.indentLevel++;
    this.emit('<plane>');
    this.indentLevel++;
    this.emit('<normal>0 0 1</normal>');
    this.emit('<size>100 100</size>');
    this.indentLevel--;
    this.emit('</plane>');
    this.indentLevel--;
    this.emit('</geometry>');
    this.indentLevel--;
    this.emit('</collision>');
    
    this.emit('<visual name="visual">');
    this.indentLevel++;
    this.emit('<geometry>');
    this.indentLevel++;
    this.emit('<plane>');
    this.indentLevel++;
    this.emit('<normal>0 0 1</normal>');
    this.emit('<size>100 100</size>');
    this.indentLevel--;
    this.emit('</plane>');
    this.indentLevel--;
    this.emit('</geometry>');
    this.emit('<material>');
    this.indentLevel++;
    this.emit('<ambient>0.8 0.8 0.8 1</ambient>');
    this.emit('<diffuse>0.8 0.8 0.8 1</diffuse>');
    this.indentLevel--;
    this.emit('</material>');
    this.indentLevel--;
    this.emit('</visual>');
    
    this.indentLevel--;
    this.emit('</link>');
    this.indentLevel--;
    this.emit('</model>');
    this.emit('');
  }

  private emitSunLight(): void {
    this.emit('<light name="sun" type="directional">');
    this.indentLevel++;
    this.emit('<cast_shadows>true</cast_shadows>');
    this.emit('<pose>0 0 10 0 0 0</pose>');
    this.emit('<diffuse>0.8 0.8 0.8 1</diffuse>');
    this.emit('<specular>0.2 0.2 0.2 1</specular>');
    this.emit('<direction>-0.5 0.1 -0.9</direction>');
    this.indentLevel--;
    this.emit('</light>');
    this.emit('');
  }

  private emitLight(light: HoloLight): void {
    const name = this.sanitizeName(light.name || 'light');
    const type = this.mapLightType(light.type);
    
    this.emit(`<light name="${name}" type="${type}">`);
    this.indentLevel++;
    
    this.emit(`<cast_shadows>${light.castShadow ?? true}</cast_shadows>`);
    
    const pos = light.position || [0, 0, 5];
    this.emit(`<pose>${pos[0]} ${pos[1]} ${pos[2]} 0 0 0</pose>`);
    
    const color = this.parseColor(light.color || '#ffffff');
    const intensity = light.intensity ?? 1.0;
    this.emit(`<diffuse>${color.r * intensity} ${color.g * intensity} ${color.b * intensity} 1</diffuse>`);
    this.emit(`<specular>${color.r * 0.3} ${color.g * 0.3} ${color.b * 0.3} 1</specular>`);
    
    if (type === 'spot') {
      this.emit('<spot>');
      this.indentLevel++;
      this.emit(`<inner_angle>${(light.angle || 45) * 0.8 * Math.PI / 180}</inner_angle>`);
      this.emit(`<outer_angle>${(light.angle || 45) * Math.PI / 180}</outer_angle>`);
      this.emit('<falloff>1</falloff>');
      this.indentLevel--;
      this.emit('</spot>');
    }
    
    if (light.range) {
      this.emit('<attenuation>');
      this.indentLevel++;
      this.emit(`<range>${light.range}</range>`);
      this.emit('<constant>0.5</constant>');
      this.emit('<linear>0.01</linear>');
      this.emit('<quadratic>0.001</quadratic>');
      this.indentLevel--;
      this.emit('</attenuation>');
    }
    
    this.indentLevel--;
    this.emit('</light>');
    this.emit('');
  }

  private emitModel(obj: HoloObjectDecl): void {
    const name = this.sanitizeName(obj.name);
    const traits = obj.traits || [];
    const isStatic = !traits.includes('physics') && !traits.includes('rigid');
    
    this.emit(`<model name="${name}">`);
    this.indentLevel++;
    
    if (isStatic) {
      this.emit('<static>true</static>');
    }
    
    // Pose
    const pos = this.extractPosition(obj);
    const rot = this.extractRotation(obj);
    this.emit(`<pose>${pos[0]} ${pos[1]} ${pos[2]} ${rot[0]} ${rot[1]} ${rot[2]}</pose>`);
    
    // Link
    this.emit(`<link name="${name}_link">`);
    this.indentLevel++;
    
    // Inertial (for dynamic objects)
    if (!isStatic) {
      const mass = this.extractMass(obj) || 1.0;
      this.emit('<inertial>');
      this.indentLevel++;
      this.emit(`<mass>${mass}</mass>`);
      this.emit('<inertia>');
      this.indentLevel++;
      this.emit(`<ixx>${mass * 0.1}</ixx><ixy>0</ixy><ixz>0</ixz>`);
      this.emit(`<iyy>${mass * 0.1}</iyy><iyz>0</iyz>`);
      this.emit(`<izz>${mass * 0.1}</izz>`);
      this.indentLevel--;
      this.emit('</inertia>');
      this.indentLevel--;
      this.emit('</inertial>');
    }
    
    // Collision
    if (traits.includes('collidable') || traits.includes('physics') || traits.includes('rigid')) {
      this.emit('<collision name="collision">');
      this.indentLevel++;
      this.emitGeometry(obj);
      this.indentLevel--;
      this.emit('</collision>');
    }
    
    // Visual
    this.emit('<visual name="visual">');
    this.indentLevel++;
    this.emitGeometry(obj);
    this.emitMaterial(obj);
    this.indentLevel--;
    this.emit('</visual>');
    
    this.indentLevel--;
    this.emit('</link>');
    
    this.indentLevel--;
    this.emit('</model>');
    this.emit('');
  }

  private emitSpatialGroup(group: HoloSpatialGroup): void {
    this.emit(`<!-- Spatial Group: ${group.name} -->`);
    if (group.objects) {
      for (const obj of group.objects) {
        this.emitModel(obj);
      }
    }
  }

  private emitGeometry(obj: HoloObjectDecl): void {
    const geometryProp = obj.properties.find(p => p.key === 'geometry');
    const geometryValue = geometryProp ? this.getStringValue(geometryProp.value) : 'box';
    const scale = this.extractScale(obj);
    
    this.emit('<geometry>');
    this.indentLevel++;
    
    switch (geometryValue) {
      case 'cube':
      case 'box':
        this.emit(`<box><size>${scale} ${scale} ${scale}</size></box>`);
        break;
      case 'sphere':
        this.emit(`<sphere><radius>${scale / 2}</radius></sphere>`);
        break;
      case 'cylinder':
        this.emit(`<cylinder><radius>${scale / 2}</radius><length>${scale}</length></cylinder>`);
        break;
      case 'plane':
        this.emit(`<plane><normal>0 0 1</normal><size>${scale} ${scale}</size></plane>`);
        break;
      case 'capsule':
        this.emit(`<capsule><radius>${scale / 3}</radius><length>${scale}</length></capsule>`);
        break;
      default:
        if (geometryValue.includes('.')) {
          // Mesh file
          this.emit(`<mesh><uri>${this.options.meshPathPrefix}${geometryValue}</uri></mesh>`);
        } else {
          this.emit(`<box><size>${scale} ${scale} ${scale}</size></box>`);
        }
    }
    
    this.indentLevel--;
    this.emit('</geometry>');
  }

  private emitMaterial(obj: HoloObjectDecl): void {
    const color = this.extractColor(obj);
    const traits = obj.traits || [];
    
    this.emit('<material>');
    this.indentLevel++;
    
    if (color) {
      const rgb = this.parseColor(color);
      this.emit(`<ambient>${rgb.r} ${rgb.g} ${rgb.b} 1</ambient>`);
      this.emit(`<diffuse>${rgb.r} ${rgb.g} ${rgb.b} 1</diffuse>`);
      this.emit(`<specular>0.1 0.1 0.1 1</specular>`);
      
      if (traits.includes('glowing') || traits.includes('emissive')) {
        this.emit(`<emissive>${rgb.r * 0.5} ${rgb.g * 0.5} ${rgb.b * 0.5} 1</emissive>`);
      }
    } else {
      this.emit('<ambient>0.7 0.7 0.7 1</ambient>');
      this.emit('<diffuse>0.7 0.7 0.7 1</diffuse>');
    }
    
    this.indentLevel--;
    this.emit('</material>');
  }

  private extractPosition(obj: HoloObjectDecl): [number, number, number] {
    const posProp = obj.properties.find(p => p.key === 'position');
    if (posProp && Array.isArray(posProp.value)) {
      return [
        Number(posProp.value[0]) || 0,
        Number(posProp.value[1]) || 0,
        Number(posProp.value[2]) || 0,
      ];
    }
    return [0, 0, 0];
  }

  private extractRotation(obj: HoloObjectDecl): [number, number, number] {
    const rotProp = obj.properties.find(p => p.key === 'rotation');
    if (rotProp && Array.isArray(rotProp.value)) {
      return [
        (Number(rotProp.value[0]) || 0) * Math.PI / 180,
        (Number(rotProp.value[1]) || 0) * Math.PI / 180,
        (Number(rotProp.value[2]) || 0) * Math.PI / 180,
      ];
    }
    return [0, 0, 0];
  }

  private extractScale(obj: HoloObjectDecl): number {
    const scaleProp = obj.properties.find(p => p.key === 'scale');
    if (scaleProp) {
      if (typeof scaleProp.value === 'number') return scaleProp.value;
      if (Array.isArray(scaleProp.value)) return Number(scaleProp.value[0]) || 1;
    }
    return 1;
  }

  private extractColor(obj: HoloObjectDecl): string | undefined {
    const colorProp = obj.properties.find(p => p.key === 'color');
    return colorProp ? this.getStringValue(colorProp.value) : undefined;
  }

  private extractMass(obj: HoloObjectDecl): number | undefined {
    const physicsProp = obj.properties.find(p => p.key === 'physics');
    if (physicsProp && typeof physicsProp.value === 'object' && !Array.isArray(physicsProp.value)) {
      const massEntry = (physicsProp.value as Record<string, unknown>).mass;
      if (typeof massEntry === 'number') return massEntry;
    }
    return undefined;
  }

  private mapLightType(type?: string): string {
    switch (type) {
      case 'point': return 'point';
      case 'directional': return 'directional';
      case 'spot': return 'spot';
      default: return 'point';
    }
  }

  private parseColor(color: string): { r: number; g: number; b: number } {
    if (color.startsWith('#')) {
      const hex = color.slice(1);
      return {
        r: parseInt(hex.slice(0, 2), 16) / 255,
        g: parseInt(hex.slice(2, 4), 16) / 255,
        b: parseInt(hex.slice(4, 6), 16) / 255,
      };
    }
    // Named colors
    const colors: Record<string, { r: number; g: number; b: number }> = {
      red: { r: 1, g: 0, b: 0 },
      green: { r: 0, g: 1, b: 0 },
      blue: { r: 0, g: 0, b: 1 },
      white: { r: 1, g: 1, b: 1 },
      black: { r: 0, g: 0, b: 0 },
      yellow: { r: 1, g: 1, b: 0 },
      cyan: { r: 0, g: 1, b: 1 },
      magenta: { r: 1, g: 0, b: 1 },
    };
    return colors[color.toLowerCase()] || { r: 0.7, g: 0.7, b: 0.7 };
  }

  private emit(line: string): void {
    const indent = '  '.repeat(this.indentLevel);
    this.lines.push(indent + line);
  }

  private sanitizeName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_').toLowerCase();
  }

  private escapeXml(str: string): string {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  }

  private getStringValue(value: HoloValue): string {
    if (typeof value === 'string') return value;
    if (typeof value === 'number') return String(value);
    if (typeof value === 'boolean') return String(value);
    return '';
  }
}

export default SDFCompiler;
