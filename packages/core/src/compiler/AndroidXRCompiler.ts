/**
 * HoloScript -> Android XR Compiler
 *
 * Translates a HoloComposition AST into Kotlin code targeting Android XR
 * (Jetpack XR / ARCore extensions).
 *
 * Emits:
 *   - Activity class with Jetpack Compose for XR
 *   - ARCore Session setup
 *   - SceneCore entity hierarchy
 *   - Spatial panel and orb placement
 *   - Filament/SceneView for 3D rendering
 *   - Passthrough and plane detection
 *   - Hand tracking integration
 *   - Spatial audio with Oboe
 *
 * @version 1.0.0
 */

import type {
  HoloComposition,
  HoloObjectDecl,
  HoloSpatialGroup,
  HoloLight,
  HoloEnvironment,
  HoloCamera,
  HoloTimeline,
  HoloAudio,
  HoloZone,
  HoloUI,
  HoloTransition,
  HoloValue,
  HoloEffects,
} from '../parser/HoloCompositionTypes';

export interface AndroidXRCompilerOptions {
  packageName?: string;
  activityName?: string;
  useFilament?: boolean;
  useARCore?: boolean;
  indent?: string;
}

export class AndroidXRCompiler {
  private options: Required<AndroidXRCompilerOptions>;
  private lines: string[] = [];
  private indentLevel: number = 0;

  constructor(options: AndroidXRCompilerOptions = {}) {
    this.options = {
      packageName: options.packageName || 'com.holoscript.generated',
      activityName: options.activityName || 'GeneratedXRActivity',
      useFilament: options.useFilament ?? true,
      useARCore: options.useARCore ?? true,
      indent: options.indent || '    ',
    };
  }

  compile(composition: HoloComposition): string {
    this.lines = [];
    this.indentLevel = 0;

    this.emit('// Auto-generated by HoloScript AndroidXRCompiler');
    this.emit(`// Source: composition "${composition.name}"`);
    this.emit('// Do not edit manually -- regenerate from .holo source');
    this.emit('');
    this.emit(`package ${this.options.packageName}`);
    this.emit('');
    this.emitImports(composition);
    this.emit('');
    this.emitActivityClass(composition);

    return this.lines.join('\n');
  }

  // ─── Imports ─────────────────────────────────────────────────────────

  private emitImports(composition: HoloComposition): void {
    this.emit('import android.os.Bundle');
    this.emit('import android.animation.ObjectAnimator');
    this.emit('import android.animation.AnimatorSet');
    this.emit('');
    this.emit('import androidx.activity.ComponentActivity');
    this.emit('import androidx.activity.compose.setContent');
    this.emit('import androidx.compose.runtime.*');
    this.emit('import androidx.compose.foundation.layout.*');
    this.emit('import androidx.compose.material3.*');
    this.emit('import androidx.compose.ui.Modifier');
    this.emit('import androidx.compose.ui.graphics.Color');
    this.emit('');
    this.emit('import androidx.xr.compose.spatial.*');
    this.emit('import androidx.xr.compose.subspace.layout.*');
    this.emit('import androidx.xr.scenecore.Entity');
    this.emit('import androidx.xr.scenecore.Session as XRSession');
    this.emit('import androidx.xr.runtime.math.Pose');
    this.emit('import androidx.xr.runtime.math.Vector3');
    this.emit('import androidx.xr.runtime.math.Quaternion');
    this.emit('');
    if (this.options.useARCore) {
      this.emit('import com.google.ar.core.Config');
      this.emit('import com.google.ar.core.Plane');
      this.emit('import com.google.ar.core.Anchor');
    }
    if (this.options.useFilament) {
      this.emit('import io.github.sceneview.ar.node.ArModelNode');
      this.emit('import io.github.sceneview.math.Position');
      this.emit('import io.github.sceneview.node.ModelNode');
      this.emit('import com.google.android.filament.LightManager');
      this.emit('import com.google.android.filament.utils.Float3');
    }
    const hasHandTracking = composition.objects?.some(o =>
      o.traits?.some(t => t.name === 'hand_tracking')
    );
    if (hasHandTracking) {
      this.emit('import androidx.xr.scenecore.InputEvent');
      this.emit('import androidx.xr.scenecore.HandNode');
    }
    if (composition.audio?.length) {
      this.emit('import android.media.AudioAttributes');
      this.emit('import android.media.SoundPool');
      this.emit('import androidx.xr.scenecore.SpatialAudioTrack');
    }
  }

  // ─── Activity Class ──────────────────────────────────────────────────

  private emitActivityClass(composition: HoloComposition): void {
    this.emit(`class ${this.options.activityName} : ComponentActivity() {`);
    this.indent();
    this.emit('private lateinit var xrSession: XRSession');
    if (composition.audio?.length) this.emit('private lateinit var soundPool: SoundPool');
    this.emit('');

    this.emit('override fun onCreate(savedInstanceState: Bundle?) {');
    this.indent();
    this.emit('super.onCreate(savedInstanceState)');
    this.emit('xrSession = XRSession.create(this)');
    if (this.options.useARCore) { this.emit(''); this.emitARSession(); }
    if (composition.audio?.length) {
      this.emit('');
      this.emit('val audioAttrs = AudioAttributes.Builder()');
      this.indent();
      this.emit('.setUsage(AudioAttributes.USAGE_GAME)');
      this.emit('.setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION).build()');
      this.dedent();
      this.emit('soundPool = SoundPool.Builder().setMaxStreams(8).setAudioAttributes(audioAttrs).build()');
    }
    this.emit('');
    this.emit('setContent {');
    this.indent();
    this.emit(`${this.sanitizeName(composition.name)}Scene()`);
    this.dedent();
    this.emit('}');
    this.dedent();
    this.emit('}');
    this.emit('');

    this.emitSceneComposable(composition);
    for (const tl of composition.timelines ?? []) this.emitTimeline(tl);
    for (const tr of composition.transitions ?? []) this.emitTransition(tr);

    this.dedent();
    this.emit('}');
  }

  // ─── AR Session ──────────────────────────────────────────────────────

  private emitARSession(): void {
    this.emit('xrSession.scene.configure { config ->');
    this.indent();
    this.emit('config.planeFindingMode = Config.PlaneFindingMode.HORIZONTAL_AND_VERTICAL');
    this.emit('config.lightEstimationMode = Config.LightEstimationMode.ENVIRONMENTAL_HDR');
    this.emit('config.depthMode = Config.DepthMode.AUTOMATIC');
    this.emit('config.updateMode = Config.UpdateMode.LATEST_CAMERA_IMAGE');
    this.dedent();
    this.emit('}');
  }

  // ─── Scene Composable ────────────────────────────────────────────────

  private emitSceneComposable(composition: HoloComposition): void {
    const name = this.sanitizeName(composition.name);
    this.emit('@Composable');
    this.emit(`private fun ${name}Scene() {`);
    this.indent();

    if (composition.state) {
      for (const p of composition.state.properties) {
        this.emit(`var ${p.key} by remember { mutableStateOf(${this.toKotlinValue(p.value)}) }`);
      }
      this.emit('');
    }

    this.emit('Subspace {');
    this.indent();
    if (composition.environment) this.emitEnvironment(composition.environment);
    if (composition.camera) this.emitCamera(composition.camera);
    for (const l of composition.lights ?? []) this.emitLight(l);
    for (const o of composition.objects ?? []) this.emitObject(o);
    for (const g of composition.spatialGroups ?? []) this.emitGroup(g);
    for (const a of composition.audio ?? []) this.emitAudio(a);
    for (const z of composition.zones ?? []) this.emitZone(z);
    if (composition.ui) this.emitUI(composition.ui);
    if (composition.effects) this.emitEffects(composition.effects);
    this.dedent();
    this.emit('}');

    this.dedent();
    this.emit('}');
    this.emit('');
  }

  // ─── Environment ─────────────────────────────────────────────────────

  private emitEnvironment(env: HoloEnvironment): void {
    this.emit('// Environment');
    for (const prop of env.properties) {
      if (prop.key === 'preset' || prop.key === 'skybox') {
        this.emit(`// Preset: "${prop.value}"`);
        this.emit('xrSession.scene.configure { config ->');
        this.indent();
        this.emit('config.lightEstimationMode = Config.LightEstimationMode.ENVIRONMENTAL_HDR');
        this.dedent();
        this.emit('}');
      } else if (prop.key === 'passthrough') {
        if (prop.value === true || prop.value === 'true') {
          this.emit('xrSession.scene.configure { it.focusMode = Config.FocusMode.AUTO }');
        }
      } else if (prop.key === 'fog' && typeof prop.value === 'object') {
        this.emit(`// Fog: ${JSON.stringify(prop.value)} -- apply via Filament renderer`);
      } else if (prop.key === 'ambient_light') {
        this.emit(`// Ambient light: ${prop.value}`);
      }
    }
  }

  // ─── Object ──────────────────────────────────────────────────────────

  private emitObject(obj: HoloObjectDecl): void {
    const v = this.sanitizeName(obj.name);
    const meshType = this.findProp(obj, 'mesh') ?? this.findProp(obj, 'type') ?? 'cube';
    const modelSrc = this.findProp(obj, 'model') ?? this.findProp(obj, 'src');
    this.emit('');
    this.emit(`// Object: ${obj.name}`);

    // Trait: plane_detection
    if (obj.traits?.some(t => t.name === 'plane_detection')) {
      this.emit(`val ${v}Plane = xrSession.scene.createEntity("${obj.name}_plane")`);
      this.emit(`${v}Plane.setPose(Pose(Vector3(0f, 0f, 0f), Quaternion.identity()))`);
    }
    // Trait: anchor
    const anchor = obj.traits?.find(t => t.name === 'anchor');
    if (anchor) {
      this.emit(`val ${v}Anchor = xrSession.scene.createAnchorEntity() // type: ${anchor.config?.type ?? 'plane'}`);
    }
    // Trait: hand_tracking
    if (obj.traits?.some(t => t.name === 'hand_tracking')) {
      this.emit(`val ${v}Hand = HandNode(xrSession)`);
      this.emit(`${v}Hand.setOnInputEventListener { event: InputEvent -> /* hand input */ }`);
    }

    if (modelSrc) {
      this.emit(`val ${v} = xrSession.scene.createEntity("${obj.name}")`);
      this.emit(`val ${v}Model = ArModelNode().apply { loadModelGlbAsync("${modelSrc}") }`);
    } else if (meshType === 'text') {
      const text = this.findProp(obj, 'text') ?? obj.name;
      const color = this.findProp(obj, 'color');
      this.emit(`SpatialPanel(SubspaceModifier.width(200f).height(60f)) {`);
      this.indent();
      this.emit(`Text("${text}", color = ${color ? this.toKotlinColor(color as string) : 'Color.White'})`);
      this.dedent();
      this.emit('}');
    } else {
      this.emit(`val ${v} = xrSession.scene.createEntity("${obj.name}")`);
      const pos = this.findProp(obj, 'position');
      if (pos && Array.isArray(pos)) {
        this.emit(`${v}.setPose(Pose(${this.toKotlinFloat3(pos as number[])}, Quaternion.identity()))`);
      }
      const scale = this.findProp(obj, 'scale');
      if (scale && Array.isArray(scale)) {
        this.emit(`${v}.setScale(${this.toKotlinFloat3(scale as number[])})`);
      } else if (typeof scale === 'number') {
        this.emit(`${v}.setScale(Float3(${scale}f, ${scale}f, ${scale}f))`);
      }
      const mat = this.findProp(obj, 'material');
      if (mat && typeof mat === 'object') {
        const m = mat as Record<string, any>;
        if (m.color) this.emit(`val ${v}Color = ${this.toKotlinColor(m.color)}`);
        if (m.roughness !== undefined) this.emit(`// roughness = ${m.roughness}f`);
        if (m.metalness !== undefined) this.emit(`// metalness = ${m.metalness}f`);
      }
      this.emit(`// Geometry: ${this.mapShapeToFilament(meshType as string)}`);
    }

    // Rotation comment
    const rot = this.findProp(obj, 'rotation');
    if (rot && Array.isArray(rot) && meshType !== 'text') {
      this.emit(`// Rotation: ${(rot as number[]).join(', ')} deg`);
    }

    // Remaining traits
    for (const t of obj.traits ?? []) {
      if (t.name === 'collidable') this.emit(`// Collision enabled for ${v}`);
      else if (t.name === 'physics') this.emit(`// Physics: mass=${t.config?.mass ?? 1.0}`);
      else if (t.name === 'grabbable') {
        this.emit(`${v}.setOnInputEventListener { _: InputEvent -> /* grab */ }`);
      }
    }

    for (const child of obj.children ?? []) this.emitObject(child);
  }

  // ─── Spatial Group ───────────────────────────────────────────────────

  private emitGroup(group: HoloSpatialGroup): void {
    const v = this.sanitizeName(group.name);
    this.emit('');
    this.emit(`// Group: ${group.name}`);
    this.emit(`val ${v} = xrSession.scene.createEntity("${group.name}")`);
    for (const p of group.properties) {
      if (p.key === 'position' && Array.isArray(p.value))
        this.emit(`${v}.setPose(Pose(${this.toKotlinFloat3(p.value as number[])}, Quaternion.identity()))`);
      else if (p.key === 'scale' && Array.isArray(p.value))
        this.emit(`${v}.setScale(${this.toKotlinFloat3(p.value as number[])})`);
      else if (p.key === 'scale' && typeof p.value === 'number')
        this.emit(`${v}.setScale(Float3(${p.value}f, ${p.value}f, ${p.value}f))`);
    }
    for (const o of group.objects) {
      this.emitObject(o);
      this.emit(`${v}.addChild(${this.sanitizeName(o.name)})`);
    }
    for (const sub of group.groups ?? []) {
      this.emitGroup(sub);
      this.emit(`${v}.addChild(${this.sanitizeName(sub.name)})`);
    }
  }

  // ─── Light ───────────────────────────────────────────────────────────

  private emitLight(light: HoloLight): void {
    const v = this.sanitizeName(light.name);
    const typeMap: Record<string, string> = {
      directional: 'DIRECTIONAL', point: 'POINT', spot: 'SPOT',
      ambient: 'DIRECTIONAL', hemisphere: 'DIRECTIONAL', area: 'POINT',
    };
    this.emit('');
    this.emit(`val ${v} = xrSession.scene.createEntity("${light.name}")`);
    this.emit(`// Filament type: LightManager.Type.${typeMap[light.lightType] ?? 'POINT'}`);

    const color = light.properties.find(p => p.key === 'color');
    const intensity = light.properties.find(p => p.key === 'intensity');
    const pos = light.properties.find(p => p.key === 'position');
    if (color) this.emit(`// Color: ${color.value}`);
    if (intensity) this.emit(`// Intensity: ${(intensity.value as number) * 100000}f lux`);
    if (pos && Array.isArray(pos.value))
      this.emit(`${v}.setPose(Pose(${this.toKotlinFloat3(pos.value as number[])}, Quaternion.identity()))`);
  }

  // ─── Camera ──────────────────────────────────────────────────────────

  private emitCamera(cam: HoloCamera): void {
    this.emit(`// Camera: ${cam.cameraType}`);
    for (const p of cam.properties) {
      if (p.key === 'passthrough' && (p.value === true || p.value === 'true'))
        this.emit('xrSession.scene.configure { it.focusMode = Config.FocusMode.AUTO }');
      else if (p.key === 'fov')
        this.emit(`// FOV: ${p.value} -- managed by XR headset`);
    }
  }

  // ─── Timeline ────────────────────────────────────────────────────────

  private emitTimeline(tl: HoloTimeline): void {
    const fn = this.sanitizeName(tl.name);
    this.emit('');
    this.emit(`private fun playTimeline_${fn}() {`);
    this.indent();
    this.emit('val set = AnimatorSet()');
    this.emit('val anims = mutableListOf<ObjectAnimator>()');

    for (const e of tl.entries) {
      const ms = Math.round(e.time * 1000);
      if (e.action.kind === 'animate') {
        for (const [k, val] of Object.entries(e.action.properties)) {
          if (typeof val === 'number') {
            this.emit(`anims.add(ObjectAnimator.ofFloat(null, "${k}", ${val}f).apply { startDelay = ${ms}L; duration = 300L })`);
          }
        }
      } else if (e.action.kind === 'emit') {
        this.emit(`// @${e.time}s emit "${e.action.event}"`);
      } else if (e.action.kind === 'call') {
        this.emit(`// @${e.time}s call ${e.action.method}()`);
      }
    }

    this.emit('set.playTogether(anims as List<android.animation.Animator>)');
    if (tl.loop) {
      this.emit('set.addListener(object : android.animation.AnimatorListenerAdapter() {');
      this.indent();
      this.emit(`override fun onAnimationEnd(a: android.animation.Animator) { playTimeline_${fn}() }`);
      this.dedent();
      this.emit('})');
    }
    this.emit('set.start()');
    this.dedent();
    this.emit('}');
  }

  // ─── Audio ───────────────────────────────────────────────────────────

  private emitAudio(audio: HoloAudio): void {
    const v = this.sanitizeName(audio.name);
    const src = audio.properties.find(p => p.key === 'src' || p.key === 'source')?.value;
    const spatial = audio.properties.find(p => p.key === 'spatial')?.value;
    const volume = audio.properties.find(p => p.key === 'volume')?.value ?? 1.0;
    const loop = audio.properties.find(p => p.key === 'loop')?.value;
    const pos = audio.properties.find(p => p.key === 'position')?.value;

    this.emit('');
    this.emit(`// Audio: ${audio.name}`);
    if (src) {
      this.emit(`val ${v}Id = soundPool.load(this, R.raw.${this.sanitizeName(src as string)}, 1)`);
    }
    if (spatial && pos && Array.isArray(pos)) {
      this.emit(`val ${v}Entity = xrSession.scene.createEntity("${audio.name}")`);
      this.emit(`${v}Entity.setPose(Pose(${this.toKotlinFloat3(pos as number[])}, Quaternion.identity()))`);
      this.emit(`val ${v}Track = SpatialAudioTrack(xrSession, ${v}Entity)`);
    }
    if (src) {
      this.emit(`soundPool.setOnLoadCompleteListener { pool, id, _ ->`);
      this.indent();
      this.emit(`if (id == ${v}Id) pool.play(id, ${volume}f, ${volume}f, 1, ${loop ? 1 : 0}, 1.0f)`);
      this.dedent();
      this.emit('}');
    }
  }

  // ─── UI ──────────────────────────────────────────────────────────────

  private emitUI(ui: HoloUI): void {
    this.emit('');
    this.emit('// UI Layer');
    for (const el of ui.elements) {
      const vn = this.sanitizeName(el.name);
      const w = el.properties.find(p => p.key === 'width')?.value ?? 400;
      const h = el.properties.find(p => p.key === 'height')?.value ?? 300;
      const text = el.properties.find(p => p.key === 'text')?.value;
      const label = el.properties.find(p => p.key === 'label')?.value;
      const elType = el.properties.find(p => p.key === 'type')?.value;

      this.emit(`SpatialPanel(SubspaceModifier.width(${w}f).height(${h}f)) {`);
      this.indent();
      if (elType === 'button' && label) {
        this.emit(`Button(onClick = { /* ${vn} */ }) { Text("${label}") }`);
      } else if (text) {
        const color = el.properties.find(p => p.key === 'color')?.value;
        this.emit(`Text("${text}", color = ${color ? this.toKotlinColor(color as string) : 'Color.White'})`);
      } else {
        this.emit(`Column(modifier = Modifier.fillMaxSize()) { Text("${el.name}") }`);
      }
      this.dedent();
      this.emit('}');
    }
  }

  // ─── Zones ───────────────────────────────────────────────────────────

  private emitZone(zone: HoloZone): void {
    const v = this.sanitizeName(zone.name);
    this.emit(`val ${v} = xrSession.scene.createEntity("${zone.name}")`);
    const pos = zone.properties.find(p => p.key === 'position')?.value;
    if (pos && Array.isArray(pos))
      this.emit(`${v}.setPose(Pose(${this.toKotlinFloat3(pos as number[])}, Quaternion.identity()))`);
    const shape = zone.properties.find(p => p.key === 'shape')?.value;
    const size = zone.properties.find(p => p.key === 'size')?.value;
    const radius = zone.properties.find(p => p.key === 'radius')?.value;
    if (shape === 'box' && size && Array.isArray(size))
      this.emit(`// Trigger volume: box ${(size as number[]).join('x')}`);
    else if (shape === 'sphere' && radius)
      this.emit(`// Trigger volume: sphere r=${radius}`);
    if (zone.handlers?.length)
      this.emit(`// Handlers: ${zone.handlers.map(h => h.event).join(', ')}`);
  }

  // ─── Effects ─────────────────────────────────────────────────────────

  private emitEffects(effects: HoloEffects): void {
    this.emit('// Post-processing (Filament Renderer)');
    for (const fx of effects.effects)
      this.emit(`// ${fx.effectType}: ${JSON.stringify(fx.properties)}`);
  }

  // ─── Transitions ─────────────────────────────────────────────────────

  private emitTransition(tr: HoloTransition): void {
    const fn = this.sanitizeName(tr.name);
    const target = tr.properties.find(p => p.key === 'target')?.value;
    const dur = tr.properties.find(p => p.key === 'duration')?.value ?? 0.5;
    this.emit('');
    this.emit(`private fun transition_${fn}() {`);
    this.indent();
    this.emit(`// -> "${target}"`);
    this.emit(`ObjectAnimator.ofFloat(null, "alpha", 1f, 0f).apply { duration = ${Math.round((dur as number) * 1000)}L }.start()`);
    this.dedent();
    this.emit('}');
  }

  // ─── Value Conversion Helpers ────────────────────────────────────────

  /** Converts [x, y, z] to `Float3(xf, yf, zf)`. */
  private toKotlinFloat3(arr: number[]): string {
    if (Array.isArray(arr) && arr.length >= 3)
      return `Float3(${arr[0]}f, ${arr[1]}f, ${arr[2]}f)`;
    if (Array.isArray(arr) && arr.length >= 1)
      return `Float3(${arr[0]}f, ${arr[0]}f, ${arr[0]}f)`;
    const v = typeof arr === 'number' ? arr : 0;
    return `Float3(${v}f, ${v}f, ${v}f)`;
  }

  /** Converts `#RRGGBB` or `#RRGGBBAA` to `Color(0xAARRGGBB)`. */
  private toKotlinColor(hex: string): string {
    if (typeof hex === 'string' && hex.startsWith('#')) {
      const raw = hex.slice(1);
      if (raw.length === 6) return `Color(0xFF${raw.toUpperCase()})`;
      if (raw.length === 8) {
        const [rr, gg, bb, aa] = [raw.substring(0,2), raw.substring(2,4), raw.substring(4,6), raw.substring(6,8)];
        return `Color(0x${aa.toUpperCase()}${rr.toUpperCase()}${gg.toUpperCase()}${bb.toUpperCase()})`;
      }
    }
    return 'Color.White';
  }

  /** Maps HoloScript shape names to Filament geometric primitive descriptions. */
  private mapShapeToFilament(type: string): string {
    const map: Record<string, string> = {
      cube: 'BoxShape', box: 'BoxShape', sphere: 'IcoSphereShape',
      cylinder: 'CylinderShape', cone: 'ConeShape', plane: 'QuadShape',
      torus: 'CustomRingGeometry', capsule: 'CapsuleShape',
    };
    return map[type] ?? `Unknown("${type}")`;
  }

  // ─── Generic Helpers ─────────────────────────────────────────────────

  private toKotlinValue(value: HoloValue): string {
    if (typeof value === 'number') return Number.isInteger(value) ? `${value}` : `${value}f`;
    if (typeof value === 'boolean') return value ? 'true' : 'false';
    if (typeof value === 'string') return `"${value}"`;
    if (value === null) return 'null';
    if (Array.isArray(value)) return `listOf(${value.map(v => this.toKotlinValue(v)).join(', ')})`;
    return 'null';
  }

  private findProp(obj: HoloObjectDecl, key: string): HoloValue | undefined {
    return obj.properties?.find(p => p.key === key)?.value;
  }

  private sanitizeName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_');
  }

  private emit(line: string): void {
    this.lines.push(this.options.indent.repeat(this.indentLevel) + line);
  }

  private indent(): void { this.indentLevel++; }
  private dedent(): void { if (this.indentLevel > 0) this.indentLevel--; }
}
