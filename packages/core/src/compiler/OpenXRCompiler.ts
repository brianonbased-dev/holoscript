/**
 * HoloScript â†’ OpenXR C++ Compiler
 *
 * Translates a HoloComposition AST into OpenXR C++ code
 * with Vulkan or OpenGL ES rendering backend.
 *
 * Emits:
 *   - OpenXR instance/session initialization
 *   - Reference space setup (LOCAL, STAGE, VIEW)
 *   - Swapchain management
 *   - Action sets for hand/controller input
 *   - Vulkan render pass per object
 *   - Hand tracking extension (XR_EXT_hand_tracking)
 *   - Spatial anchor extension
 *   - Passthrough (XR_FB_passthrough)
 *
 * @version 1.0.0
 */

import type {
  HoloComposition,
  HoloObjectDecl,
  HoloSpatialGroup,
  HoloLight,
  HoloEnvironment,
  HoloCamera,
  HoloValue,
} from '../parser/HoloCompositionTypes';

export interface OpenXRCompilerOptions {
  appName?: string;
  renderBackend?: 'vulkan' | 'opengl_es';
  enableHandTracking?: boolean;
  enablePassthrough?: boolean;
  indent?: string;
}

export class OpenXRCompiler {
  private options: Required<OpenXRCompilerOptions>;
  private lines: string[] = [];
  private indentLevel: number = 0;

  constructor(options: OpenXRCompilerOptions = {}) {
    this.options = {
      appName: options.appName || 'HoloScriptApp',
      renderBackend: options.renderBackend || 'vulkan',
      enableHandTracking: options.enableHandTracking ?? true,
      enablePassthrough: options.enablePassthrough ?? false,
      indent: options.indent || '    ',
    };
  }

  compile(composition: HoloComposition): string {
    this.lines = [];
    this.indentLevel = 0;

    this.emit('// Auto-generated by HoloScript OpenXRCompiler');
    this.emit(`// Source: composition "${composition.name}"`);
    this.emit('// Do not edit manually -- regenerate from .holo source');
    this.emit('');

    this.emitIncludes();
    this.emit('');
    this.emit(`namespace ${this.sanitizeName(composition.name)} {`);
    this.emit('');
    this.indent();

    // Light UBO struct
    this.emit('struct LightUBO {');
    this.indent();
    this.emit('glm::vec4 position;');
    this.emit('glm::vec4 color;');
    this.emit('float intensity;');
    this.emit('float range;');
    this.emit('float padding[2];');
    this.dedent();
    this.emit('};');
    this.emit('');

    // Global declarations
    this.emit('XrInstance instance = XR_NULL_HANDLE;');
    this.emit('XrSession session = XR_NULL_HANDLE;');
    this.emit('XrSpace appSpace = XR_NULL_HANDLE;');
    this.emit('XrSwapchain swapchain = XR_NULL_HANDLE;');
    this.emit('XrActionSet actionSet = XR_NULL_HANDLE;');
    this.emit('XrAction grabAction = XR_NULL_HANDLE;');
    this.emit('XrAction triggerAction = XR_NULL_HANDLE;');
    this.emit('XrAction aimPoseAction = XR_NULL_HANDLE;');
    this.emit('XrAction hapticAction = XR_NULL_HANDLE;');
    if (this.options.enableHandTracking) {
      this.emit('XrHandTrackerEXT handTrackerLeft = XR_NULL_HANDLE;');
      this.emit('XrHandTrackerEXT handTrackerRight = XR_NULL_HANDLE;');
    }
    this.emit('bool sessionRunning = false;');
    this.emit('');

    // Emit init functions
    this.emitInstanceInit(composition);
    this.emit('');
    this.emitSessionInit();
    this.emit('');
    this.emitActionSets();
    this.emit('');

    if (this.options.enableHandTracking) {
      this.emitHandTracking();
      this.emit('');
    }

    this.emitRenderPass();
    this.emit('');

    // Emit scene setup function
    this.emit('void setupScene() {');
    this.indent();

    if (composition.environment) {
      this.emitEnvironment(composition.environment);
    }

    for (const light of composition.lights ?? []) {
      this.emitLight(light);
    }

    for (const obj of composition.objects ?? []) {
      this.emitObject(obj);
    }

    for (const group of composition.spatialGroups ?? []) {
      this.emitGroup(group);
    }

    if (composition.camera) {
      this.emitCamera(composition.camera);
    }

    this.dedent();
    this.emit('}');
    this.emit('');

    // Render loop
    this.emitRenderLoop(composition);
    this.emit('');

    // Main function
    this.emit('int main() {');
    this.indent();
    this.emit('initInstance();');
    this.emit('initSession();');
    this.emit('initActionSets();');
    if (this.options.enableHandTracking) {
      this.emit('initHandTracking();');
    }
    this.emit('setupScene();');
    this.emit('renderLoop();');
    this.emit('');
    this.emit('// Cleanup');
    if (this.options.enableHandTracking) {
      this.emit('xrDestroyHandTrackerEXT(handTrackerLeft);');
      this.emit('xrDestroyHandTrackerEXT(handTrackerRight);');
    }
    this.emit('xrDestroySwapchain(swapchain);');
    this.emit('xrDestroySpace(appSpace);');
    this.emit('xrDestroySession(session);');
    this.emit('xrDestroyInstance(instance);');
    this.emit('return 0;');
    this.dedent();
    this.emit('}');

    this.dedent();
    this.emit('');
    this.emit(`} // namespace ${this.sanitizeName(composition.name)}`);

    return this.lines.join('\n');
  }

  // ---------------------------------------------------------------------------
  // Includes
  // ---------------------------------------------------------------------------

  private emitIncludes(): void {
    this.emit('#include <openxr/openxr.h>');
    this.emit('#include <openxr/openxr_platform.h>');
    if (this.options.enableHandTracking) {
      this.emit('#include <openxr/openxr_extension.h>');
    }
    this.emit('');
    if (this.options.renderBackend === 'vulkan') {
      this.emit('#include <vulkan/vulkan.h>');
    } else {
      this.emit('#include <GLES3/gl3.h>');
      this.emit('#include <EGL/egl.h>');
    }
    this.emit('');
    this.emit('#include <glm/glm.hpp>');
    this.emit('#include <glm/gtc/matrix_transform.hpp>');
    this.emit('#include <glm/gtc/type_ptr.hpp>');
    this.emit('');
    this.emit('#include <vector>');
    this.emit('#include <array>');
    this.emit('#include <string>');
    this.emit('#include <cstring>');
    this.emit('#include <cmath>');
    this.emit('#include <iostream>');
  }

  // ---------------------------------------------------------------------------
  // Instance initialization
  // ---------------------------------------------------------------------------

  private emitInstanceInit(composition: HoloComposition): void {
    this.emit('void initInstance() {');
    this.indent();

    this.emit('std::vector<const char*> extensions = {');
    this.indent();
    if (this.options.renderBackend === 'vulkan') {
      this.emit('XR_KHR_VULKAN_ENABLE2_EXTENSION_NAME,');
    } else {
      this.emit('XR_KHR_OPENGL_ES_ENABLE_EXTENSION_NAME,');
    }
    if (this.options.enableHandTracking) {
      this.emit('XR_EXT_HAND_TRACKING_EXTENSION_NAME,');
    }
    if (this.options.enablePassthrough) {
      this.emit('XR_FB_PASSTHROUGH_EXTENSION_NAME,');
    }

    // Check composition for anchor traits
    const needsAnchor = this.compositionUsesAnchor(composition);
    if (needsAnchor) {
      this.emit('XR_MSFT_SPATIAL_ANCHOR_EXTENSION_NAME,');
    }

    this.dedent();
    this.emit('};');
    this.emit('');

    this.emit('XrInstanceCreateInfo createInfo{XR_TYPE_INSTANCE_CREATE_INFO};');
    this.emit(`std::strncpy(createInfo.applicationInfo.applicationName, "${this.options.appName}", XR_MAX_APPLICATION_NAME_SIZE);`);
    this.emit('createInfo.applicationInfo.apiVersion = XR_CURRENT_API_VERSION;');
    this.emit('createInfo.enabledExtensionCount = static_cast<uint32_t>(extensions.size());');
    this.emit('createInfo.enabledExtensionNames = extensions.data();');
    this.emit('');
    this.emit('XrResult result = xrCreateInstance(&createInfo, &instance);');
    this.emit('if (XR_FAILED(result)) {');
    this.indent();
    this.emit('std::cerr << "Failed to create XR instance" << std::endl;');
    this.emit('return;');
    this.dedent();
    this.emit('}');

    this.dedent();
    this.emit('}');
  }

  // ---------------------------------------------------------------------------
  // Session initialization
  // ---------------------------------------------------------------------------

  private emitSessionInit(): void {
    this.emit('void initSession() {');
    this.indent();

    this.emit('// Get system');
    this.emit('XrSystemId systemId = XR_NULL_SYSTEM_ID;');
    this.emit('XrSystemGetInfo systemInfo{XR_TYPE_SYSTEM_GET_INFO};');
    this.emit('systemInfo.formFactor = XR_FORM_FACTOR_HEAD_MOUNTED_DISPLAY;');
    this.emit('xrGetSystem(instance, &systemInfo, &systemId);');
    this.emit('');

    if (this.options.renderBackend === 'vulkan') {
      this.emit('// Vulkan graphics binding');
      this.emit('XrGraphicsBindingVulkanKHR graphicsBinding{XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR};');
      this.emit('// TODO: populate graphicsBinding with VkInstance, VkPhysicalDevice, VkDevice, etc.');
    } else {
      this.emit('// OpenGL ES graphics binding');
      this.emit('XrGraphicsBindingOpenGLESAndroidKHR graphicsBinding{XR_TYPE_GRAPHICS_BINDING_OPENGL_ES_ANDROID_KHR};');
      this.emit('// TODO: populate graphicsBinding with EGLDisplay, EGLContext, EGLConfig');
    }
    this.emit('');

    this.emit('// Create session');
    this.emit('XrSessionCreateInfo sessionCreateInfo{XR_TYPE_SESSION_CREATE_INFO};');
    this.emit('sessionCreateInfo.systemId = systemId;');
    this.emit('sessionCreateInfo.next = &graphicsBinding;');
    this.emit('xrCreateSession(instance, &sessionCreateInfo, &session);');
    this.emit('');

    this.emit('// Reference space (STAGE for room-scale)');
    this.emit('XrReferenceSpaceCreateInfo refSpaceInfo{XR_TYPE_REFERENCE_SPACE_CREATE_INFO};');
    this.emit('refSpaceInfo.referenceSpaceType = XR_REFERENCE_SPACE_TYPE_STAGE;');
    this.emit('refSpaceInfo.poseInReferenceSpace.orientation = {0.0f, 0.0f, 0.0f, 1.0f};');
    this.emit('refSpaceInfo.poseInReferenceSpace.position = {0.0f, 0.0f, 0.0f};');
    this.emit('xrCreateReferenceSpace(session, &refSpaceInfo, &appSpace);');
    this.emit('');

    this.emit('// Swapchain');
    this.emit('XrSwapchainCreateInfo swapchainInfo{XR_TYPE_SWAPCHAIN_CREATE_INFO};');
    this.emit('swapchainInfo.usageFlags = XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT;');
    if (this.options.renderBackend === 'vulkan') {
      this.emit('swapchainInfo.format = VK_FORMAT_R8G8B8A8_SRGB;');
    } else {
      this.emit('swapchainInfo.format = GL_SRGB8_ALPHA8;');
    }
    this.emit('swapchainInfo.sampleCount = 1;');
    this.emit('swapchainInfo.width = 1920;');
    this.emit('swapchainInfo.height = 1920;');
    this.emit('swapchainInfo.faceCount = 1;');
    this.emit('swapchainInfo.arraySize = 2; // stereo');
    this.emit('swapchainInfo.mipCount = 1;');
    this.emit('xrCreateSwapchain(session, &swapchainInfo, &swapchain);');
    this.emit('');
    this.emit('sessionRunning = true;');

    this.dedent();
    this.emit('}');
  }

  // ---------------------------------------------------------------------------
  // Action sets (input)
  // ---------------------------------------------------------------------------

  private emitActionSets(): void {
    this.emit('void initActionSets() {');
    this.indent();

    this.emit('XrActionSetCreateInfo actionSetInfo{XR_TYPE_ACTION_SET_CREATE_INFO};');
    this.emit('std::strncpy(actionSetInfo.actionSetName, "gameplay", XR_MAX_ACTION_SET_NAME_SIZE);');
    this.emit('std::strncpy(actionSetInfo.localizedActionSetName, "Gameplay", XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE);');
    this.emit('xrCreateActionSet(instance, &actionSetInfo, &actionSet);');
    this.emit('');

    const actions = [
      { name: 'grabAction', id: 'grab', localized: 'Grab', type: 'XR_ACTION_TYPE_FLOAT_INPUT' },
      { name: 'triggerAction', id: 'trigger', localized: 'Trigger', type: 'XR_ACTION_TYPE_FLOAT_INPUT' },
      { name: 'aimPoseAction', id: 'aim_pose', localized: 'Aim Pose', type: 'XR_ACTION_TYPE_POSE_INPUT' },
      { name: 'hapticAction', id: 'haptic', localized: 'Haptic', type: 'XR_ACTION_TYPE_VIBRATION_OUTPUT' },
    ];

    for (const action of actions) {
      this.emit('{');
      this.indent();
      this.emit('XrActionCreateInfo info{XR_TYPE_ACTION_CREATE_INFO};');
      this.emit(`info.actionType = ${action.type};`);
      this.emit(`std::strncpy(info.actionName, "${action.id}", XR_MAX_ACTION_NAME_SIZE);`);
      this.emit(`std::strncpy(info.localizedActionName, "${action.localized}", XR_MAX_LOCALIZED_ACTION_NAME_SIZE);`);
      this.emit('info.countSubactionPaths = 0;');
      this.emit(`xrCreateAction(actionSet, &info, &${action.name});`);
      this.dedent();
      this.emit('}');
    }

    this.emit('');
    this.emit('// Attach action set to session');
    this.emit('XrSessionActionSetsAttachInfo attachInfo{XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO};');
    this.emit('attachInfo.countActionSets = 1;');
    this.emit('attachInfo.actionSets = &actionSet;');
    this.emit('xrAttachSessionActionSets(session, &attachInfo);');

    this.dedent();
    this.emit('}');
  }

  // ---------------------------------------------------------------------------
  // Environment (clear color, fog)
  // ---------------------------------------------------------------------------

  private emitEnvironment(env: HoloEnvironment): void {
    this.emit('// === Environment ===');
    for (const prop of env.properties) {
      if (prop.key === 'preset' || prop.key === 'skybox') {
        this.emit(`// Environment preset: "${prop.value}"`);
      } else if (prop.key === 'background' || prop.key === 'clear_color') {
        const color = this.toCppColor(prop.value as string);
        this.emit(`glm::vec4 clearColor = ${color};`);
      } else if (prop.key === 'fog' && typeof prop.value === 'object') {
        const fog = prop.value as Record<string, any>;
        const fogColor = fog.color ? this.toCppColor(fog.color) : 'glm::vec4(0.5f, 0.5f, 0.5f, 1.0f)';
        this.emit(`glm::vec4 fogColor = ${fogColor};`);
        this.emit(`float fogNear = ${fog.near ?? 10.0}f;`);
        this.emit(`float fogFar = ${fog.far ?? 100.0}f;`);
      } else if (prop.key === 'ambient_light') {
        const intensity = typeof prop.value === 'number' ? prop.value : 0.5;
        this.emit(`float ambientIntensity = ${intensity}f;`);
      } else if (prop.key === 'gravity' && Array.isArray(prop.value)) {
        this.emit(`glm::vec3 gravity = ${this.toCppVec3(prop.value)};`);
      }
    }
    this.emit('');
  }

  // ---------------------------------------------------------------------------
  // Object emission
  // ---------------------------------------------------------------------------

  private emitObject(obj: HoloObjectDecl): void {
    const varName = this.sanitizeName(obj.name);
    this.emit(`// Object: ${obj.name}`);
    this.emit('{');
    this.indent();

    const meshType = this.findObjProp(obj, 'mesh') || this.findObjProp(obj, 'type') || 'cube';
    const pos = this.findObjProp(obj, 'position');
    const scale = this.findObjProp(obj, 'scale');
    const color = this.findObjProp(obj, 'color');
    const material = this.findObjProp(obj, 'material');

    // Vertex data
    this.emit(`auto ${varName}_vertices = ${this.mapShapeToVertexData(meshType as string)};`);
    this.emit('');

    // Transform
    this.emit(`glm::mat4 ${varName}_model = glm::mat4(1.0f);`);
    if (pos && Array.isArray(pos)) {
      this.emit(`${varName}_model = glm::translate(${varName}_model, ${this.toCppVec3(pos)});`);
    }
    if (scale) {
      if (Array.isArray(scale)) {
        this.emit(`${varName}_model = glm::scale(${varName}_model, ${this.toCppVec3(scale)});`);
      } else {
        this.emit(`${varName}_model = glm::scale(${varName}_model, glm::vec3(${scale}f));`);
      }
    }
    this.emit('');

    // Material / color
    if (material && typeof material === 'object') {
      const mat = material as Record<string, any>;
      const baseColor = mat.color ? this.toCppColor(mat.color) : 'glm::vec4(1.0f)';
      this.emit(`glm::vec4 ${varName}_color = ${baseColor};`);
      this.emit(`float ${varName}_roughness = ${mat.roughness ?? 0.5}f;`);
      this.emit(`float ${varName}_metallic = ${mat.metalness ?? mat.metallic ?? 0.0}f;`);
    } else if (color) {
      this.emit(`glm::vec4 ${varName}_color = ${this.toCppColor(color as string)};`);
    } else {
      this.emit(`glm::vec4 ${varName}_color = glm::vec4(1.0f);`);
    }
    this.emit('');

    if (this.options.renderBackend === 'vulkan') {
      this.emit(`// Create Vulkan vertex buffer for ${obj.name}`);
      this.emit(`VkBuffer ${varName}_vbo; // TODO: vkCreateBuffer + vkAllocateMemory`);
      this.emit(`VkDescriptorSet ${varName}_desc; // TODO: allocate descriptor set`);
    } else {
      this.emit(`GLuint ${varName}_vao, ${varName}_vbo;`);
      this.emit(`glGenVertexArrays(1, &${varName}_vao);`);
      this.emit(`glGenBuffers(1, &${varName}_vbo);`);
      this.emit(`glBindVertexArray(${varName}_vao);`);
      this.emit(`glBindBuffer(GL_ARRAY_BUFFER, ${varName}_vbo);`);
      this.emit(`glBufferData(GL_ARRAY_BUFFER, ${varName}_vertices.size() * sizeof(float), ${varName}_vertices.data(), GL_STATIC_DRAW);`);
      this.emit('glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);');
      this.emit('glEnableVertexAttribArray(0);');
      this.emit('glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));');
      this.emit('glEnableVertexAttribArray(1);');
    }

    // Handle traits
    if (obj.traits) {
      for (const trait of obj.traits) {
        if (trait.name === 'hand_tracking') {
          this.emit('');
          this.emit(`// Trait: hand_tracking -- joint data driven via XR_EXT_hand_tracking`);
          this.emit(`// ${varName} position will be updated from hand joint locations each frame`);
        } else if (trait.name === 'anchor') {
          this.emit('');
          this.emit(`// Trait: anchor -- XR_MSFT_spatial_anchor`);
          this.emit(`XrSpatialAnchorMSFT ${varName}_anchor = XR_NULL_HANDLE;`);
          this.emit('XrSpatialAnchorCreateInfoMSFT anchorInfo{XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_MSFT};');
          this.emit('anchorInfo.space = appSpace;');
          this.emit('anchorInfo.time = predictedDisplayTime;');
          if (pos && Array.isArray(pos)) {
            this.emit(`anchorInfo.pose.position = {${(pos[0] ?? 0)}f, ${(pos[1] ?? 0)}f, ${(pos[2] ?? 0)}f};`);
          } else {
            this.emit('anchorInfo.pose.position = {0.0f, 0.0f, 0.0f};');
          }
          this.emit('anchorInfo.pose.orientation = {0.0f, 0.0f, 0.0f, 1.0f};');
          this.emit(`xrCreateSpatialAnchorMSFT(session, &anchorInfo, &${varName}_anchor);`);
        } else if (trait.name === 'grabbable') {
          this.emit('');
          this.emit(`// Trait: grabbable -- detect grip action on ${obj.name}`);
          this.emit(`bool ${varName}_grabbed = false;`);
        } else if (trait.name === 'physics') {
          this.emit('');
          this.emit(`// Trait: physics -- simulated via CPU/GPU physics step`);
          this.emit(`glm::vec3 ${varName}_velocity(0.0f);`);
          this.emit(`float ${varName}_mass = ${(trait.config?.mass as number) ?? 1.0}f;`);
        }
      }
    }

    this.dedent();
    this.emit('}');
    this.emit('');

    // Recurse children
    if (obj.children) {
      for (const child of obj.children) {
        this.emitObject(child);
      }
    }
  }

  // ---------------------------------------------------------------------------
  // Spatial group
  // ---------------------------------------------------------------------------

  private emitGroup(group: HoloSpatialGroup): void {
    const varName = this.sanitizeName(group.name);
    this.emit(`// Spatial Group: ${group.name}`);
    this.emit('{');
    this.indent();

    this.emit(`glm::mat4 ${varName}_transform = glm::mat4(1.0f);`);
    for (const prop of group.properties) {
      if (prop.key === 'position' && Array.isArray(prop.value)) {
        this.emit(`${varName}_transform = glm::translate(${varName}_transform, ${this.toCppVec3(prop.value)});`);
      } else if (prop.key === 'rotation' && Array.isArray(prop.value)) {
        const r = prop.value as number[];
        this.emit(`${varName}_transform = glm::rotate(${varName}_transform, glm::radians(${r[0] ?? 0}f), glm::vec3(1,0,0));`);
        this.emit(`${varName}_transform = glm::rotate(${varName}_transform, glm::radians(${r[1] ?? 0}f), glm::vec3(0,1,0));`);
        this.emit(`${varName}_transform = glm::rotate(${varName}_transform, glm::radians(${r[2] ?? 0}f), glm::vec3(0,0,1));`);
      } else if (prop.key === 'scale') {
        if (Array.isArray(prop.value)) {
          this.emit(`${varName}_transform = glm::scale(${varName}_transform, ${this.toCppVec3(prop.value)});`);
        } else {
          this.emit(`${varName}_transform = glm::scale(${varName}_transform, glm::vec3(${prop.value}f));`);
        }
      }
    }
    this.emit(`// Push ${varName}_transform onto model matrix stack`);
    this.emit('');

    for (const obj of group.objects) {
      this.emitObject(obj);
    }

    if (group.groups) {
      for (const sub of group.groups) {
        this.emitGroup(sub);
      }
    }

    this.emit('// Pop model matrix stack');
    this.dedent();
    this.emit('}');
    this.emit('');
  }

  // ---------------------------------------------------------------------------
  // Light
  // ---------------------------------------------------------------------------

  private emitLight(light: HoloLight): void {
    const varName = this.sanitizeName(light.name);
    this.emit(`// Light: ${light.name} (${light.lightType})`);
    this.emit('{');
    this.indent();

    this.emit(`LightUBO ${varName}_ubo;`);

    const colorProp = light.properties.find(p => p.key === 'color');
    const intensityProp = light.properties.find(p => p.key === 'intensity');
    const posProp = light.properties.find(p => p.key === 'position');

    if (posProp && Array.isArray(posProp.value)) {
      const p = posProp.value as number[];
      const w = light.lightType === 'directional' ? 0.0 : 1.0;
      this.emit(`${varName}_ubo.position = glm::vec4(${p[0]}f, ${p[1]}f, ${p[2]}f, ${w}f);`);
    } else {
      const w = light.lightType === 'directional' ? 0.0 : 1.0;
      this.emit(`${varName}_ubo.position = glm::vec4(0.0f, 5.0f, 0.0f, ${w}f);`);
    }

    if (colorProp) {
      this.emit(`${varName}_ubo.color = ${this.toCppColor(colorProp.value as string)};`);
    } else {
      this.emit(`${varName}_ubo.color = glm::vec4(1.0f);`);
    }

    this.emit(`${varName}_ubo.intensity = ${(intensityProp?.value as number) ?? 1.0}f;`);
    this.emit(`${varName}_ubo.range = ${light.lightType === 'directional' ? 0.0 : 50.0}f;`);

    this.emit(`// Upload ${varName}_ubo to uniform buffer`);

    this.dedent();
    this.emit('}');
    this.emit('');
  }

  // ---------------------------------------------------------------------------
  // Camera (XR view-driven)
  // ---------------------------------------------------------------------------

  private emitCamera(cam: HoloCamera): void {
    this.emit('// Camera: view/projection derived from xrLocateViews');
    this.emit('{');
    this.indent();

    this.emit('XrViewLocateInfo viewLocateInfo{XR_TYPE_VIEW_LOCATE_INFO};');
    this.emit('viewLocateInfo.viewConfigurationType = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO;');
    this.emit('viewLocateInfo.displayTime = predictedDisplayTime;');
    this.emit('viewLocateInfo.space = appSpace;');
    this.emit('');
    this.emit('XrViewState viewState{XR_TYPE_VIEW_STATE};');
    this.emit('uint32_t viewCount = 2;');
    this.emit('std::array<XrView, 2> views;');
    this.emit('views[0].type = XR_TYPE_VIEW;');
    this.emit('views[1].type = XR_TYPE_VIEW;');
    this.emit('xrLocateViews(session, &viewLocateInfo, &viewState, viewCount, &viewCount, views.data());');
    this.emit('');
    this.emit('// Per-eye projection and view matrices');
    this.emit('for (uint32_t eye = 0; eye < viewCount; eye++) {');
    this.indent();
    this.emit('const XrFovf& fov = views[eye].fov;');

    for (const prop of cam.properties) {
      if (prop.key === 'near' || prop.key === 'near_clip') {
        this.emit(`float nearClip = ${prop.value}f;`);
      } else if (prop.key === 'far' || prop.key === 'far_clip') {
        this.emit(`float farClip = ${prop.value}f;`);
      }
    }
    this.emit('// Build asymmetric projection from fov angles + near/far');
    this.emit('// Build view matrix from views[eye].pose');

    this.dedent();
    this.emit('}');

    this.dedent();
    this.emit('}');
    this.emit('');
  }

  // ---------------------------------------------------------------------------
  // Render pass
  // ---------------------------------------------------------------------------

  private emitRenderPass(): void {
    if (this.options.renderBackend === 'vulkan') {
      this.emit('void beginRenderPass(VkCommandBuffer cmd, VkRenderPass renderPass, VkFramebuffer framebuffer, uint32_t width, uint32_t height) {');
      this.indent();
      this.emit('VkRenderPassBeginInfo rpInfo{VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO};');
      this.emit('rpInfo.renderPass = renderPass;');
      this.emit('rpInfo.framebuffer = framebuffer;');
      this.emit('rpInfo.renderArea.extent = {width, height};');
      this.emit('VkClearValue clearValue{};');
      this.emit('clearValue.color = {{0.0f, 0.0f, 0.0f, 1.0f}};');
      this.emit('rpInfo.clearValueCount = 1;');
      this.emit('rpInfo.pClearValues = &clearValue;');
      this.emit('vkCmdBeginRenderPass(cmd, &rpInfo, VK_SUBPASS_CONTENTS_INLINE);');
      this.emit('');
      this.emit('// Bind pipeline and draw objects here');
      this.emit('');
      this.emit('vkCmdEndRenderPass(cmd);');
      this.dedent();
      this.emit('}');
    } else {
      this.emit('void beginRenderPass(uint32_t framebuffer, uint32_t width, uint32_t height) {');
      this.indent();
      this.emit('glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);');
      this.emit('glViewport(0, 0, width, height);');
      this.emit('glClearColor(0.0f, 0.0f, 0.0f, 1.0f);');
      this.emit('glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);');
      this.emit('glEnable(GL_DEPTH_TEST);');
      this.emit('');
      this.emit('// Bind shader program and draw objects here');
      this.emit('');
      this.dedent();
      this.emit('}');
    }
  }

  // ---------------------------------------------------------------------------
  // Render loop
  // ---------------------------------------------------------------------------

  private emitRenderLoop(composition: HoloComposition): void {
    this.emit('void renderLoop() {');
    this.indent();

    this.emit('while (sessionRunning) {');
    this.indent();

    this.emit('// Poll OpenXR events');
    this.emit('XrEventDataBuffer event{XR_TYPE_EVENT_DATA_BUFFER};');
    this.emit('while (xrPollEvent(instance, &event) == XR_SUCCESS) {');
    this.indent();
    this.emit('if (event.type == XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED) {');
    this.indent();
    this.emit('auto* stateEvent = reinterpret_cast<XrEventDataSessionStateChanged*>(&event);');
    this.emit('if (stateEvent->state == XR_SESSION_STATE_STOPPING) {');
    this.indent();
    this.emit('sessionRunning = false;');
    this.dedent();
    this.emit('}');
    this.dedent();
    this.emit('}');
    this.emit('event = {XR_TYPE_EVENT_DATA_BUFFER};');
    this.dedent();
    this.emit('}');
    this.emit('if (!sessionRunning) break;');
    this.emit('');

    this.emit('// Sync actions');
    this.emit('XrActiveActionSet activeActionSet{actionSet, XR_NULL_PATH};');
    this.emit('XrActionsSyncInfo syncInfo{XR_TYPE_ACTIONS_SYNC_INFO};');
    this.emit('syncInfo.countActiveActionSets = 1;');
    this.emit('syncInfo.activeActionSets = &activeActionSet;');
    this.emit('xrSyncActions(session, &syncInfo);');
    this.emit('');

    this.emit('// Wait frame');
    this.emit('XrFrameWaitInfo waitInfo{XR_TYPE_FRAME_WAIT_INFO};');
    this.emit('XrFrameState frameState{XR_TYPE_FRAME_STATE};');
    this.emit('xrWaitFrame(session, &waitInfo, &frameState);');
    this.emit('');

    this.emit('// Begin frame');
    this.emit('XrFrameBeginInfo beginInfo{XR_TYPE_FRAME_BEGIN_INFO};');
    this.emit('xrBeginFrame(session, &beginInfo);');
    this.emit('');

    this.emit('XrTime predictedDisplayTime = frameState.predictedDisplayTime;');
    this.emit('');

    // Hand tracking per-frame update
    if (this.options.enableHandTracking) {
      this.emit('// Hand tracking update');
      this.emit('updateHandTracking(predictedDisplayTime);');
      this.emit('');
    }

    this.emit('// Locate views for stereo rendering');
    this.emit('XrViewLocateInfo viewLocateInfo{XR_TYPE_VIEW_LOCATE_INFO};');
    this.emit('viewLocateInfo.viewConfigurationType = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO;');
    this.emit('viewLocateInfo.displayTime = predictedDisplayTime;');
    this.emit('viewLocateInfo.space = appSpace;');
    this.emit('XrViewState viewState{XR_TYPE_VIEW_STATE};');
    this.emit('uint32_t viewCount = 2;');
    this.emit('std::array<XrView, 2> views;');
    this.emit('views[0].type = XR_TYPE_VIEW;');
    this.emit('views[1].type = XR_TYPE_VIEW;');
    this.emit('xrLocateViews(session, &viewLocateInfo, &viewState, viewCount, &viewCount, views.data());');
    this.emit('');

    this.emit('// Acquire and render to swapchain image');
    this.emit('XrSwapchainImageAcquireInfo acquireInfo{XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO};');
    this.emit('uint32_t imageIndex;');
    this.emit('xrAcquireSwapchainImage(swapchain, &acquireInfo, &imageIndex);');
    this.emit('');
    this.emit('XrSwapchainImageWaitInfo swapWaitInfo{XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO};');
    this.emit('swapWaitInfo.timeout = XR_INFINITE_DURATION;');
    this.emit('xrWaitSwapchainImage(swapchain, &swapWaitInfo);');
    this.emit('');
    this.emit('// === Render scene objects ===');
    this.emit('// TODO: iterate scene objects, bind pipelines, issue draw calls');
    this.emit('');

    this.emit('XrSwapchainImageReleaseInfo releaseInfo{XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO};');
    this.emit('xrReleaseSwapchainImage(swapchain, &releaseInfo);');
    this.emit('');

    this.emit('// End frame');
    this.emit('XrCompositionLayerProjection layer{XR_TYPE_COMPOSITION_LAYER_PROJECTION};');
    this.emit('layer.space = appSpace;');
    this.emit('std::array<XrCompositionLayerProjectionView, 2> projViews;');
    this.emit('for (uint32_t eye = 0; eye < 2; eye++) {');
    this.indent();
    this.emit('projViews[eye] = {XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW};');
    this.emit('projViews[eye].pose = views[eye].pose;');
    this.emit('projViews[eye].fov = views[eye].fov;');
    this.emit('projViews[eye].subImage.swapchain = swapchain;');
    this.emit('projViews[eye].subImage.imageArrayIndex = eye;');
    this.emit('projViews[eye].subImage.imageRect.offset = {0, 0};');
    this.emit('projViews[eye].subImage.imageRect.extent = {1920, 1920};');
    this.dedent();
    this.emit('}');
    this.emit('layer.viewCount = 2;');
    this.emit('layer.views = projViews.data();');
    this.emit('');
    this.emit('const XrCompositionLayerBaseHeader* layers[] = {');
    this.indent();
    this.emit('reinterpret_cast<const XrCompositionLayerBaseHeader*>(&layer)');
    this.dedent();
    this.emit('};');
    this.emit('XrFrameEndInfo endInfo{XR_TYPE_FRAME_END_INFO};');
    this.emit('endInfo.displayTime = predictedDisplayTime;');
    this.emit('endInfo.environmentBlendMode = XR_ENVIRONMENT_BLEND_MODE_OPAQUE;');
    this.emit('endInfo.layerCount = 1;');
    this.emit('endInfo.layers = layers;');
    this.emit('xrEndFrame(session, &endInfo);');

    this.dedent();
    this.emit('}');

    this.dedent();
    this.emit('}');
  }

  // ---------------------------------------------------------------------------
  // Hand tracking
  // ---------------------------------------------------------------------------

  private emitHandTracking(): void {
    this.emit('void initHandTracking() {');
    this.indent();

    this.emit('XrHandTrackerCreateInfoEXT createInfo{XR_TYPE_HAND_TRACKER_CREATE_INFO_EXT};');
    this.emit('');
    this.emit('createInfo.hand = XR_HAND_LEFT_EXT;');
    this.emit('createInfo.handJointSet = XR_HAND_JOINT_SET_DEFAULT_EXT;');
    this.emit('xrCreateHandTrackerEXT(session, &createInfo, &handTrackerLeft);');
    this.emit('');
    this.emit('createInfo.hand = XR_HAND_RIGHT_EXT;');
    this.emit('xrCreateHandTrackerEXT(session, &createInfo, &handTrackerRight);');

    this.dedent();
    this.emit('}');
    this.emit('');

    this.emit('void updateHandTracking(XrTime displayTime) {');
    this.indent();

    this.emit('XrHandJointLocationsEXT locations{XR_TYPE_HAND_JOINT_LOCATIONS_EXT};');
    this.emit(`std::array<XrHandJointLocationEXT, XR_HAND_JOINT_COUNT_EXT> jointLocations;`);
    this.emit('locations.jointCount = static_cast<uint32_t>(jointLocations.size());');
    this.emit('locations.jointLocations = jointLocations.data();');
    this.emit('');
    this.emit('XrHandJointsLocateInfoEXT locateInfo{XR_TYPE_HAND_JOINTS_LOCATE_INFO_EXT};');
    this.emit('locateInfo.baseSpace = appSpace;');
    this.emit('locateInfo.time = displayTime;');
    this.emit('');
    this.emit('// Left hand');
    this.emit('xrLocateHandJointsEXT(handTrackerLeft, &locateInfo, &locations);');
    this.emit('if (locations.isActive) {');
    this.indent();
    this.emit('// Process left hand joint positions');
    this.emit('for (uint32_t j = 0; j < XR_HAND_JOINT_COUNT_EXT; j++) {');
    this.indent();
    this.emit('const auto& loc = jointLocations[j];');
    this.emit('glm::vec3 pos(loc.pose.position.x, loc.pose.position.y, loc.pose.position.z);');
    this.emit('// Update hand-tracked object transforms from joint data');
    this.dedent();
    this.emit('}');
    this.dedent();
    this.emit('}');
    this.emit('');
    this.emit('// Right hand');
    this.emit('xrLocateHandJointsEXT(handTrackerRight, &locateInfo, &locations);');
    this.emit('if (locations.isActive) {');
    this.indent();
    this.emit('for (uint32_t j = 0; j < XR_HAND_JOINT_COUNT_EXT; j++) {');
    this.indent();
    this.emit('const auto& loc = jointLocations[j];');
    this.emit('glm::vec3 pos(loc.pose.position.x, loc.pose.position.y, loc.pose.position.z);');
    this.emit('// Update hand-tracked object transforms from joint data');
    this.dedent();
    this.emit('}');
    this.dedent();
    this.emit('}');

    this.dedent();
    this.emit('}');
  }

  // ---------------------------------------------------------------------------
  // Helpers
  // ---------------------------------------------------------------------------

  private emit(line: string): void {
    this.lines.push(this.options.indent.repeat(this.indentLevel) + line);
  }

  private indent(): void {
    this.indentLevel++;
  }

  private dedent(): void {
    if (this.indentLevel > 0) this.indentLevel--;
  }

  private sanitizeName(name: string): string {
    return name.replace(/[^a-zA-Z0-9_]/g, '_');
  }

  private findObjProp(obj: HoloObjectDecl, key: string): HoloValue | undefined {
    return obj.properties?.find(p => p.key === key)?.value;
  }

  // ---------------------------------------------------------------------------
  // Value conversion helpers
  // ---------------------------------------------------------------------------

  toCppVec3(arr: HoloValue): string {
    if (Array.isArray(arr) && arr.length >= 3) {
      return `glm::vec3(${arr[0]}f, ${arr[1]}f, ${arr[2]}f)`;
    }
    if (typeof arr === 'number') {
      return `glm::vec3(${arr}f)`;
    }
    return 'glm::vec3(0.0f)';
  }

  toCppColor(hex: HoloValue): string {
    if (typeof hex === 'string' && hex.startsWith('#')) {
      const h = hex.slice(1);
      const r = (parseInt(h.substring(0, 2), 16) / 255).toFixed(3);
      const g = (parseInt(h.substring(2, 4), 16) / 255).toFixed(3);
      const b = (parseInt(h.substring(4, 6), 16) / 255).toFixed(3);
      return `glm::vec4(${r}f, ${g}f, ${b}f, 1.0f)`;
    }
    if (typeof hex === 'string') {
      return `glm::vec4(1.0f) /* ${hex} */`;
    }
    return 'glm::vec4(1.0f)';
  }

  mapShapeToVertexData(type: string): string {
    switch (type) {
      case 'cube':
      case 'box':
        return 'generateCubeVertices()';
      case 'sphere':
      case 'orb':
        return 'generateSphereVertices(32, 32)';
      case 'plane':
        return 'generatePlaneVertices()';
      case 'cylinder':
        return 'generateCylinderVertices(32)';
      case 'cone':
      case 'pyramid':
        return 'generateConeVertices(32)';
      case 'torus':
        return 'generateTorusVertices(32, 16)';
      default:
        return 'generateCubeVertices()';
    }
  }

  // ---------------------------------------------------------------------------
  // Composition analysis helpers
  // ---------------------------------------------------------------------------

  private compositionUsesAnchor(composition: HoloComposition): boolean {
    const check = (objs: HoloObjectDecl[] | undefined): boolean => {
      if (!objs) return false;
      return objs.some(o =>
        o.traits?.some(t => t.name === 'anchor' || t.name === 'persistent_anchor' || t.name === 'shared_anchor') ||
        check(o.children)
      );
    };
    return check(composition.objects);
  }
}
