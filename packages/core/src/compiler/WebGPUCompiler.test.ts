import { describe, it, expect, beforeEach } from 'vitest';
import { WebGPUCompiler, WebGPUCompilerOptions } from './WebGPUCompiler';
import type {
  HoloComposition,
  HoloObjectDecl,
  HoloLight,
  HoloCamera,
  HoloEnvironment,
  HoloSpatialGroup,
} from '../parser/HoloCompositionTypes';

// Helper to create a minimal composition
function createComposition(overrides: Partial<HoloComposition> = {}): HoloComposition {
  return {
    type: 'HoloComposition',
    name: 'TestScene',
    objects: [],
    ...overrides,
  } as HoloComposition;
}

// Helper to create an object declaration
function createObject(name: string, overrides: Partial<HoloObjectDecl> = {}): HoloObjectDecl {
  return {
    type: 'ObjectDecl',
    name,
    properties: [],
    traits: [],
    ...overrides,
  } as HoloObjectDecl;
}

// Helper to create a light
function createLight(
  name: string,
  lightType: string,
  properties: Array<{ key: string; value: any }> = []
): HoloLight {
  return {
    type: 'Light',
    name,
    lightType,
    properties,
  } as HoloLight;
}

// Helper to create a camera
function createCamera(properties: Array<{ key: string; value: any }> = []): HoloCamera {
  return {
    type: 'Camera',
    cameraType: 'perspective',
    properties,
  } as HoloCamera;
}

// Helper to create environment
function createEnvironment(properties: Array<{ key: string; value: any }> = []): HoloEnvironment {
  return {
    type: 'Environment',
    properties,
  } as HoloEnvironment;
}

// Helper to create spatial group
function createSpatialGroup(
  name: string,
  objects: HoloObjectDecl[],
  properties: Array<{ key: string; value: any }> = []
): HoloSpatialGroup {
  return {
    type: 'SpatialGroup',
    name,
    objects,
    properties,
  } as HoloSpatialGroup;
}

describe('WebGPUCompiler', () => {
  let compiler: WebGPUCompiler;

  beforeEach(() => {
    compiler = new WebGPUCompiler();
  });

  describe('constructor', () => {
    it('should create with default options', () => {
      expect(compiler).toBeDefined();
      expect(compiler).toBeInstanceOf(WebGPUCompiler);
    });

    it('should accept custom options', () => {
      const customCompiler = new WebGPUCompiler({
        entryPoint: 'customMain',
        enableCompute: false,
        msaa: 1,
        indent: '    ',
      });
      expect(customCompiler).toBeDefined();
    });
  });

  describe('compile', () => {
    it('should generate WebGPU code header', () => {
      const composition = createComposition({ name: 'MyScene' });
      const result = compiler.compile(composition);

      expect(result).toContain('// Auto-generated by HoloScript WebGPUCompiler');
      expect(result).toContain('// Source: composition "MyScene"');
    });

    it('should generate device initialization code', () => {
      const composition = createComposition();
      const result = compiler.compile(composition);

      expect(result).toContain('navigator.gpu.requestAdapter()');
      expect(result).toContain('adapter.requestDevice()');
      expect(result).toContain('canvas.getContext("webgpu")');
    });

    it('should configure canvas context', () => {
      const composition = createComposition();
      const result = compiler.compile(composition);

      expect(result).toContain('context.configure');
      expect(result).toContain('alphaMode: "premultiplied"');
    });

    it('should create MSAA texture with default sample count', () => {
      const composition = createComposition();
      const result = compiler.compile(composition);

      expect(result).toContain('const MSAA_COUNT = 4');
      expect(result).toContain('sampleCount: MSAA_COUNT');
    });

    it('should create MSAA texture with custom sample count', () => {
      const customCompiler = new WebGPUCompiler({ msaa: 8 });
      const composition = createComposition();
      const result = customCompiler.compile(composition);

      expect(result).toContain('const MSAA_COUNT = 8');
    });

    it('should create depth texture', () => {
      const composition = createComposition();
      const result = compiler.compile(composition);

      expect(result).toContain('depthTexture = device.createTexture');
      expect(result).toContain('format: "depth24plus"');
    });

    it('should include buffer creation helpers', () => {
      const composition = createComposition();
      const result = compiler.compile(composition);

      expect(result).toContain('function createBuffer');
      expect(result).toContain('function createStorageBuffer');
    });
  });

  describe('object compilation', () => {
    it('should compile a basic mesh object', () => {
      const composition = createComposition({
        objects: [
          createObject('myCube', {
            properties: [{ key: 'mesh', value: 'cube' }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// Object: myCube');
      expect(result).toContain('myCubeVertices');
      expect(result).toContain('myCubeVBO');
      expect(result).toContain('myCubePipeline');
    });

    it('should generate vertex buffer for cube', () => {
      const composition = createComposition({
        objects: [
          createObject('testCube', {
            properties: [{ key: 'mesh', value: 'cube' }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('generateCubeVertices');
      expect(result).toContain('GPUBufferUsage.VERTEX');
    });

    it('should generate vertex buffer for sphere', () => {
      const composition = createComposition({
        objects: [
          createObject('testSphere', {
            properties: [{ key: 'mesh', value: 'sphere' }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('generateSphereVertices');
    });

    it('should handle object position', () => {
      const composition = createComposition({
        objects: [
          createObject('positionedObj', {
            properties: [
              { key: 'mesh', value: 'cube' },
              { key: 'position', value: [5, 10, 15] },
            ],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('5,10,15,1');
    });

    it('should handle object scale', () => {
      const composition = createComposition({
        objects: [
          createObject('scaledObj', {
            properties: [
              { key: 'mesh', value: 'cube' },
              { key: 'scale', value: [2, 3, 4] },
            ],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('2,0,0,0');
      expect(result).toContain('0,3,0,0');
      expect(result).toContain('0,0,4,0');
    });

    it('should handle uniform scale', () => {
      const composition = createComposition({
        objects: [
          createObject('uniformScaledObj', {
            properties: [
              { key: 'mesh', value: 'cube' },
              { key: 'size', value: 3 },
            ],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('3,0,0,0');
      expect(result).toContain('0,3,0,0');
      expect(result).toContain('0,0,3,0');
    });

    it('should handle object color', () => {
      const composition = createComposition({
        objects: [
          createObject('coloredObj', {
            properties: [
              { key: 'mesh', value: 'cube' },
              { key: 'color', value: '#ff0000' },
            ],
          }),
        ],
      });

      const result = compiler.compile(composition);

      // Red color (1.0, 0, 0)
      expect(result).toMatch(/1(\.0+)?,0(\.0+)?,0(\.0+)?,1/);
    });

    it('should handle material roughness and metalness', () => {
      const composition = createComposition({
        objects: [
          createObject('pbrObj', {
            properties: [
              { key: 'mesh', value: 'cube' },
              { key: 'material', value: { roughness: 0.3, metalness: 0.8 } },
            ],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('0.3');
      expect(result).toContain('0.8');
    });

    it('should create render pipeline for mesh', () => {
      const composition = createComposition({
        objects: [createObject('pipelineTest', { properties: [] })],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('device.createRenderPipeline');
      expect(result).toContain('vertex:');
      expect(result).toContain('fragment:');
      expect(result).toContain('primitive:');
    });

    it('should create bind group for mesh', () => {
      const composition = createComposition({
        objects: [createObject('bindTest', { properties: [] })],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('device.createBindGroup');
      expect(result).toContain('getBindGroupLayout(0)');
    });

    it('should compile nested children', () => {
      const composition = createComposition({
        objects: [
          createObject('parent', {
            properties: [{ key: 'mesh', value: 'cube' }],
            children: [
              createObject('child', {
                properties: [{ key: 'mesh', value: 'sphere' }],
              }),
            ],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// Object: parent');
      expect(result).toContain('// Object: child');
    });
  });

  describe('GPU traits', () => {
    it('should handle gaussian_splat trait', () => {
      const composition = createComposition({
        objects: [
          createObject('splatObj', {
            traits: [
              {
                name: 'gaussian_splat',
                config: { src: 'scene.ply', max_splats: 100000 },
              },
            ],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// Gaussian Splat');
      expect(result).toContain('SplatBuf');
      expect(result).toContain('SplatPipeline');
    });

    it('should handle point_cloud trait', () => {
      const composition = createComposition({
        objects: [
          createObject('cloudObj', {
            traits: [
              {
                name: 'point_cloud',
                config: { max_points: 50000 },
              },
            ],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// Point Cloud');
      expect(result).toContain('PointBuf');
      expect(result).toContain('PointPipeline');
    });

    it('should handle gpu_particle trait', () => {
      const composition = createComposition({
        objects: [
          createObject('particleObj', {
            traits: [
              {
                name: 'gpu_particle',
                config: { count: 20000 },
              },
            ],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// GPU Particles');
      expect(result).toContain('ParticleCount = 20000');
      expect(result).toContain('ParticleBufA');
      expect(result).toContain('ParticleBufB');
      expect(result).toContain('ParticlePipeline');
    });

    it('should handle gpu_physics trait', () => {
      const composition = createComposition({
        objects: [
          createObject('physicsObj', {
            properties: [{ key: 'mesh', value: 'cube' }],
            traits: [{ name: 'gpu_physics', config: {} }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('PhysicsBuf');
      expect(result).toContain('// gpu_physics');
    });

    it('should handle compute trait', () => {
      const composition = createComposition({
        objects: [
          createObject('computeObj', {
            properties: [{ key: 'mesh', value: 'cube' }],
            traits: [
              {
                name: 'compute',
                config: { buffer_size: 8192 },
              },
            ],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('ComputeBuf');
      expect(result).toContain('8192');
    });
  });

  describe('spatial groups', () => {
    it('should compile spatial group with transform', () => {
      const composition = createComposition({
        spatialGroups: [
          createSpatialGroup(
            'myGroup',
            [createObject('groupedObj', { properties: [] })],
            [{ key: 'position', value: [10, 20, 30] }]
          ),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// Spatial Group: myGroup');
      expect(result).toContain('GroupXform');
      expect(result).toContain('10,20,30,1');
    });

    it('should compile objects within spatial group', () => {
      const composition = createComposition({
        spatialGroups: [
          createSpatialGroup('testGroup', [
            createObject('innerObj1', { properties: [{ key: 'mesh', value: 'cube' }] }),
            createObject('innerObj2', { properties: [{ key: 'mesh', value: 'sphere' }] }),
          ]),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// Object: innerObj1');
      expect(result).toContain('// Object: innerObj2');
    });

    it('should handle nested spatial groups', () => {
      const composition = createComposition({
        spatialGroups: [
          {
            ...createSpatialGroup('outerGroup', []),
            groups: [createSpatialGroup('innerGroup', [createObject('nestedObj', {})])],
          },
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// Spatial Group: outerGroup');
      expect(result).toContain('// Spatial Group: innerGroup');
    });
  });

  describe('lights', () => {
    it('should compile directional light', () => {
      const composition = createComposition({
        lights: [
          createLight('sun', 'directional', [
            { key: 'intensity', value: 2.0 },
            { key: 'color', value: '#ffffff' },
            { key: 'position', value: [10, 20, 5] },
          ]),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// Light: sun (directional)');
      expect(result).toContain('sunLight');
    });

    it('should compile point light', () => {
      const composition = createComposition({
        lights: [
          createLight('lamp', 'point', [
            { key: 'intensity', value: 1.5 },
            { key: 'position', value: [0, 5, 0] },
          ]),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// Light: lamp (point)');
    });

    it('should compile spot light', () => {
      const composition = createComposition({
        lights: [createLight('spotlight', 'spot', [{ key: 'intensity', value: 3.0 }])],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// Light: spotlight (spot)');
    });

    it('should handle light color', () => {
      const composition = createComposition({
        lights: [
          createLight('redLight', 'point', [
            { key: 'color', value: '#ff0000' },
            { key: 'intensity', value: 1.0 },
          ]),
        ],
      });

      const result = compiler.compile(composition);

      // Red color with intensity
      expect(result).toMatch(/1(\.0+)?,[0.]+,[0.]+/);
    });

    it('should handle light direction', () => {
      const composition = createComposition({
        lights: [
          createLight('downLight', 'directional', [
            { key: 'direction', value: [0, -1, 0] },
          ]),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('0,-1,0');
    });
  });

  describe('camera', () => {
    it('should compile camera with FOV', () => {
      const composition = createComposition({
        camera: createCamera([{ key: 'fov', value: 75 }]),
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// === Camera ===');
      expect(result).toContain('cameraFov = 75');
    });

    it('should handle camera position', () => {
      const composition = createComposition({
        camera: createCamera([{ key: 'position', value: [0, 5, 10] }]),
      });

      const result = compiler.compile(composition);

      expect(result).toContain('cameraPos');
      expect(result).toContain('0,5,10');
    });

    it('should handle camera look_at', () => {
      const composition = createComposition({
        camera: createCamera([{ key: 'look_at', value: [0, 0, 0] }]),
      });

      const result = compiler.compile(composition);

      expect(result).toContain('cameraTarget');
      expect(result).toContain('0,0,0');
    });

    it('should handle near and far planes', () => {
      const composition = createComposition({
        camera: createCamera([
          { key: 'near', value: 0.01 },
          { key: 'far', value: 500 },
        ]),
      });

      const result = compiler.compile(composition);

      expect(result).toContain('cameraNear = 0.01');
      expect(result).toContain('cameraFar = 500');
    });

    it('should build view projection matrix', () => {
      const composition = createComposition({
        camera: createCamera([]),
      });

      const result = compiler.compile(composition);

      expect(result).toContain('function buildViewProjection()');
      expect(result).toContain('vpUniform');
    });
  });

  describe('environment', () => {
    it('should compile environment with background color', () => {
      const composition = createComposition({
        environment: createEnvironment([{ key: 'background', value: '#1a1a2e' }]),
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// === Environment ===');
      expect(result).toContain('clearColor');
    });

    it('should handle skybox property', () => {
      const composition = createComposition({
        environment: createEnvironment([{ key: 'skybox', value: '#87ceeb' }]),
      });

      const result = compiler.compile(composition);

      expect(result).toContain('clearColor');
    });

    it('should handle fog', () => {
      const composition = createComposition({
        environment: createEnvironment([
          {
            key: 'fog',
            value: { color: '#cccccc', near: 10, far: 100 },
          },
        ]),
      });

      const result = compiler.compile(composition);

      expect(result).toContain('fogUniforms');
    });

    it('should handle ambient light', () => {
      const composition = createComposition({
        environment: createEnvironment([{ key: 'ambient_light', value: 0.5 }]),
      });

      const result = compiler.compile(composition);

      expect(result).toContain('ambientIntensity = 0.5');
    });
  });

  describe('compute shaders', () => {
    it('should emit compute pipelines for gpu_particle', () => {
      const composition = createComposition({
        objects: [
          createObject('particles', {
            traits: [{ name: 'gpu_particle', config: { count: 10000 } }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// === Compute Pipelines ===');
      expect(result).toContain('ParticleCompute');
      expect(result).toContain('createComputePipeline');
    });

    it('should calculate dispatch count for particles', () => {
      const composition = createComposition({
        objects: [
          createObject('particles', {
            traits: [{ name: 'gpu_particle', config: { count: 6400 } }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      // 6400 / 64 = 100 dispatches
      expect(result).toContain('ComputeDispatches = 100');
    });

    it('should emit compute pipeline for gpu_physics', () => {
      const composition = createComposition({
        objects: [
          createObject('physicsObj', {
            properties: [{ key: 'mesh', value: 'cube' }],
            traits: [{ name: 'gpu_physics', config: {} }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('PhysicsCompute');
      expect(result).toContain('WGSL_PHYSICS_COMPUTE');
    });

    it('should emit custom compute pipeline', () => {
      const composition = createComposition({
        objects: [
          createObject('customCompute', {
            properties: [{ key: 'mesh', value: 'cube' }],
            traits: [
              {
                name: 'compute',
                config: { shader: 'my_shader', workgroups: [32, 1, 1] },
              },
            ],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('CustomCompute');
      expect(result).toContain('my_shader');
      expect(result).toContain('[32,1,1]');
    });

    it('should not emit compute pipelines when enableCompute is false', () => {
      const noComputeCompiler = new WebGPUCompiler({ enableCompute: false });
      const composition = createComposition({
        objects: [
          createObject('particles', {
            traits: [{ name: 'gpu_particle', config: { count: 10000 } }],
          }),
        ],
      });

      const result = noComputeCompiler.compile(composition);

      expect(result).not.toContain('// === Compute Pipelines ===');
    });
  });

  describe('WGSL shaders', () => {
    it('should emit vertex shader', () => {
      const composition = createComposition({
        objects: [createObject('obj', { properties: [] })],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('const WGSL_VERTEX');
      expect(result).toContain('@vertex fn vs_main');
      expect(result).toContain('mat4x4<f32>');
    });

    it('should emit fragment shader with PBR', () => {
      const composition = createComposition({
        objects: [createObject('obj', { properties: [] })],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('const WGSL_FRAGMENT');
      expect(result).toContain('@fragment fn fs_main');
    });

    it('should emit gaussian splat shader', () => {
      const composition = createComposition({
        objects: [
          createObject('splat', {
            traits: [{ name: 'gaussian_splat', config: {} }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('const WGSL_SPLAT');
      expect(result).toContain('vs_splat');
      expect(result).toContain('fs_splat');
    });

    it('should emit point cloud shader', () => {
      const composition = createComposition({
        objects: [
          createObject('cloud', {
            traits: [{ name: 'point_cloud', config: {} }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('const WGSL_POINT');
      expect(result).toContain('vs_point');
      expect(result).toContain('fs_point');
    });

    it('should emit particle render shader', () => {
      const composition = createComposition({
        objects: [
          createObject('particles', {
            traits: [{ name: 'gpu_particle', config: {} }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('const WGSL_PARTICLE_RENDER');
      expect(result).toContain('vs_particle');
      expect(result).toContain('fs_particle');
    });

    it('should emit particle compute shader', () => {
      const composition = createComposition({
        objects: [
          createObject('particles', {
            traits: [{ name: 'gpu_particle', config: {} }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('const WGSL_PARTICLE_COMPUTE');
      expect(result).toContain('@compute');
      expect(result).toContain('cs_particle_update');
    });

    it('should emit physics compute shader', () => {
      const composition = createComposition({
        objects: [
          createObject('physics', {
            properties: [{ key: 'mesh', value: 'cube' }],
            traits: [{ name: 'gpu_physics', config: {} }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('const WGSL_PHYSICS_COMPUTE');
      expect(result).toContain('cs_physics_step');
    });
  });

  describe('render loop', () => {
    it('should generate render loop', () => {
      const composition = createComposition({
        objects: [createObject('obj', { properties: [] })],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// === Render Loop ===');
      expect(result).toContain('function frame()');
      expect(result).toContain('requestAnimationFrame(frame)');
    });

    it('should create command encoder', () => {
      const composition = createComposition({
        objects: [createObject('obj', { properties: [] })],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('device.createCommandEncoder()');
    });

    it('should begin render pass', () => {
      const composition = createComposition({
        objects: [createObject('obj', { properties: [] })],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('enc.beginRenderPass');
      expect(result).toContain('colorAttachments');
      expect(result).toContain('depthStencilAttachment');
    });

    it('should emit draw calls for mesh objects', () => {
      const composition = createComposition({
        objects: [
          createObject('cube1', { properties: [{ key: 'mesh', value: 'cube' }] }),
          createObject('sphere1', { properties: [{ key: 'mesh', value: 'sphere' }] }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('rp.setPipeline(cube1Pipeline)');
      expect(result).toContain('rp.draw(cube1VertexCount)');
      expect(result).toContain('rp.setPipeline(sphere1Pipeline)');
      expect(result).toContain('rp.draw(sphere1VertexCount)');
    });

    it('should emit draw calls for splat objects', () => {
      const composition = createComposition({
        objects: [
          createObject('splat', {
            traits: [{ name: 'gaussian_splat', config: {} }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('rp.setPipeline(splatSplatPipeline)');
      expect(result).toContain('rp.draw(4');
    });

    it('should emit draw calls for particle objects', () => {
      const composition = createComposition({
        objects: [
          createObject('particles', {
            traits: [{ name: 'gpu_particle', config: {} }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('rp.setPipeline(particlesParticlePipeline)');
      expect(result).toContain('rp.setVertexBuffer');
      expect(result).toContain('rp.draw(particlesParticleCount)');
    });

    it('should include compute pass when enabled', () => {
      const composition = createComposition({
        objects: [
          createObject('particles', {
            traits: [{ name: 'gpu_particle', config: {} }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('const cp = enc.beginComputePass()');
      expect(result).toContain('cp.setPipeline');
      expect(result).toContain('cp.dispatchWorkgroups');
      expect(result).toContain('cp.end()');
    });

    it('should submit command buffer', () => {
      const composition = createComposition({
        objects: [createObject('obj', { properties: [] })],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('device.queue.submit');
      expect(result).toContain('enc.finish()');
    });

    it('should include frame counter and time', () => {
      const composition = createComposition();
      const result = compiler.compile(composition);

      expect(result).toContain('let frameCount = 0');
      expect(result).toContain('frameCount++');
      expect(result).toContain('const time = ');
    });
  });

  describe('color parsing', () => {
    it('should parse hex colors', () => {
      const composition = createComposition({
        objects: [
          createObject('redObj', {
            properties: [
              { key: 'mesh', value: 'cube' },
              { key: 'color', value: '#ff0000' },
            ],
          }),
        ],
      });

      const result = compiler.compile(composition);

      // Should contain approximately 1.0, 0.0, 0.0 for red
      expect(result).toMatch(/1(\.0+)?,0(\.0+)?,0(\.0+)?/);
    });

    it('should parse array colors', () => {
      const composition = createComposition({
        objects: [
          createObject('greenObj', {
            properties: [
              { key: 'mesh', value: 'cube' },
              { key: 'color', value: [0, 1, 0] },
            ],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('0,1,0');
    });
  });

  describe('name sanitization', () => {
    it('should sanitize names with special characters in variable names', () => {
      const composition = createComposition({
        objects: [
          createObject('my-object.name', {
            properties: [{ key: 'mesh', value: 'cube' }],
          }),
        ],
      });

      const result = compiler.compile(composition);

      // Variable names should be sanitized
      expect(result).toContain('my_object_nameVertices');
      expect(result).toContain('my_object_nameVBO');
      expect(result).toContain('my_object_namePipeline');

      // Original name can appear in comments
      expect(result).toContain('// Object: my-object.name');
    });
  });

  describe('geometry types', () => {
    const geometryTypes = ['cube', 'sphere', 'orb', 'plane', 'cylinder', 'cone', 'pyramid', 'torus'];

    geometryTypes.forEach((geoType) => {
      it(`should handle ${geoType} geometry`, () => {
        const composition = createComposition({
          objects: [
            createObject(`${geoType}Obj`, {
              properties: [{ key: 'mesh', value: geoType }],
            }),
          ],
        });

        const result = compiler.compile(composition);

        expect(result).toContain(`// Object: ${geoType}Obj`);
        expect(result).toContain('Vertices');
      });
    });
  });

  describe('edge cases', () => {
    it('should handle empty composition', () => {
      const composition = createComposition({
        name: 'EmptyScene',
        objects: [],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// Auto-generated');
      expect(result).toContain('requestAnimationFrame(frame)');
    });

    it('should handle composition with only environment', () => {
      const composition = createComposition({
        environment: createEnvironment([{ key: 'background', value: '#000000' }]),
      });

      const result = compiler.compile(composition);

      expect(result).toContain('clearColor');
    });

    it('should handle empty object name', () => {
      const composition = createComposition({
        objects: [createObject('', { properties: [{ key: 'mesh', value: 'cube' }] })],
      });

      const result = compiler.compile(composition);

      // Should still compile with sanitized empty name
      expect(result).toContain('Vertices');
    });

    it('should handle very long object names', () => {
      const longName = 'a'.repeat(100);
      const composition = createComposition({
        objects: [createObject(longName, { properties: [{ key: 'mesh', value: 'cube' }] })],
      });

      const result = compiler.compile(composition);

      expect(result).toContain(`// Object: ${longName}`);
    });

    it('should handle unicode characters in names', () => {
      const composition = createComposition({
        objects: [
          createObject('日本語オブジェクト', {
            properties: [{ key: 'mesh', value: 'cube' }],
          }),
        ],
      });

      // Unicode gets sanitized to underscores
      expect(() => compiler.compile(composition)).not.toThrow();
    });

    it('should handle deeply nested spatial groups', () => {
      const deepGroup: any = createSpatialGroup('level5', [
        createObject('deepObj', { properties: [{ key: 'mesh', value: 'cube' }] }),
      ]);

      for (let i = 4; i >= 1; i--) {
        const wrapper = createSpatialGroup(`level${i}`, []);
        wrapper.groups = [deepGroup];
      }

      const composition = createComposition({
        spatialGroups: [deepGroup],
      });

      expect(() => compiler.compile(composition)).not.toThrow();
    });

    it('should handle many objects', () => {
      const objects = Array.from({ length: 50 }, (_, i) =>
        createObject(`obj${i}`, { properties: [{ key: 'mesh', value: 'cube' }] })
      );

      const composition = createComposition({ objects });
      const result = compiler.compile(composition);

      expect(result).toContain('// Object: obj0');
      expect(result).toContain('// Object: obj49');
    });

    it('should handle multiple GPU traits on same object', () => {
      const composition = createComposition({
        objects: [
          createObject('multiGPU', {
            properties: [{ key: 'mesh', value: 'cube' }],
            traits: [
              { name: 'gpu_physics', config: {} },
              { name: 'compute', config: { buffer_size: 4096 } },
            ],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('PhysicsBuf');
      expect(result).toContain('ComputeBuf');
    });

    it('should handle extreme position values', () => {
      const composition = createComposition({
        objects: [
          createObject('extremePos', {
            properties: [
              { key: 'mesh', value: 'cube' },
              { key: 'position', value: [1e10, -1e10, 0] },
            ],
          }),
        ],
      });

      expect(() => compiler.compile(composition)).not.toThrow();
    });

    it('should handle zero scale', () => {
      const composition = createComposition({
        objects: [
          createObject('zeroScale', {
            properties: [
              { key: 'mesh', value: 'cube' },
              { key: 'scale', value: [0, 0, 0] },
            ],
          }),
        ],
      });

      expect(() => compiler.compile(composition)).not.toThrow();
    });

    it('should handle negative scale', () => {
      const composition = createComposition({
        objects: [
          createObject('negativeScale', {
            properties: [
              { key: 'mesh', value: 'cube' },
              { key: 'scale', value: [-1, -1, -1] },
            ],
          }),
        ],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('-1,0,0,0');
    });

    it('should handle invalid color format gracefully', () => {
      const composition = createComposition({
        objects: [
          createObject('invalidColor', {
            properties: [
              { key: 'mesh', value: 'cube' },
              { key: 'color', value: 'not-a-color' },
            ],
          }),
        ],
      });

      // Should fall back to white
      expect(() => compiler.compile(composition)).not.toThrow();
    });

    it('should handle missing light properties', () => {
      const composition = createComposition({
        lights: [createLight('minimalLight', 'point', [])],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('// Light: minimalLight');
    });

    it('should handle camera with no properties', () => {
      const composition = createComposition({
        camera: createCamera([]),
      });

      const result = compiler.compile(composition);

      // Should use defaults
      expect(result).toContain('cameraFov = 60');
      expect(result).toContain('cameraNear = 0.1');
      expect(result).toContain('cameraFar = 1000');
    });

    it('should handle gpu_particle with zero count', () => {
      const composition = createComposition({
        objects: [
          createObject('zeroParticles', {
            traits: [{ name: 'gpu_particle', config: { count: 0 } }],
          }),
        ],
      });

      expect(() => compiler.compile(composition)).not.toThrow();
    });

    it('should handle all light types', () => {
      const lightTypes = ['directional', 'point', 'spot', 'hemisphere', 'ambient', 'area'];
      const composition = createComposition({
        lights: lightTypes.map((t, i) => createLight(`light${i}`, t, [])),
      });

      const result = compiler.compile(composition);

      for (let i = 0; i < lightTypes.length; i++) {
        expect(result).toContain(`// Light: light${i}`);
      }
    });

    it('should handle fog with missing properties', () => {
      const composition = createComposition({
        environment: createEnvironment([
          { key: 'fog', value: {} },
        ]),
      });

      const result = compiler.compile(composition);

      // Should use default fog values
      expect(result).toContain('fogUniforms');
    });

    it('should handle composition with all features combined', () => {
      const composition = createComposition({
        environment: createEnvironment([{ key: 'background', value: '#1a1a2e' }]),
        objects: [
          createObject('cube', { properties: [{ key: 'mesh', value: 'cube' }] }),
          createObject('particles', { traits: [{ name: 'gpu_particle', config: { count: 1000 } }] }),
        ],
        lights: [createLight('sun', 'directional', [{ key: 'intensity', value: 1.0 }])],
        camera: createCamera([{ key: 'fov', value: 60 }]),
        spatialGroups: [createSpatialGroup('group1', [createObject('inner', {})])],
      });

      const result = compiler.compile(composition);

      expect(result).toContain('clearColor');
      expect(result).toContain('// Object: cube');
      expect(result).toContain('// GPU Particles');
      expect(result).toContain('// Light: sun');
      expect(result).toContain('cameraFov');
      expect(result).toContain('// Spatial Group: group1');
    });
  });
});
