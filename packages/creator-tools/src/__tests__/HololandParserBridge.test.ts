/**
 * Hololand Parser Bridge Tests
 * 
 * Tests for Phase 6 trait system integration with Hololand parser
 * Covers code generation, registration, validation, and error recovery
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import { HololandParserBridge, type DeviceOptimizationContext } from '../HololandParserBridge'
import { TraitAnnotationEditor } from '../TraitAnnotationEditor'
import { mockMaterialConfig, mockDevices, PerformanceMeasure } from './setup'

describe('HololandParserBridge', () => {
  let editor: TraitAnnotationEditor
  let bridge: HololandParserBridge
  let performanceMeasure: PerformanceMeasure

  const mockDeviceContext: DeviceOptimizationContext = {
    deviceId: 'test-device',
    gpuCapability: 'high',
    cpuCapability: 'high',
    targetFPS: 60,
    maxGPUMemory: 512,
    supportedShaderLevel: 'es3',
  }

  beforeEach(() => {
    editor = new TraitAnnotationEditor(mockMaterialConfig)
    bridge = new HololandParserBridge(editor)
    performanceMeasure = new PerformanceMeasure()
  })

  afterEach(() => {
    performanceMeasure.clear()
  })

  describe('Code Generation', () => {
    it('should generate HSPlus code', () => {
      const code = bridge.generateHoloScriptPlusCode()
      expect(code).toBeDefined()
      expect(code.length).toBeGreaterThan(0)
    })

    it('should generate valid HSPlus syntax', () => {
      const code = bridge.generateHoloScriptPlusCode()
      expect(code).toMatch(/@material|@trait|@shader/)
    })

    it('should include imports when requested', () => {
      const code = bridge.generateHoloScriptPlusCode({ generateImports: true })
      expect(code).toContain('import')
      expect(code).toContain('@hololand/traits')
    })

    it('should exclude imports when not requested', () => {
      const code = bridge.generateHoloScriptPlusCode({ generateImports: false })
      // Should still have trait code but no imports
      expect(code).toMatch(/@material|@trait/)
    })

    it('should include metadata when requested', () => {
      const code = bridge.generateHoloScriptPlusCode({ includeMetadata: true })
      expect(code).toContain('Generated by Phase 6 Trait Editor')
      expect(code).toContain('Timestamp:')
    })

    it('should generate consistent code', () => {
      const code1 = bridge.generateHoloScriptPlusCode()
      const code2 = bridge.generateHoloScriptPlusCode()
      expect(code1).toEqual(code2)
    })

    it('should generate code in <100ms', () => {
      performanceMeasure.start('codeGen')
      bridge.generateHoloScriptPlusCode()
      const duration = performanceMeasure.end('codeGen')

      expect(duration).toBeLessThan(100)
    })
  })

  describe('Device Optimization', () => {
    it('should register device', () => {
      bridge.registerDevice(mockDeviceContext)
      expect(bridge).toBeDefined()
    })

    it('should register multiple devices', () => {
      mockDevices.forEach((device, idx) => {
        bridge.registerDevice({
          ...mockDeviceContext,
          deviceId: device.id,
          maxGPUMemory: device.specs.gpuMemoryMB,
        })
      })
      expect(bridge).toBeDefined()
    })

    it('should optimize for low-end GPU', () => {
      const lowEndContext: DeviceOptimizationContext = {
        deviceId: 'low-end',
        gpuCapability: 'low',
        cpuCapability: 'medium',
        targetFPS: 30,
        maxGPUMemory: 256,
        supportedShaderLevel: 'es2',
      }

      const code = bridge.generateHoloScriptPlusCode({
        optimizeForDevice: lowEndContext,
      })

      expect(code).toBeDefined()
    })

    it('should optimize for high-end GPU', () => {
      const highEndContext: DeviceOptimizationContext = {
        deviceId: 'high-end',
        gpuCapability: 'extreme',
        cpuCapability: 'extreme',
        targetFPS: 120,
        maxGPUMemory: 8192,
        supportedShaderLevel: 'core',
      }

      const code = bridge.generateHoloScriptPlusCode({
        optimizeForDevice: highEndContext,
      })

      expect(code).toBeDefined()
    })

    it('should add optimization comments', () => {
      const code = bridge.generateHoloScriptPlusCode({
        optimizeForDevice: mockDeviceContext,
        includeMetadata: true,
      })

      expect(code).toContain('Optimization hints for device')
      expect(code).toContain(mockDeviceContext.deviceId)
    })
  })

  describe('Parser Registration', () => {
    it('should register trait with parser', () => {
      const result = bridge.registerTraitWithParser('test-trait')
      expect(result.success).toBe(true)
      expect(result.traitId).toBe('test-trait')
    })

    it('should return registration metadata', () => {
      const result = bridge.registerTraitWithParser('test-trait')
      expect(result.metadata).toBeDefined()
      expect(result.metadata?.estimatedMemory).toBeGreaterThan(0)
    })

    it('should assess performance impact', () => {
      const result = bridge.registerTraitWithParser('test-trait')
      expect(result.metadata?.performanceImpact).toMatch(/low|medium|high/)
    })

    it('should handle duplicate registration', () => {
      const result1 = bridge.registerTraitWithParser('dup-trait')
      const result2 = bridge.registerTraitWithParser('dup-trait')

      expect(result1.success).toBe(true)
      expect(result2.success).toBe(true) // Should succeed on re-registration
    })

    it('should store registered trait code', () => {
      bridge.registerTraitWithParser('stored-trait')
      const code = bridge.getRegisteredTraitCode('stored-trait')

      expect(code).toBeDefined()
      expect(code).toContain('@material')
    })

    it('should retrieve all registered traits', () => {
      bridge.registerTraitWithParser('trait1')
      bridge.registerTraitWithParser('trait2')
      bridge.registerTraitWithParser('trait3')

      const all = bridge.getAllRegisteredTraits()
      expect(all.size).toBe(3)
    })
  })

  describe('Code Validation', () => {
    it('should validate valid code', () => {
      const code = bridge.generateHoloScriptPlusCode()
      const validation = bridge.validateHoloScriptPlus(code)

      expect(validation.valid).toBe(true)
      expect(validation.errors.length).toBe(0)
    })

    it('should detect missing decorators', () => {
      const invalidCode = 'metallic: 0.5\nroughness: 0.8'
      const validation = bridge.validateHoloScriptPlus(invalidCode)

      expect(validation.warnings.length).toBeGreaterThan(0)
    })

    it('should detect unbalanced braces', () => {
      const invalidCode = '@material { \n metallic: 0.5'
      const validation = bridge.validateHoloScriptPlus(invalidCode)

      expect(validation.valid).toBe(false)
      expect(validation.errors.length).toBeGreaterThan(0)
    })

    it('should detect undefined references', () => {
      const invalidCode = '@material { value: undefined }'
      const validation = bridge.validateHoloScriptPlus(invalidCode)

      expect(validation.errors.length).toBeGreaterThan(0)
    })

    it('should warn on code size', () => {
      const largeCode = '@material { ' + 'x: 1, '.repeat(50000) + ' }'
      const validation = bridge.validateHoloScriptPlus(largeCode)

      // Should have warnings but might still be valid
      expect(validation.warnings.length).toBeGreaterThan(0)
    })

    it('should validate in <50ms', () => {
      const code = bridge.generateHoloScriptPlusCode()
      performanceMeasure.start('validate')
      bridge.validateHoloScriptPlus(code)
      const duration = performanceMeasure.end('validate')

      expect(duration).toBeLessThan(50)
    })
  })

  describe('Error Handling', () => {
    it('should capture validation errors', () => {
      const invalidCode = '@material { }'
      bridge.validateHoloScriptPlus(invalidCode)
      const errors = bridge.getValidationErrors()

      // Should have some validation data collected
      expect(errors).toBeDefined()
    })

    it('should clear errors', () => {
      const invalidCode = '@material { value: undefined }'
      bridge.validateHoloScriptPlus(invalidCode)

      bridge.clearErrors()
      const errors = bridge.getValidationErrors()

      // Errors should be cleared
      expect(errors.length).toBeLessThanOrEqual(0)
    })

    it('should limit error history', () => {
      // Generate multiple errors
      for (let i = 0; i < 20; i++) {
        bridge.validateHoloScriptPlus(`invalid${i}`)
      }

      const errors = bridge.getValidationErrors(5)
      expect(errors.length).toBeLessThanOrEqual(5)
    })

    it('should distinguish recoverable errors', () => {
      const unbalancedCode = '@material { value: 1'
      const validation = bridge.validateHoloScriptPlus(unbalancedCode)

      const hasRecoverable = validation.errors.some((e) => e.recoverable)
      expect(hasRecoverable).toBe(true)
    })
  })

  describe('Error Recovery', () => {
    it('should recover from syntax errors', () => {
      const error = {
        type: 'syntax' as const,
        message: 'Missing braces',
        recoverable: true,
      }

      const recovered = bridge.recoverFromError(error)
      expect(recovered).toBeDefined()
    })

    it('should recover from semantic errors', () => {
      const error = {
        type: 'semantic' as const,
        message: 'Undefined reference',
        recoverable: true,
      }

      const recovered = bridge.recoverFromError(error)
      expect(recovered).toBeDefined()
    })

    it('should not recover non-recoverable errors', () => {
      const error = {
        type: 'runtime' as const,
        message: 'Critical error',
        recoverable: false,
      }

      const recovered = bridge.recoverFromError(error)
      expect(recovered).toBeUndefined()
    })

    it('should generate valid code after recovery', () => {
      const error = {
        type: 'syntax' as const,
        message: 'Invalid syntax',
        recoverable: true,
      }

      const recovered = bridge.recoverFromError(error)
      if (recovered) {
        const validation = bridge.validateHoloScriptPlus(recovered)
        // Recovered code should be more valid
        expect(validation.errors.length).toBeLessThanOrEqual(2)
      }
    })
  })

  describe('Strict Mode', () => {
    it('should allow validation errors in non-strict mode', () => {
      const code = bridge.generateHoloScriptPlusCode({
        strictMode: false,
      })

      expect(code).toBeDefined()
    })

    it('should validate errors in strict mode', () => {
      const validCode = bridge.generateHoloScriptPlusCode({
        strictMode: true,
      })

      expect(validCode).toBeDefined()
    })

    it('should generate fallback code in non-strict mode', () => {
      const code = bridge.generateHoloScriptPlusCode({
        strictMode: false,
      })

      // Should fallback to base code
      expect(code.length).toBeGreaterThan(0)
    })
  })

  describe('Memory Estimation', () => {
    it('should estimate memory usage', () => {
      const code = bridge.generateHoloScriptPlusCode()
      const result = bridge.registerTraitWithParser('mem-test')

      expect(result.metadata?.estimatedMemory).toBeGreaterThan(0)
      expect(typeof result.metadata?.estimatedMemory).toBe('number')
    })

    it('should account for textures in memory estimate', () => {
      editor.updateProperty('baseColor', '#ff0000')
      const result = bridge.registerTraitWithParser('texture-test')

      expect(result.metadata?.estimatedMemory).toBeGreaterThan(0)
    })

    it('should vary memory by property complexity', () => {
      const result1 = bridge.registerTraitWithParser('simple')

      editor.updateProperty('metallic', 0.5)
      const result2 = bridge.registerTraitWithParser('complex')

      // Complex should use same or more memory
      expect(result2.metadata?.estimatedMemory).toBeGreaterThanOrEqual(
        result1.metadata?.estimatedMemory || 0
      )
    })
  })

  describe('Import/Export', () => {
    it('should export registration data', () => {
      bridge.registerTraitWithParser('export-test')
      const data = bridge.exportRegistrationData()

      expect(data).toBeDefined()
      expect(typeof data).toBe('string')
    })

    it('should export valid JSON', () => {
      bridge.registerTraitWithParser('json-test')
      const data = bridge.exportRegistrationData()

      const parsed = JSON.parse(data)
      expect(parsed.traits).toBeDefined()
      expect(Array.isArray(parsed.traits)).toBe(true)
    })

    it('should include timestamp in export', () => {
      bridge.registerTraitWithParser('timestamp-test')
      const data = bridge.exportRegistrationData()

      const parsed = JSON.parse(data)
      expect(parsed.timestamp).toBeDefined()
    })

    it('should import registration data', () => {
      bridge.registerTraitWithParser('original-trait')
      const exported = bridge.exportRegistrationData()

      const newBridge = new HololandParserBridge(editor)
      const success = newBridge.importRegistrationData(exported)

      expect(success).toBe(true)
      expect(newBridge.getRegisteredTraitCode('original-trait')).toBeDefined()
    })

    it('should handle invalid JSON on import', () => {
      const bridge2 = new HololandParserBridge(editor)
      const success = bridge2.importRegistrationData('invalid json')

      expect(success).toBe(false)
    })

    it('should round-trip data correctly', () => {
      bridge.registerTraitWithParser('roundtrip')
      bridge.registerDevice(mockDeviceContext)

      const exported = bridge.exportRegistrationData()
      const newBridge = new HololandParserBridge(editor)
      newBridge.importRegistrationData(exported)

      const reimported = newBridge.exportRegistrationData()
      expect(reimported).toEqual(exported)
    })
  })

  describe('Performance', () => {
    it('should validate trait registration in <100ms', () => {
      performanceMeasure.start('register')
      bridge.registerTraitWithParser('perf-test')
      const duration = performanceMeasure.end('register')

      expect(duration).toBeLessThan(100)
    })

    it('should handle 100 registrations in <1 second', () => {
      performanceMeasure.start('bulk')
      for (let i = 0; i < 100; i++) {
        bridge.registerTraitWithParser(`trait-${i}`)
      }
      const duration = performanceMeasure.end('bulk')

      expect(duration).toBeLessThan(1000)
    })

    it('should optimize code consistently', () => {
      const durations: number[] = []

      for (let i = 0; i < 50; i++) {
        performanceMeasure.start('opt')
        bridge.generateHoloScriptPlusCode({
          optimizeForDevice: mockDeviceContext,
        })
        durations.push(performanceMeasure.end('opt'))
      }

      const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length
      expect(avgDuration).toBeLessThan(50)
    })
  })

  describe('Integration Scenarios', () => {
    it('should complete full registration workflow', () => {
      // 1. Generate code
      const code = bridge.generateHoloScriptPlusCode({
        generateImports: true,
        includeMetadata: true,
      })
      expect(code).toBeDefined()

      // 2. Validate code
      const validation = bridge.validateHoloScriptPlus(code)
      expect(validation.valid).toBe(true)

      // 3. Register trait
      const result = bridge.registerTraitWithParser('workflow-test')
      expect(result.success).toBe(true)

      // 4. Export data
      const exported = bridge.exportRegistrationData()
      expect(exported).toBeDefined()
    })

    it('should handle device optimization workflow', () => {
      // 1. Register device
      bridge.registerDevice(mockDeviceContext)

      // 2. Generate optimized code
      const optimized = bridge.generateHoloScriptPlusCode({
        optimizeForDevice: mockDeviceContext,
      })
      expect(optimized).toBeDefined()

      // 3. Validate optimized code
      const validation = bridge.validateHoloScriptPlus(optimized)
      expect(validation.valid).toBe(true)
    })

    it('should handle error recovery workflow', () => {
      // 1. Generate code
      const code = bridge.generateHoloScriptPlusCode()

      // 2. Validate
      const validation = bridge.validateHoloScriptPlus(code)

      // 3. If errors, recover
      if (validation.errors.length > 0) {
        const recovered = bridge.recoverFromError(validation.errors[0])
        expect(recovered).toBeDefined()
      }
    })

    it('should handle multi-device registration', () => {
      const devices = [
        { ...mockDeviceContext, deviceId: 'iphone', gpuCapability: 'low' as const },
        { ...mockDeviceContext, deviceId: 'ipad', gpuCapability: 'medium' as const },
        { ...mockDeviceContext, deviceId: 'quest', gpuCapability: 'medium' as const },
        { ...mockDeviceContext, deviceId: 'visionpro', gpuCapability: 'high' as const },
        { ...mockDeviceContext, deviceId: 'hololens', gpuCapability: 'medium' as const },
        { ...mockDeviceContext, deviceId: 'rtx4090', gpuCapability: 'extreme' as const },
      ]

      devices.forEach(device => {
        bridge.registerDevice(device)
      })

      // Register trait for each device
      devices.forEach(device => {
        const result = bridge.registerTraitWithParser(`trait-${device.deviceId}`)
        expect(result.success).toBe(true)
      })

      const allTraits = bridge.getAllRegisteredTraits()
      expect(allTraits.size).toBe(devices.length)
    })
  })

  describe('Edge Cases', () => {
    it('should handle empty configuration', () => {
      const emptyEditor = new TraitAnnotationEditor({
        type: 'material' as const,
        properties: {},
        isDirty: false,
      })
      const emptyBridge = new HololandParserBridge(emptyEditor)

      const code = emptyBridge.generateHoloScriptPlusCode()
      expect(code).toBeDefined()
    })

    it('should handle very large code generation', () => {
      const result = bridge.registerTraitWithParser('large-trait')
      expect(result.success).toBe(true)
    })

    it('should handle rapid consecutive registrations', () => {
      for (let i = 0; i < 20; i++) {
        const result = bridge.registerTraitWithParser(`rapid-${i}`)
        expect(result.success).toBe(true)
      }
    })

    it('should handle Unicode in trait IDs', () => {
      const result = bridge.registerTraitWithParser('trait-é-ñ-ü')
      expect(result.success).toBe(true)
    })
  })
})
